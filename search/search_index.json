{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This document extends the Practical Labs provided by Bootlin. Their courses for embedded system development are really good, and what I appreciate the most is their open source approach. On one hand, their paid trainnig sessions are valuable for professionals, and to have live support from their team, which is expected for the many paid courses available all around the world. On the other hand, having the very same training material released as open source really gives more opportunity to spread knowledge on such complex topics even for students, hobbyists, and us amateurs in general! We all love free open source stuff!</p> <p>I decided to write this to complement some missing information, updated or alternative procedures while performing the labs. I'm doing this also because I find it the best way to really learn stuff: read, apply, modify, describe!</p> <p>I strongly recommend to read Bootlin's slides before practicing with the labs!</p> <p>I'm going to follow the Embedded Linux System Development - QEMU variant, so that anybody can try stuff without buying any physical boards. The course provided by Bootlin, as per March 2023, isn't the most updated one of theirs, which is for the STM32MP1 boards instead.</p> <p>Since old and new versions of the course cover variants of the same topics, and I find all those variants valuable knowledge, I'm willing to provide such variants as well.</p> <p>I own a BeagleBone Black rev.C board, so I'm willing to extend this document for it \u2014 I'm not going to buy yet another board right now!</p>"},{"location":"#style-and-conventions","title":"Style and conventions","text":"<p>This is an informal document, so that it can feel closer to the user. I try my best to be clean and precise about what is describe. The topics covered here are very complex, and the actual purpose of this document is for me to consolidate my knowledge while writing these notes. I'm not an expert \u2014 rather, I'm still studying all of this \u2014 so there can be mistakes or unclear parts. Furthermore, English isn't my native language.</p> <p>New terms are indicated in italics the first time they're introduced, or to distinguish them from plain text.</p> <p>Important text is marked with bold.</p> <p>The reference Linux shell is bash. We usually type <code>~</code> instead of <code>$HOME</code>. The following is a shell code block:</p> <pre><code>$ echo \"Shell command line from a generic user\"\n# echo \"Shell command line from the root user\"\n</code></pre> <p>Sometimes I'm going to use shell variables to make command lines shorter and with added semantics, easily editable.</p> <pre><code>$ VARIABLE_USED_BY_FOLLOWING_CODE_BLOCKS=\"...\"\n$ variable_used_only_within_this_code_block=\"...\"\n</code></pre> <p>When using variables I typically enclose string expressions within quotes to improve readability, despite quotes usually being optional.</p> <pre><code>$ MY_PATH=\"/this/is/my/path\"\n$ MY_PATH=/quotes/not/required\n$ echo $MY_PATH/direct/use/\n$ echo \"${MY_PATH}/braces/and/quotes/to/improve/readability\"\n</code></pre> <p>Very long command lines can be wrapped. I leave two spaces before the wrapping <code>\\</code>, or between command line options, to give a better visual cue.</p> <pre><code>$ some-command  --option first  --option second  --option third\n$ echo Some commands can be split  \\\ninto multiple lines,  \\\nto improve readability\n</code></pre> <p>When creating small text files, I usually prefer to pass the content via command line, as in:</p> <pre><code>$ cat  &gt; file.txt  &lt;&lt;'EOF'\nHere's some text that's going to\nbecome the content of the\n\"file.txt\" text file,\nas soon as the user puts\nan 'EOF' on a standalone line.\nEOF\n$ cat file.txt\nHere's some text that's going to\nbecome the content of the\n\"file.txt\" text file,\nas soon as the user puts\nan 'EOF' on a standalone line.\n</code></pre> <p>An untitled shell block usually represents a shell running on the Linux host machine. In case of a shell running on a different machine, like a QEMU guest or a remote shell, or even file content, that shell is given a title:</p> picocomBBB - BusyBox<pre><code>$ echo \"I'm a BusyBox shell running on the remote BeagleBone Black board!\"\n$ echo \"You can use me because you're connected to me via serial connection with `picocom`!\"\n</code></pre> ssh - Debian<pre><code>$ echo \"I'm a BASH shell running on the remote Debian board!\"\n$ echo \"You can use me because you're connected to me via SSH!\"\n</code></pre> QEMU - U-Boot<pre><code>=&gt; echo \"I'm an U-Boot prompt running on the emulated target board!\"\n=&gt; echo \"You can use me because you're running QEMU on your host machine!\"\n</code></pre> script.sh<pre><code>#!/bin/sh\necho \"Hello $USER! I'm a shell script file!\"\n</code></pre> <p>Inline code: <code>int main(int argc, char *argv[]);</code>.</p>"},{"location":"#backups","title":"Backups","text":"<p>I created a Google Drive folder where I put backup copies of relevant outputs, tools, and files mentioned within the documents, in case they cannot be retrieved the standard way (e.g. broken git reposifory, or unreachable sites).</p> <p>https://drive.google.com/drive/folders/1DhCmpQT-Sus44rgsjVs82BA0bJSz8-eV?usp=share_link</p>"},{"location":"copying/","title":"Copying this document","text":"<p>\u00a9 2023, Andrea Zoppi. </p> <p>This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License. This means that you are free to download, distribute and even modify it, under certain conditions.</p> <p>Most of the content is an extension to the tutorials by Bootlin, published under the same license:</p> <p>\u00a9 2004-2023, Bootlin, https://bootlin.com/. </p>"},{"location":"bbb/appdev/","title":"App - Development","text":"<p>TODO: THIS DOCUMENT IS STILL JUST A DRAFT!</p>"},{"location":"bbb/appdev/#objectives","title":"Objectives","text":"<ul> <li>Compile an application against a Buildroot build space and debug it remotely.</li> </ul>"},{"location":"bbb/appdev/#required-tools","title":"Required tools","text":"<ul> <li> <p>Ubuntu packages:</p> <p><code>snap</code> and those from the previous labs.</p> </li> <li> <p>snap packages:</p> <p><code>code</code> (Visual Studio Code)</p> </li> <li> <p>The root filesystem and NFS setup from the integration course.</p> </li> </ul>"},{"location":"bbb/appdev/#setup","title":"Setup","text":"<p>We will continue to use the same root filesystem.</p> <p>Our goal is to compile and debug our own MPD client. This client will be driven by the Nunckuk to switch between audio tracks, and to adjust the playback volume.</p> <p>However, this client will be used together with mpc, as it won't be able to create the playlist and start the playback. It will just be used to control the volume and switch between songs. So, you need to run <code>mpc</code> commands first before trying the new client:</p> picocomBBB - systemd<pre><code># mpc update\n# mpc add /\n# mpc pause\n</code></pre> <p>We will use the new client to resume playback.</p>"},{"location":"bbb/appdev/#compile-your-own-application","title":"Compile your own application","text":"<p>Go to the <code>$HOME/embedded-linux-bbb-labs/appdev</code> directory.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/appdev\"\n</code></pre> <p>In the lab directory the file <code>nunchuk-mpd-client.c</code> contains an application which implements a simple MPD client based on the libmpdclient library. As MPC is also based on this library, Buildroot already compiled it and added it to our root filesystem. What's special in this application is that it allows to drive music playback through our Nunchuk.</p> <p>Buildroot has generated toolchain wrappers in <code>output/host/bin/</code>, which make it easier to use the toolchain, since these wrappers pass some mandatory flags, especially the <code>--sysroot gcc</code> flag, which tells GCC where to look for headers and libraries. This way, we can compile our application outside Buildroot, as often as we want.</p> <p>Let's add this directory to our <code>PATH</code>, and try to compile the application.</p> <pre><code>$ export PATH=\"$LAB_PATH/../integration/buildroot/output/host/bin:$PATH\"\n$ cd $LAB_PATH\n$ arm-linux-gcc -o nunchuk-mpd-client nunchuk-mpd-client.c\n    ...\nnunchuk-mpd-client.c:(.text+0x28): undefined reference to `mpd_connection_get_error_message'\n    ...\ncollect2: error: ld returned 1 exit status\n</code></pre> <p>The compiler complains about undefined references to some symbols in <code>libmpdclient</code>. This is normal, since we didn't tell the compiler to link with this library. So, let's use <code>pkg-config</code> to query its database about the list of libraries needed to build an application against <code>libmpdclient</code>. Again, <code>output/host/bin/</code> has a special <code>pkg-config</code> that automatically knows where to look, so it already knows the right paths to find <code>.pc</code> files and their sysroot.</p> <pre><code>$ arm-linux-gcc -o nunchuk-mpd-client nunchuk-mpd-client.c  \\\n    $(pkg-config --libs libmpdclient)\n</code></pre> <p>Copy the <code>nunchuk-mpd-client</code> executable to the <code>/root</code> directory of the root filesystem, and then strip it.</p> <pre><code>$ NFSROOT=\"$LAB_PATH/../integration/nfsroot\"\n$ cp nunchuk-mpd-client \"$NFSROOT/root/\"\n$ arm-linux-strip \"$NFSROOT/root/nunchuk-mpd-client\"\n</code></pre> <p>Back to target system, try to run the program:</p> picocomBBB - systemd<pre><code># /root/nunchuk-mpd-client\nERROR: didn't manage to find the Nunchuk device in /dev/input. Is the Nunchuk driver loaded?\n</code></pre>"},{"location":"bbb/appdev/#enable-debugging-tools","title":"Enable debugging tools","text":"<p>In order to debug our application, let's make Buildroot build some debugging tools for our root filesystem. This is also an opportunity to enable <code>perf</code>, that we are using later on during this lab.</p> <p>Go back to the Buildroot configuration interface and enable the following options:</p> <ul> <li> <p>In <code>Kernel</code> \u2192 <code>Linux Kernel Tools</code>:</p> <ul> <li>Enable <code>perf</code>.</li> </ul> </li> <li> <p>In <code>Target packages</code> \u2192 <code>Debugging, profiling and benchmark</code>:</p> <ul> <li>Enable <code>ltrace</code>.</li> <li>Enable <code>strace</code>.</li> </ul> </li> </ul> <p>Then rebuild and update your root filesystem.</p> <pre><code>$ BUILDROOT=\"$LAB_PATH/../integration/buildroot\"\n$ cd $BUILDROOT\n$ make menuconfig\n$ cp .config \"$LAB_PATH/buildroot-appdev.config\"\n$ make\n$ cp output/images/zImage /srv/tftp/\n$ cd $NFSROOT\n$ sudo rm -rf *\n$ tar xfv \"$BUILDROOT/output/images/rootfs.tar\"\n$ cp \"$LAB_PATH/nunchuk-mpd-client\" \"$NFSROOT/root/\"\n</code></pre>"},{"location":"bbb/appdev/#using-strace","title":"Using strace","text":"<p>Let's run the program through the <code>strace</code> command to find out why this happens.</p> picocomBBB - systemd<pre><code># strace /root/nunchuk-mpd-client\n    ...\nopenat(AT_FDCWD, \"/dev/event0\", O_RDONLY) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/dev/event1\", O_RDONLY) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/dev/event2\", O_RDONLY) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/dev/event3\", O_RDONLY) = -1 ENOENT (No such file or directory)\nwrite(2, \"ERROR: didn't manage to find the\"..., 93ERROR: didn't manage to find the Nunchuk device in /dev/input. Is the Nunchuk driver loaded?\n) = 93\nexit_group(1)                           = ?\n+++ exited with 1 +++\n</code></pre> <p>You should see that it's trying to access files that don't exist: it's looking for <code>/dev/event0</code>, while the actual file is at <code>/dev/input/event0</code>! So, let's fix the source code from <code>\"/dev/%s\"</code> to <code>\"/dev/input/%s\"</code>:</p> File: nunchuk-mpd-client.c - fixed input device path<pre><code>/*...*/\nint main(int argc, char ** argv)\n{\n/*...*/\n/* Find Nunchuk input device */\nndev = scandir(\"/dev/input\", &amp;namelist, is_event_device, alphasort);\n/*...*/\nfor (i = 0; i &lt; ndev; i++)\n{\n/*...*/\nsnprintf(fname, sizeof(fname), \"/dev/input/%s\", namelist[i]-&gt;d_name);\n/*...*/\n}\n/*...*/\n}\n/*...*/\n</code></pre> <pre><code>$ cd $LAB_PATH\n$ sed -i 's|\"/dev/%s\"|\"/dev/input/%s\"|' nunchuk-mpd-client.c\n$ arm-linux-gcc  -o nunchuk-mpd-client  nunchuk-mpd-client.c  $(pkg-config --libs libmpdclient)\n$ cp nunchuk-mpd-client \"$NFSROOT/root/\"\n</code></pre> <p>Rebuild the program and run it again (no need to strip for our debug sessions):</p> picocomBBB - systemd<pre><code># /root/nunchuk-mpd-client\nERROR: didn't manage to find the Nunchuk device in /dev/input. Is the Nunchuk driver loaded?\n</code></pre> <p>Ouch, same problem again!</p> <p>You can run the program again through <code>strace</code>, and check that the right paths are now accessed, but the cause of the issue might be tricky to find.</p> picocomBBB - systemd<pre><code># strace /root/nunchuk-mpd-client\n    ...\nopenat(AT_FDCWD, \"/dev/input/event0\", O_RDONLY) = 3\nioctl(3, EVIOCGNAME(256), \"tps65217_pwrbutton\\0\") = 19\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/dev/input/event1\", O_RDONLY) = 3\nioctl(3, EVIOCGNAME(256), \"Wii Nunchuk\\0\") = 12\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/dev/input/event2\", O_RDONLY) = 3\nioctl(3, EVIOCGNAME(256), \"Logitech Inc. Logitech USB Heads\"...) = 57\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/dev/input/event3\", O_RDONLY) = 3\nioctl(3, EVIOCGNAME(256), \"Logitech Inc. Logitech USB Heads\"...) = 40\nclose(3)                                = 0\nwrite(2, \"ERROR: didn't manage to find the\"..., 93ERROR: didn't manage to find the Nunchuk device in /dev/input. Is the Nunchuk driver loaded?\n) = 93\nexit_group(1)                           = ?\n+++ exited with 1 +++\n</code></pre> <p>If you didn't spot the bug, <code>ltrace</code> might help you!</p>"},{"location":"bbb/appdev/#using-ltrace","title":"Using ltrace","text":"<p>Let's run the program through <code>ltrace</code> now. We will be able to see the shared library calls. Take your time to study the ltrace output. That's interesting information! Back to our issue, the last lines of output should make the issue pretty obvious.</p> picocomBBB - systemd<pre><code># ltrace /root/nunchuk-mpd-client\n    ...\nsnprintf(\"/dev/input/event1\", 256, \"/dev/input/%s\", \"event1\") = 17\nfree(0x49b228)                                   = &lt;void&gt;\nopen(\"/dev/input/event1\", 0, 022230010)          = 3\nioctl(3, -2130688762, 0xbef8fb9c)                = 12\nstrcmp(\"Wii Nunchuck\", \"Wii Nunchuk\")            = -8\nclose(3)\n    ...\n</code></pre> <p>The for loop within the program should stop at the first instance of a device named <code>\"Wii Nunchuck\"</code>... and indeed, there are none, because it's called <code>\"Wii Nunchuk\"</code> instead! This was clearly a typo, let's fix it!</p> <pre><code>$ cd $LAB_PATH\n$ sed -i \"s/Nunchuck/Nunchuk/\" nunchuk-mpd-client.c\n$ arm-linux-gcc  -o nunchuk-mpd-client  nunchuk-mpd-client.c  $(pkg-config --libs libmpdclient)\n$ cp nunchuk-mpd-client \"$NFSROOT/root/\"\n</code></pre> <p>You should now be able to use the new client, driving the server through the following Nunchuk inputs:</p> <ul> <li>Joystick up: volume up 5%</li> <li>Joystick down: volume down 5%</li> <li>Joystick left: previous song</li> <li>Joystick right: next song</li> <li>Z (big) button: pause / play</li> <li>C (small) button: quit client!</li> </ul> picocomBBB - systemd<pre><code># /root/nunchuk-mpd-client\n# /root/nunchuk-mpd-client\nConnection successful\nPlay/Pause\nQuit\n[ 2804.673441] audit: type=1701 audit(1683378416.277:7): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=235 comm=\"nunchuk-mpd-cli\" exe=\"/root/nunchuk-mpd-client\" sig=11 res=1\nSegmentation fault\n</code></pre> <p>Have fun with the new client. You'll just realize that quitting causes the program to crash with a segmentation fault. Let's debug this too, this time via <code>gdbserver</code>.</p>"},{"location":"bbb/appdev/#using-gdbserver","title":"Using gdbserver","text":"<p>We are going to use <code>gdbserver</code> to understand why the program segfaults.</p> <p>Compile <code>nunchuk-mpd-client.c</code> again with the <code>-g</code> (<code>g</code> means <code>gdb</code>) option to include debugging symbols. This time, just keep it on your workstation, as you already have the version without debugging symbols on your target.</p> <pre><code>$ cd $LAB_PATH\n$ arm-linux-gcc  -g  -o nunchuk-mpd-client  nunchuk-mpd-client.c  $(pkg-config --libs libmpdclient)\n</code></pre> <p>Then, on the target side, run the program under <code>gdbserver</code>. <code>gdbserver</code> will listen on a TCP port for a connection from <code>gdb</code> on the host, and will control the execution of <code>nunchuk-mpd-client</code> according to the <code>gdb</code> commands.</p> picocomBBB - systemd<pre><code># gdbserver localhost:2345 /root/nunchuk-mpd-client\nProcess /root/nunchuk-mpd-client created; pid = 179\nListening on port 2345\n</code></pre> <p>On the host side, run <code>arm-linux-gdb</code> (also found in your toolchain):</p> <pre><code>$ arm-linux-gdb nunchuk-mpd-client\nGNU gdb (GDB) 11.1\n    ...\nReading symbols from nunchuk-mpd-client...\n(gdb)\n</code></pre> <p><code>gdb</code> starts and loads the debugging information from the <code>nunchuk-mpd-client</code> binary (in the <code>appdev</code> directory), which was compiled with <code>-g</code>.</p> <p>Then, we need to tell where to find our libraries, since they are not present in the default <code>/lib/</code> and <code>/usr/lib/</code> directories on your workstation. This is done by setting the <code>sysroot</code> variable (on one line; replace <code>&lt;user&gt;</code> with your user name). Then, tell <code>gdb</code> to connect to the remote system.</p> <pre><code>(gdb) set sysroot /home/&lt;user&gt;/embedded-linux-bbb-labs/integration/buildroot/output/staging\n(gdb) target remote 192.168.0.69:2345\nRemote debugging using 192.168.0.69:2345\nReading symbols from /home/me/embedded-linux-bbb-labs/integration/buildroot/output/staging/lib/ld-linux-armhf.so.3...\n0xb6fc88c0 in _start ()\n   from /home/me/embedded-linux-bbb-labs/integration/buildroot/output/staging/lib/ld-linux-armhf.so.3\n</code></pre> <p>Then, use <code>gdb</code> as usual to set breakpoints, look at the source code, run the application step by step, etc. In our case, we'll just start the program and press the C (small) button to quit and trigger the segmentation fault:</p> <pre><code>(gdb) continue\nContiniung.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb6fb3690 in mpd_settings_free () from /home/me/embedded-linux-bbb-labs/integration/buildroot/output/staging/lib/libmpdclient.so.2\n</code></pre> <p>After the segmentation fault, you can ask for a backtrace to see where this happened:</p> <pre><code>(gdb) backtrace\n#0  0xb6fb3690 in mpd_settings_free ()\n   from /home/me/embedded-linux-bbb-labs/integration/buildroot/output/staging/lib/libmpdclient.so.2\n#1  0xb6fa8548 in mpd_connection_free ()\n   from /home/me/embedded-linux-bbb-labs/integration/buildroot/output/staging/lib/libmpdclient.so.2\n#2  0x00401300 in main (argc=1, argv=0xbefffe24) at nunchuk-mpd-client.c:167\n</code></pre> <p>This will tell you that the segmentation fault occurred in a function of the <code>libmpdclient</code>, called by our program. You will also get the number of the line in the program which caused this. This should help you to find the bug in our application.</p> File: nunchuk-mpd-client.c<pre><code>/*...*/\ncase BTN_C:\nif (event.value == 1) {\nprintf(\"Quit\\n\");\nquit = 1;\nfree(conn);\n}\nbreak;\n/*...*/\n/* Close connection */\nmpd_connection_free(conn);  /* __LINE__ == 167 */\n/*...*/\n</code></pre> <p>Obviously, the <code>mpd_connection_free()</code> function was provided a pointer to some memory that was already unallocated with <code>free()</code>. We're going to fix this bug later on, after learning how to use more tools.</p> <p>You can now quit <code>gdb</code>.</p> <pre><code>(gdb) quit\nA debugging session is active.\n\n        Inferior 1 [process 179] will be killed.\n\nQuit anyway? (y or n) y\n</code></pre>"},{"location":"bbb/appdev/#post-mortem-analysis","title":"Post mortem analysis","text":"<p>Configure your shell on the target to get a core file dumped when you run <code>nunchuk-mpd-client</code> again.</p> picocomBBB - systemd<pre><code># ulimit -c unlimited\n# echo \"nunchuk-mpd-client.core\" &gt; /proc/sys/kernel/core_pattern\n# /root/nunchuk-mpd-client\nConnection successful\nQuit\n[ 1617.932592] audit: type=1701 audit(1683388582.214:2): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=194 comm=\"nunchuk-mpd-cli\" exe=\"/root/nunchuk-mpd-client\" sig=11 res=1\nSegmentation fault (core dumped)\n# du -h nunchuk-mpd-client.core*\n124.0K  nunchuk-mpd-client.core.194\n# chmod a+r nunchuk-mpd-client.core.194\n</code></pre> <p>Once you have such a file, inspect it with <code>arm-linux-gdb</code> on the host, set the <code>sysroot</code> setting, and then generate a backtrace to see where the program crashed. This way, you can have information about the crash without running the program through the debugger.</p> <p>Because the executable on the target does not contain debug information (it was compiled without the <code>-g</code> option), and because the core dump holds the absolute paths of the target, we have to emulate the state of the target sysroot somehow. One way works by copying the debug executable and the core dump to the corresponding places within the <code>staging</code> folder by Buildroot. With <code>set sysroot</code>, <code>gdb</code> sees the debug files as if they were there on the fake target.</p> Folder structure excerpts to analyze our core dump<pre><code>[TARGET]\n/                                       &lt;&lt;&lt;  host NFS: $NFSROOT\n\u251c\u2500\u2500 lib/\n|   \u2514\u2500\u2500 libmpdclient.so.2\n\u2514\u2500\u2500 root/\n \u00a0\u00a0 \u251c\u2500\u2500 nunchuk-mpd-client              &lt;&lt;&lt;  without debug symbols\n    \u2514\u2500\u2500 nunchuk-mpd-client.core.194\n\n[HOST]\nbuildroot/output/staging/               &lt;&lt;&lt;  gdb: sysroot\n\u251c\u2500\u2500 lib/\n|   \u2514\u2500\u2500 libmpdclient.so.2\n\u2514\u2500\u2500 root/\n \u00a0\u00a0 \u251c\u2500\u2500 nunchuk-mpd-client              &lt;&lt;&lt;  with debug symbols, copied from: $LAB_PATH/data/\n    \u2514\u2500\u2500 nunchuk-mpd-client.core.194     &lt;&lt;&lt;  copied from: $NFSROOT/root/\n</code></pre> <p>Here's the sequence of operations, switching between the shell and <code>gdb</code>:</p> <pre><code>$ cd \"$BUILDROOT/output/staging/root/\"\n$ cp \"$LAB_PATH/nunchuk-mpd-client\" ./\n$ cp \"$NFSROOT/root/nunchuk-mpd-client.core.194\" ./\n$ arm-linux-gdb  -ex \"set sysroot $BUILDROOT/output/staging\"\n    ...\n</code></pre> <pre><code>(gdb) file nunchuk-mpd-client\nReading symbols from nunchuk-mpd-client...\n(gdb) core-file nunchuk-mpd-client.core.194\nwarning: core file may not match specified executable file.\n[New LWP 194]\nCore was generated by `/root/nunchuk-mpd-client'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0xb6f6c690 in mpd_settings_free ()\n   from /home/me/embedded-linux-bbb-labs/appdev/../integration/buildroot/output/staging/lib/libmpdclient.so.2\n(gdb) backtrace full\n#0  0xb6f6c690 in mpd_settings_free ()\n   from /home/me/embedded-linux-bbb-labs/appdev/../integration/buildroot/output/staging/lib/libmpdclient.so.2\nNo symbol table info available.\n#1  0xb6f61548 in mpd_connection_free ()\n   from /home/me/embedded-linux-bbb-labs/appdev/../integration/buildroot/output/staging/lib/libmpdclient.so.2\nNo symbol table info available.\n#2  0x00421300 in main (argc=1, argv=0xbea46e24) at nunchuk-mpd-client.c:167\n        conn = 0x4331c0\n        i = 1\n        ndev = 4\n        ret = 16\n        fd = 3\n        quit = 1\n        num_events = 1\n        event = {time = {tv_sec = 1683388582, tv_usec = 224672}, type = 1, code = 306, value = 1}\n        namelist = 0x43b1b\n(gdb) set confirm off\n(gdb) quit\n</code></pre> <pre><code>$ cd \"$BUILDROOT/output/staging/root/\"\n$ rm nunchuk-mpd-client*\n</code></pre> <p>You can even see the value of all variables in the different function contexts of your program. This way, you can have a lot of information about the crash without running the program through the debugger.</p>"},{"location":"bbb/appdev/#visual-studio-code","title":"Visual Studio Code","text":""},{"location":"bbb/appdev/#installing-software","title":"Installing software","text":"<p>We are going to use Visual Studio Code to do the remote debugging again, and eventually fix and recompile our program.</p> <p>The first thing to do is install VSC. This package is only available as a snap package:</p> <pre><code>$ sudo apt install snap\n$ sudo snap install --classic code\n</code></pre>"},{"location":"bbb/appdev/#accessing-your-board-through-ssh","title":"Accessing your board through SSH","text":"<p>We will use Visual Studio Code to modify and recompile our client program, and also to update and run the binary on the target. Of course, we will use a simple solution, as we won't be able to spend too much time learning about all the possibilities offered by VSC.</p> <p>For our purpose, a good solution is SSH, which allows to copy files (via the <code>scp</code> command) and to run remote commands. We already included the Dropbear SSH server in our root filesystem.</p> <p>We just need to implement password-less SSH access, to keep things simple:</p> <p>Generate a password-less one with the <code>ssh-keygen</code> command, named <code>id_rsa_empty</code>. We're creating two files in <code>~/.ssh/</code>: <code>id_rsa_empty</code> (private key) and <code>id_rsa_empty.pub</code> (public key).</p> <pre><code>$ ssh-keygen -t rsa -f ~/.ssh/id_rsa_empty\nGenerating public/private rsa key pair.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/me/.ssh/id_rsa_empty\nYour public key has been saved in /home/me/.ssh/id_rsa_empty.pub\nThe key fingerprint is:\nSHA256:MMNVi/JBFlFTv6DpuCpx6zj/WGceGDr7Q6k0ThcBUqo me@vm\n    ...\n</code></pre> <p>Then, create the <code>/root/.ssh/</code> directory on the target, and in it create an <code>authorized_keys</code> file with the line in <code>id_rsa_empty.pub</code>.</p> <pre><code># sudo chmod -R a+rwx \"$NFSROOT/root/\"\n$ cd \"$NFSROOT/root/\"\n$ mkdir -p .ssh/\n$ cat ~/.ssh/id_rsa_empty.pub &gt; .ssh/authorized_keys\n</code></pre> <p>Finally, fix permissions on the target, as Dropbear is quite strict about them:</p> picocomBBB - systemd<pre><code># chmod -R go-rwx /root\n# chown -R root.root /root\n</code></pre> <p>Then, you can test that SSH works without a password:</p> <pre><code>$ ssh -i ~/.ssh/id_rsa_empty root@192.168.0.69\n</code></pre> <p>If you face trouble, you can check the Dropbear logs on the target (Ctrl+C to exit <code>journalctl</code>). For example, here we once tried to connect with the wrong SSH identity, then we retied with the authorized one:</p> picocomBBB - systemd<pre><code># journalctl -fu dropbear\nMay 06 19:13:21 buildroot dropbear[179]: Child connection from 192.168.0.15:48928\nMay 06 19:13:22 buildroot dropbear[179]: User account 'root' is locked\nMay 06 19:13:24 buildroot dropbear[179]: Exit before auth from &lt;192.168.0.15:48928&gt;: (user 'root', 1 fails): Exited normally\nMay 06 19:22:39 buildroot dropbear[190]: Child connection from 192.168.0.15:46688\nMay 06 19:22:40 buildroot dropbear[190]: Pubkey auth succeeded for 'root' with key sha1!! 12:f0:db:23:34:dc:60:f1:7a:1a:d5:0c:f8:a2:dc:aa:37:97:36:0e from 192.168.0.15:46688\n</code></pre>"},{"location":"bbb/appdev/#compiling-and-debugging","title":"Compiling and debugging","text":"<p>The <code>appdev/</code> lab directory already contains a <code>prep-debug.sh</code> script and a <code>.vscode/</code> directory with ready made settings for code editing and for compiling and debugging our application.</p> <p>Here are these files:</p> <ul> <li><code>prep-debug.sh</code>: script to recompile the program, copy it to the target through SSH, and start it through the debugger.   Open this file and update the target IP and path settings if necessary.   Since we're using a custom SSH identity, add <code>-i ~/.ssh/id_rsa_empty</code> to the SSH commands (<code>ssh</code> and <code>scp</code>).   The result should look like:</li> </ul> File: prep-debug.sh - adapted to this lab<pre><code>#!/bin/sh\n# Definitions\nTARGETIP=\"192.168.0.69\"\nPATH=\"$HOME/embedded-linux-bbb-labs/integration/buildroot/output/host/bin:$PATH\"\nEXEC=nunchuk-mpd-client\nCROSS_COMPILE=arm-linux-\nSSHID=\"~/.ssh/id_rsa_empty\"\n# Rebuild executable\n${CROSS_COMPILE}gcc -g -o $EXEC $EXEC.c $(pkg-config --libs --cflags libmpdclient)\n# Kill gdbserver on the target\nssh -i $SSHID root@$TARGETIP killall gdbserver\n\n# Copy over new executable\nscp -i $SSHID $EXEC root@$TARGETIP:/root/\n\n# Start gdbserver on the target\nssh -i $SSHID -n -f root@$TARGETIP \"sh -c 'nohup gdbserver localhost:2345 /root/nunchuk-mpd-client &gt; /dev/null 2&gt;&amp;1 &amp;'\"\n</code></pre> <ul> <li> <p><code>.vscode/c_cpp_properties.json</code>: settings for the code editor.   Modify the paths in this file according to your setup.</p> </li> <li> <p><code>.vscode/tasks.json</code>: definition of a <code>build</code> task, calling the <code>prep-debug.sh</code> script.</p> </li> <li> <p><code>.vscode/launch.json</code>: these are the settings for remote debugging.   Again, open this file, update the paths, and the target IP address if necessary.</p> </li> </ul> <p>Start Visual Studio Code:</p> <pre><code>$ code\n</code></pre> <p>Use <code>File</code> \u2192 <code>Open Folder</code> to open the <code>appdev/</code> directory.</p> <p>The first thing to do is to make sure the C/C++ extension from Microsoft (<code>ms-vscode.cpptools</code>) is installed. Do this using the Extensions vertical tab.</p> <p>Then click on the <code>nunchuk-mpd-client.c</code> file in the left column to open it in VSC.</p> <p>Now, start by compiling your program from VSC, copying it to the target, and running it through the debugger by using the <code>Terminal</code> \u2192 <code>Run Build Task...</code> menu entry.</p> <p>Last but not least, you can start debugging the program by clicking on the <code>Run and Debug</code> tab, and then on the <code>gdb (Launch)</code> at the top.</p> <p>In the debug console, you should see that debugging has started. The bottom line of the interface should turn orange too.</p> <p>Then, start using the Nunchuk to control playback, and when you try to quit with the C button, VSC should now see the segmentation fault.</p> <p>You can then look at variables, the call stack, browse the code, et cetera...</p> <p>To stop debugging, you should use <code>Run</code> \u2192 <code>Stop Debugging</code>.</p> <p>By studing the the code, you should eventually find that what's causing the segmentation fault is the call to <code>free()</code> in the test for the C button. Remove this line, save the file through the <code>File</code> menu (otherwise nothing will change), and then compile and run the application again. This time, there should be no more segmentation fault when you hit the C button.</p> <p>If you are ahead of time, don't hesitate to spend more time with VSC, for example to add breakpoints and execute the program step-by-step.</p>"},{"location":"bbb/appdev/#profiling-the-application-with-perf","title":"Profiling the application with perf","text":"<p>Let's connect to the target via SSH for the best user experience.</p> <pre><code>$ ssh -i ~/.ssh/id_rsa_empty root@192.168.0.69\n</code></pre> <p>Let's make a quick attempt at profiling our application with the <code>perf</code> command:</p> ssh - systemd<pre><code># perf record /root/nunchuk-mpd-client\n</code></pre> <p>Use your application and leave it when you are done.</p> <p>This stores profiling data in a <code>perf.data</code> file. One way to extract information from it is to run the below command in the same directory (the one containing <code>perf.data</code>):</p> ssh - systemd<pre><code># perf report\n</code></pre> <pre><code># To display the perf.data header info, please use --header/--header-only options.\n#\n#\n# Total Lost Samples: 0\n#\n# Samples: 43  of event 'cycles'\n# Event count (approx.): 8939291\n#\n# Overhead  Command          Shared Object        Symbol\n# ........  ...............  ...................  ...............................\n#\n     5.75%  nunchuk-mpd-cli  ld-linux-armhf.so.3  [.] _dl_relocate_object\n     5.57%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] getname_flags\n     5.47%  nunchuk-mpd-cli  ld-linux-armhf.so.3  [.] strcmp\n     5.35%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] __mutex_init\n     5.33%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] __fsnotify_inode_delete\n     4.80%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] _raw_spin_lock\n     4.72%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] down_read_trylock\n     4.56%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] _raw_spin_unlock_irqrestore\n     3.86%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] next_uptodate_page\n     3.72%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] queue_work_on\n     3.67%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] release_pages\n     3.24%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] __anon_vma_prepare\n     3.24%  nunchuk-mpd-cli  ld-linux-armhf.so.3  [.] _dl_name_match_p\n     2.83%  nunchuk-mpd-cli  ld-linux-armhf.so.3  [.] do_lookup_x\n     2.82%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] do_page_fault\n     2.82%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] v7_flush_icache_all\n     2.81%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] __audit_syscall_exit\n     2.81%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] xas_find\n     2.80%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] tcp_write_xmit\n     2.80%  nunchuk-mpd-cli  libc.so.6            [.] getenv\n     2.80%  nunchuk-mpd-cli  libc.so.6            [.] strlen\n     2.56%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] expand_downwards\n     2.07%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] core_sys_select\n     2.07%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] syscall_trace_exit\n     2.07%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] vfs_write\n     1.86%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] mark_page_accessed\n     1.86%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] skb_unlink\n     1.86%  nunchuk-mpd-cli  libc.so.6            [.] __fdelt_warn\n     1.75%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] __flush_work\n     1.70%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] tcp_ack\n     0.37%  nunchuk-mpd-cli  [kernel.kallsyms]    [k] set_cred_ucounts\n     0.06%  perf-exec        [kernel.kallsyms]    [k] perf_event_exec\n\n#\n# (Cannot load tips.txt file, please install perf!)\n#\n\n~\n</code></pre> <p>See the time spent in various kernel (<code>[k]</code>) and userspace (<code>[.]</code>) functions.</p> <p>Now, let's profile the whole system. First, make sure that the system is currently playing audio. Then SSH to your board and run <code>perf top</code> (working better through SSH) to see live information about kernel and userspace functions consuming most CPU time.</p> <p>This is interactive, but hard to analyze. You can also run <code>perf record</code> for about 30 seconds, followed by <code>perf report</code> to have a useful summary of system wide activity for a substantial amount of time.</p> <p>This was a very brief start at practising with <code>perf</code>, which offers many more possibilities than we could see here.</p>"},{"location":"bbb/appdev/#what-to-remember","title":"What to remember","text":"<p>During this lab, we learned that...</p> <ul> <li> <p>It's easy to study the behavior of programs and diagnose issues without even having the source code, thanks to strace, ltrace and perf.</p> </li> <li> <p>You can use <code>perf</code> as a system wide profiler too.</p> </li> <li> <p>You can leave a small <code>gdbserver</code> program (about 400 KB) on your target that allows to debug target applications, using a standard <code>gdb</code> debugger on the development host, or a graphical IDE such as Visual Studio Code.</p> </li> <li> <p>It is fine to strip applications and binaries on the target machine, as long as the programs and libraries with debugging symbols are available on the development host.</p> </li> <li> <p>Thanks to core dumps, you can know where a program crashed, without having to reproduce the issue by running the program through the debugger.</p> </li> </ul>"},{"location":"bbb/appdev/#packaging-with-meson","title":"Packaging with Meson","text":"<p>Now that our application is ready, the next thing to do is to properly integrate it into our root filesystem. This is a nice opportunity to see how to do this with Meson and leverage Buildroot's infrastructure to cross-compile Meson based packages.</p> <p>Still in the main <code>appdev/</code> directory, create a <code>nunchuk-mpd-client-1.0/</code> directory and copy the <code>nunchuk-mpd-client.c</code> file to it. In this new directory, all you have to do is create a very simple <code>meson.build</code> file.</p> <pre><code>$ mkdir -p \"$LAB_PATH/nunchuk-mpd-client-1.0/\"\n$ cd $_\n$ cp ../nunchuk-mpd-client.c .\n$ nano meson.build\n</code></pre> File: meson.build<pre><code>project('nunchuk-mpd-client', 'c', version: '1.0')\nlibmpdclient_dep = dependency('libmpdclient', version: '&gt;= 2.16')\nexecutable('nunchuk-mpd-client', 'nunchuk-mpd-client.c',\ndependencies: libmpdclient_dep, install: true)\n</code></pre> <p>Note that <code>install: true</code> is necessary to get the executable installed by <code>ninja install</code>.</p> <p>Now, the next thing is to add a new package to the Buildroot source tree.</p> <p>Create a <code>nunchuk-mpd-client</code> directory under <code>package/</code>. In this directory, create a <code>Config.in</code> file. You can reuse the one from the <code>mpd-mpc</code> package (the <code>mpc</code> client) which also depends on <code>libmpdclient</code>.</p> <pre><code>$ mkdir -p \"$BUILDROOT/package/nunchuk-mpd-client/\"\n$ cd $_\n$ cp ../mpd-mpc/Config.in .\n$ nano Config.in\n</code></pre> File: Config.in<pre><code>config BR2_PACKAGE_NUNCHUK_MPD_CLIENT\n        bool \"nunchuk-mpd-client\"\nselect BR2_PACKAGE_LIBMPDCLIENT\n        help\n          A minimalist Nintendo Nunchuk interface to MPD.\n          https://bootlin.com/doc/training/embedded-linux-bbb/\n</code></pre> <p>Modify <code>package/Config.in</code> to source this new file in the <code>Audio and video applications</code> submenu.</p> <pre><code>$ nano ../Config.in\n</code></pre> File: package/Config.in - added package<pre><code>    ...\nmenu \"Audio and video applications\"\n...\n        source \"package/musepack/Config.in\"\nsource \"package/ncmpc/Config.in\"\nsource \"package/nunchuk-mpd-client/Config.in\"\nsource \"package/omxplayer/Config.in\"\nsource \"package/on2-8170-libs/Config.in\"\n...\n</code></pre> <p>Last but not least, create the <code>nunchuk-mpd-client.mk</code>.</p> <pre><code>$ nano nunchuk-mpd-client.mk\n</code></pre> File: nunchuk-mpd-client.mk<pre><code>NUNCHUK_MPD_CLIENT_VERSION = 1.0\nNUNCHUK_MPD_CLIENT_SITE = $(HOME)/embedded-linux-bbb-labs/appdev/nunchuk-mpd-client-1.0\nNUNCHUK_MPD_CLIENT_SITE_METHOD = local\nNUNCHUK_MPD_CLIENT_DEPENDENCIES = host-pkgconf libmpdclient\n\n$(eval $(meson-package))\n</code></pre> <p>All you have to do now is to enable the <code>nunchuk-mpd-client</code> package in Buildroot's configuration, run <code>make</code>, update the root filesystem and check on the target that <code>/usr/bin/nunchuk-mpd-client</code> exists and runs fine.</p> <pre><code>$ cd $BUILDROOT\n$ make menuconfig\n$ cp .config \"$LAB_PATH/buildroot-nunchuk-mpd-client.config\"\n$ make\n$ cp output/images/zImage /srv/tftp/\n$ cd $NFSROOT\n$ sudo rm -rf *\n$ tar xfv \"$BUILDROOT/output/images/rootfs.tar\"\n</code></pre> picocomBBB - systemd<pre><code># reboot\n    ...\n# which nunchuk-mpd-client\n/usr/bin/nunchuk-mpd-client\n# nunchuk-mpd-client\nConnection successful\nQuit\nConnection terminated\n</code></pre> <p>All this was pretty straightforward, wasn't it? Meson rocks!</p> <p>Congratulations, you've reached the end of all our labs. Try to look back, and see how much experience you've gained in these last days.</p>"},{"location":"bbb/appdev/#backup-and-restore","title":"Backup and restore","text":"<p>TODO: git commit + bundle</p> <p>TODO: add missing files and folders to tar xz</p> <pre><code>$ cd \"$BUILDROOT/output/images/\"\n$ tar cfJv \"$LAB_PATH/appdev-images.tar.xz\" *\n</code></pre>"},{"location":"bbb/appdev/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/blockfs/","title":"Block Filesystems","text":""},{"location":"bbb/blockfs/#objectives","title":"Objectives","text":"<ul> <li> <p>Produce filesystem images.</p> </li> <li> <p>Configure the kernel to use these filesystems.</p> </li> <li> <p>Use the <code>tmpfs</code> filesystem to store temporary files.</p> </li> <li> <p>Load the kernel and DTB from a FAT partition.</p> </li> </ul> <p>After doing the BusyBox lab, we are going to copy the filesystem contents to the emulated SD card. The storage will be split into several partitions, and your QEMU emulated board will be booted from this SD card, without using NFS anymore.</p>"},{"location":"bbb/blockfs/#setup","title":"Setup","text":"<p>Throughout this lab, we will continue to use the root filesystem we have created in the <code>$HOME/embedded-linux-bbb-labs/tinysystem/nfsroot</code> directory, which we will progressively adapt to use block filesystems.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/tinysystem\"\n</code></pre>"},{"location":"bbb/blockfs/#filesystem-support-in-the-kernel","title":"Filesystem support in the kernel","text":"<p>Make sure that your kernel supports SquashFS (<code>SQUASHFS</code>) and ext4 (<code>EXT4_FS</code>). Basic configuration options for these filesystems will be sufficient; no need for things like extended attributes.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux\"\n$ grep -r \"\\bCONFIG_SQUASHFS\\b\" .config\n# CONFIG_SQUASHFS is not set\n$ grep -r \"\\bCONFIG_EXT4_FS\\b\" .config\nCONFIG_EXT4_FS=y\n</code></pre> <p>If necessary, recompile and update your kernel image on the TFTP server. We will only later copy the kernel to our FAT partition.</p> <pre><code>$ cp \"$LAB_PATH/../hardware/kernel-leds.config\" .config\n$ make menuconfig\n$ cp .config \"$LAB_PATH/kernel-blockfs.config\"\n$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export MAKEFLAGS=-j$(nproc)\n$ export ARCH=arm\n$ make\n$ cp arch/arm/boot/zImage /srv/tftp/zImage-with-blockfs\n$ cp arch/arm/boot/zImage /srv/tftp/zImage\n</code></pre> <p>Boot your board on the NFS filesystem you used in this previous lab. Now, check the contents of <code>/proc/filesystems</code>. You should see that ext4 and SquashFS are supported.</p> picocomBBB - BusyBox<pre><code># cat /proc/filesystems\nnodev   sysfs\nnodev   tmpfs\nnodev   bdev\nnodev   proc\nnodev   cgroup\nnodev   cgroup2\nnodev   cpuset\nnodev   devtmpfs\nnodev   binfmt_misc\nnodev   configfs\nnodev   debugfs\nnodev   tracefs\nnodev   sockfs\nnodev   pipefs\nnodev   ramfs\nnodev   rpc_pipefs\nnodev   devpts\n        ext3\n        ext4\n        ext2\n        cramfs\n        squashfs\n        vfat\n        msdos\nnodev   nfs\nnodev   nfs4\nnodev   jffs2\nnodev   mqueue\nnodev   ubifs\n</code></pre> <p>You can now <code>halt</code> the board and disconnect, so that you can remove the SD card to be formatted.</p>"},{"location":"bbb/blockfs/#format-the-third-partition","title":"Format the third partition","text":"<p>We are going to format the third partition of the SD card image with the EXT4 filesystem, so that it can contain uploaded images.</p> <p>Plug the SD card again. With the bootloader tutorial we alredy created the partition, but now we're going to format it.</p> <pre><code>$ SDCARD_DEV=\"/dev/mmcblk0\"\n$ SDCARD_DEVP=\"${SDCARD_DEV}p\"\n</code></pre> <p>If using an USB SD card reader, remember to follow the instructions of the bootloader tutorial. In my case, the device is <code>/dev/sdd</code>.</p> <pre><code>$ SDCARD_DEV=\"/dev/sdd\"\n$ SDCARD_DEVP=\"${SDCARD_DEV}\"\n</code></pre> <pre><code>$ sudo partprobe\n$ sudo umount ${SDCARD_DEVP}*\n$ sudo mkfs.ext4 -L data \"${SDCARD_DEVP}3\"\n    ...\n</code></pre> <p>Mount this partition on a directory on your host (you could create the <code>/mnt/www_upload_files</code> directory, for example) and move the contents of the <code>/www/upload/files</code> directory (in your target root filesystem) into it. The goal is to use the third partition of the SD card as the storage for the uploaded images. Finally, unmount the partition.</p> <pre><code>$ mnt_path=\"/mnt/www_upload_files\"\n$ sudo mkdir -p $mnt_path\n$ sudo mount -t ext4 \"${SDCARD_DEVP}3\" $mnt_path\n$ cd \"$LAB_PATH/nfsroot/www/upload/files/\"\n$ sudo cp -rv $(ls) $mnt_path\n'adult-small.png' -&gt; '/mnt/www_upload_files/adult-small.png'\n'brick.png' -&gt; '/mnt/www_upload_files/brick.png'\n'linux-blackfin.jpg' -&gt; '/mnt/www_upload_files/linux-blackfin.jpg'\n'linux-kernel-dev-book.jpg' -&gt; '/mnt/www_upload_files/linux-kernel-dev-book.jpg'\n'lkn-small.jpg' -&gt; '/mnt/www_upload_files/lkn-small.jpg'\n$ sudo umount $mnt_path\n$ sudo rmdir $mnt_path\n</code></pre> <p>Now, restart the board with the updated SD card, and from the Linux command line mount this third partition on <code>/www/upload/files</code>.</p> picocomBBB - BusyBox<pre><code># ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\nlinux-blackfin.jpg\n# rm -rf /www/upload/files/*\n# mount -t ext4 /dev/mmcblk0p3 /www/upload/files/\nEXT4-fs (mmcblk0p3): mounted filesystem with ordered data mode. Opts: (null). Quota mode: disabled.\n# ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\nlinux-blackfin.jpg         lost+found\n</code></pre> <p>Once this works, modify the startup scripts in your root filesystem to do it automatically at boot time.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t ext4 /dev/mmcblk0p3 /www/upload/files/\n/usr/sbin/httpd -h /www/\nmodprobe snd-usb-audio\nEOF\n</code></pre> <p>Reboot your target system again. With the <code>mount</code> command, check that <code>/www/upload/files</code> is now a mount point for the third SD card partition.</p> <p>Also make sure that you can still upload new images, and that these images are listed in the web interface. For example, upload the file <code>$LAB_PATH/nfsroot/www/gohome.png</code>.</p> picocomBBB - BusyBox<pre><code># reboot\n    ...\n# mount\n192.168.0.15:/srv/nfs on / type nfs (rw,relatime,vers=3,rsize=4096,wsize=4096,namlen=255,hard,nolock,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=192.168.0.15,mountvers=3,mountproto=tcp,local_lock=all,addr=192.168.0.15)\ndevtmpfs on /dev type devtmpfs (rw,relatime,size=242424k,nr_inodes=60606,mode=755)\nproc on /proc type proc (rw,relatime)\nsys on /sys type sysfs (rw,relatime)\n/dev/mmcblk0p3 on /www/upload/files type ext4 (rw,relatime)\n# echo \"Upload gohome.png from the web interface, please!\"\n    ...\n# ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\ngohome.png                 lost+found\nlinux-blackfin.jpg         upload.log\n</code></pre> <p>The pictures below are from the QEMU variant of this course.</p> <p></p> <p></p>"},{"location":"bbb/blockfs/#adding-a-tmpfs-partition-for-log-files","title":"Adding a <code>tmpfs</code> partition for log files","text":"<p>Currently, the upload script was storing its log file in <code>/www/upload/files/upload.log</code>. To avoid seeing this log file in the directory containing uploaded files, let's store it into <code>/var/log</code> instead.</p> <p>Add the <code>/var/log/</code> directory to your root filesystem, and modify the startup script to mount a <code>tmpfs</code> filesystem to this directory. You can test your <code>tmpfs</code> mount command line on the system before adding it to the startup script, in order to be sure that it works properly. Note that for types of <code>tmpfs</code> and <code>sysfs</code> the device name is just ignored, so we can just name them after the type.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ mkdir -p var/log/\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t tmpfs tmpfs /var/log/\nmount -t ext4 /dev/mmcblk0p3 /www/upload/files/\n/usr/sbin/httpd -h /www/\nmodprobe snd-usb-audio\nEOF\n</code></pre> <p>Modify the <code>www/cgi-bin/upload.cfg</code> configuration file to store the log file in <code>/var/log/upload.log</code>. You will lose your log file each time you reboot your system, but that's OK in our system. That's what <code>tmpfs</code> is for: temporary data that you don't need to keep across system reboots.</p> <pre><code>$ nano www/cgi-bin/upload.cfg\n$ cat www/cgi-bin/upload.cfg\nConfig          = Default\n  Root          = /www/upload/files\n  FileMask      = *\n  IgnoreSubdirs = YES\n  Overwrite     = YES\n  LogFile       = /var/log/upload.log\n  OkPage        = /www/upload/OkPage.html\n  BadPage       = /www/upload/BadPage.html\n  Debug         = 0\n</code></pre> <p>Reboot your system and check that it works as expected, by uploading <code>gohome.png</code> again.</p> picocomBBB - BusyBox<pre><code># reboot\n    ...\n# mount\n192.168.0.15:/srv/nfs on / type nfs (rw,relatime,vers=3,rsize=4096,wsize=4096,namlen=255,hard,nolock,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=192.168.0.15,mountvers=3,mountproto=tcp,local_lock=all,addr=192.168.0.15)\ndevtmpfs on /dev type devtmpfs (rw,relatime,size=242424k,nr_inodes=60606,mode=755)\nproc on /proc type proc (rw,relatime)\nsysfs on /sys type sysfs (rw,relatime)\ntmpfs on /var/log type tmpfs (rw,relatime)\n/dev/mmcblk0p3 on /www/upload/files type ext4 (rw,relatime)\n# rm -v /www/upload/files/gohome.png\nremoved '/www/upload/files/gohome.png'\n# echo \"Upload gohome.png from the web interface, please!\"\n    ...\n# ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\ngohome.png                 lost+found\nlinux-blackfin.jpg         upload.log\n# cat /var/log/upload.log\nThu Jan  1 00:00:45 1970 File uploaded succesfully: gohome.png (888 bytes)\n# reboot\n    ...\n# cat /var/log/upload.log\ncat: can't open '/var/log/upload.log': No such file or directory\n</code></pre> <p>You can now <code>halt</code> and disconnect.</p>"},{"location":"bbb/blockfs/#making-a-squashfs-image","title":"Making a SquashFS image","text":"<p>We are going to store the root filesystem in a SquashFS filesystem in the second partition of the SD card. In order to create SquashFS images on your host, you need to install the <code>squashfs-tools</code> package.</p> <pre><code>$ sudo apt install squashfs-tools\n</code></pre> <p>Then, create a SquashFS image of your NFS root directory with <code>mksquashfs</code>.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ mksquashfs * ../nfsroot.sqsh\n</code></pre> <p>Plug the SD card again. Using the <code>dd</code> command, copy the filesystem image to the second partition (named <code>image</code>) in the SD card image. Finally, unmount and cleanup.</p> <pre><code>$ sudo partprobe\n$ sudo umount ${SDCARD_DEVP}*\n$ sudo mkfs.ext4 -L image \"${SDCARD_DEVP}2\"\n    ...\n$ sudo dd if=\"$LAB_PATH/nfsroot.sqsh\" of=\"${SDCARD_DEVP}2\"\n50168+0 records in\n50168+0 records out\n25686016 bytes (26 MB, 24 MiB) copied, 71.6355 s, 359 kB/s\n</code></pre>"},{"location":"bbb/blockfs/#booting-on-the-squashfs-partition","title":"Booting on the SquashFS partition","text":"<p>In the U-boot shell, configure the kernel command line to use the second partition of the SD card as the root file system. Also add the <code>rootwait</code> boot argument, to wait for the SD card to be properly initialized before trying to mount the root filesystem. Since the SD cards are detected asynchronously by the kernel, the kernel might try to mount the root filesystem too early without <code>rootwait</code>. Check that your system still works. Congratulations if it does!</p> picocomBBB - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootargs_mmcblk0p2 \"console=ttyS0,115200n8  root=/dev/mmcblk0p2 rootwait  ip=${ipaddr}::${serverip}:${netmask}::${netif}\"\n=&gt; setenv bootargs $bootargs_mmcblk0p2\n=&gt; saveenv\n=&gt; reset\n    ...\nVFS: Mounted root (squashfs filesystem) readonly on device 179:2.\n    ...\nPlease press Enter to activate this console.\n</code></pre> <p>Now <code>halt</code> and disconnect.</p>"},{"location":"bbb/blockfs/#store-the-kernel-image-and-dtb-on-the-sd-card","title":"Store the kernel image and DTB on the SD card","text":"<p>We have to edit the SD card again, to mount the FAT partition (the first one) in the SD card image, for example on <code>/mnt/sd_boot</code>. It should contain only the latest saved U-Boot environment. Then, copy the kernel image and DTB to it. FInally, unmount the FAT partition and release the loop device.</p> <pre><code>$ sudo partprobe\n$ sudo umount ${SDCARD_DEVP}*\n$ mnt_path=\"/mnt/sd_boot\"\n$ sudo mkdir -p $mnt_path\n$ sudo mount -t vfat \"${SDCARD_DEVP}1\" $mnt_path\n$ ls /mnt/sd_boot/\nMLO uboot.env uboot.img\n$ sudo cp /srv/tftp/zImage /srv/tftp/am335x-boneblack-custom.dtb $mnt_path\n$ ls /mnt/sd_boot/\nam335x-boneblack-custom.dtb  MLO  uboot.env  u-boot.img  zImage\n$ sudo umount $mnt_path\n$ sudo rmdir $mnt_path\n</code></pre> <p>You now need to adjust the <code>bootcmd</code> of U-Boot so that it loads kernel and from the SD card, instead of loading them from the network via TFTP. In U-boot, you can load a file from a FAT filesystem using the <code>fatload</code> command, which expects: the device, the partition, the load address, and the source filename. Compare the previous and the new <code>bootcmd</code>. Finally, <code>reset</code> to reboot the board and make sure that your system still boots fine.</p> picocomBBB - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; printenv bootcmd\nbootcmd=tftp 0x81000000 zImage;  tftp 0x82000000 am335x-boneblack-custom.dtb;  bootz 0x81000000 - 0x82000000\n=&gt; setenv bootcmd_mmcblk0p1 \"fatload mmc 0:1 0x81000000 zImage;  fatload mmc 0:1 0x82000000 am335x-boneblack-custom.dtb;  bootz 0x81000000 - 0x82000000\"\n=&gt; setenv bootcmd $bootcmd_mmcblk0p1\n=&gt; saveenv\n=&gt; reset\n    ...\n4869856 bytes read in 320 ms (14.5 MiB/s)\n67275 bytes read in 7 ms (9.2 MiB/s)\nKernel image @ 0x81000000 [ 0x000000 - 0x4a4ee0 ]\n## Flattened Device Tree blob at 82000000\n   Booting using the fdt blob at 0x82000000\n   Loading Device Tree to 8ffec000, end 8ffff6ca ... OK\n\nStarting kernel ...\n    ...\nPlease press Enter to activate this console.\n</code></pre> <p>You can now <code>halt</code> and disconnect.</p> <p>Now, the whole system (bootloader, kernel and filesystems) is stored on the SD card. That's very useful for product demos, for examples. You can switch demos by switching SD cards, and the system depends on nothing else. In particular, no networking is necessary.</p>"},{"location":"bbb/blockfs/#backup","title":"Backup","text":"<pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-fatload.cpio.xz\"\n$ cd $LAB_PATH\n$ tar cfJv \"$LAB_PATH/nfsroot.sqsh.tar.xz\" nfsroot.sqsh\n$ cd /srv/tftp/\n$ tar cfJv \"$LAB_PATH/blockfs-tftp.tar.xz\" zImage am335x-boneblack-custom.dtb\n</code></pre>"},{"location":"bbb/blockfs/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/bootloader/","title":"Bootloader - U-Boot","text":""},{"location":"bbb/bootloader/#objectives","title":"Objectives","text":"<p>After this lab you will be able to:</p> <ul> <li> <p>Set up serial communication with the target board.</p> </li> <li> <p>Compile and install the U-Boot bootloader.</p> </li> <li> <p>Use basic U-Boot commands.</p> </li> <li> <p>Set up TFTP communication with the host machine.</p> </li> </ul>"},{"location":"bbb/bootloader/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>device-tree-compiler</code> <code>libssl-dev</code> <code>parted</code> <code>picocom</code> <code>python3-dev</code> <code>python3-distutils</code> <code>qemu-system-arm</code> <code>swig</code> <code>tftpd-hpa</code></p> <p>plus those from the previous labs.</p> </li> <li> <p>Das U-Boot, either as:</p> <ul> <li> <p>git repository</p> </li> <li> <p>Source code archive for release <code>v2022.07</code></p> </li> </ul> </li> <li> <p>BeagleBone Black board</p> <ul> <li> <p>Powered via generic USB (5\u00a0V).</p> </li> <li> <p>Dedicated Ethernet connection.</p> </li> </ul> </li> <li> <p>A generic USB-to-UART cable, TTL levels, 3.3\u00a0V (do not exceed!), only TX/RX pins required.</p> <ul> <li>Cable used by the original Bootlin tutorial.</li> </ul> </li> </ul>"},{"location":"bbb/bootloader/#bootloader-startup","title":"Bootloader startup","text":"<p>As the bootloader is the first piece of software executed by a hardware platform, the installation procedure of the bootloader is very specific to the hardware platform. There are usually two cases:</p> <ul> <li> <p>The processor offers nothing to ease the installation of the bootloader, in which case the JTAG has to be used to initialize flash storage and write the bootloader code to flash. Detailed knowledge of the hardware is of course required to perform these operations.</p> </li> <li> <p>The processor offers a monitor, implemented in ROM, and through which access to the memories is made easier.</p> </li> </ul> <p>The AM3358 SoC on the BeagleBone falls into the second category. The monitor integrated in the ROM reads the SD card to search for a valid bootloader.</p>"},{"location":"bbb/bootloader/#serial-communication","title":"Serial communication","text":"<p>The BeagleBone serial connector is exported on J1 (the 6 pins close to one of the 48 pins headers). Using your USB-to-UART adapter, connect the ground wire (blue) to the pin closest to the power supply connector (pin #1), and the adapter TX (red) and adapter RX (green) wires to the pins 4 (board RX) and 5 (board TX), respectively.</p> Board pin Board signal Cable signal Cable color J1 1 GND GND Blue  J1 4 RX TX Red   J1 5 TX RX Green <p></p> <p></p> <p>After insertion into the USB host, you have to re-assign it to the VirtualBox VM, via its menus.</p> <p>Then, the Lubuntu VM should register it into the host <code>/dev/</code> folder, as <code>/dev/ttyUSB0</code> (or similar names for different adapter chips, like <code>/dev/ttyACM0</code>, <code>/dev/ttyAMA0</code>, etc.).</p> <p>To communicate with the board through the serial port, install a serial communication program, such as <code>picocom</code>.</p> <p>If you run <code>ls -l /dev/ttyUSB0</code>, you can also see that only <code>root</code> and users belonging to the <code>dialout</code> group have read and write access to the serial console. Therefore, you need to add your user to the <code>dialout</code> group. Important: for the group change to be effective, you have to reboot your computer (at least on Ubuntu 22.04) and log in again. A workaround is to run <code>newgrp dialout</code>, but it works only within that shell session \u2014 you have to repeat this command for each shell you open, until the next login session.</p> <pre><code>$ sudo apt install picocom\n$ ls -l /dev/ttyUSB0\ncrw-rw---- 1 root dialout 188, 0 Apr 14 23:33 /dev/ttyUSB0\n$ sudo adduser $USER dialout\n$ newgrp dialout\n</code></pre> <p>Run <code>picocom -b 115200 /dev/ttyUSB0</code> to start serial communication on <code>/dev/ttyUSB0</code>, with a baud rate of 115200 baud (the typical speed). If you wish to exit <code>picocom</code>, press Ctrl+A followed by Ctrl+X.</p> <pre><code>$ picocom -b 115200 /dev/ttyUSB0\npicocom v3.1\nport is        : /dev/ttyUSB0\nflowcontrol    : none\nbaudrate is    : 115200\nparity is      : none\ndatabits are   : 8\nstopbits are   : 1\nescape is      : C-a\nlocal echo is  : no\nnoinit is      : no\nnoreset is     : no\nhangup is      : no\nnolock is      : no\nsend_cmd is    : sz -vv\nreceive_cmd is : rz -vv -E\nimap is        :\nomap is        :\nemap is        : crcrlf,delbs,\nlogfile is     : none\ninitstring     : none\nexit_after is  : not set\nexit is        : no\nType [C-a] [C-h] to see available commands\nTerminal ready\nTerminating...\nThanks for using picocom\n</code></pre> <p>There should be nothing on the serial line so far, as the board is not powered up yet.</p> <p>To speed up typing for reconnection, I suggest a tiny script:</p> <pre><code>$ sudo cat &gt; /usr/bin/picocomBBB &lt;&lt;'EOF'\n#!/bin/sh\npicocom -b 115200 /dev/ttyUSB0\nEOF\n$ chmod +x /usr/bin/picocomBBB\n</code></pre> <p>This way we can type and run <code>picocomBBB</code> instead of the longer command line.</p> <p>It is now time to power up your board by plugging in the mini-USB (BeagleBone Black case) or micro-USB (BeagleBone Black Wireless case) cable to your PC.</p> <p>See what messages you get on the serial line. You should see U-Boot start on the serial line, if there was a valid U-Boot and SPL on the board\u2019s eMMC.</p> <pre><code>$ picocomBBB\n    ...\nU-Boot SPL 2019.04-00002-g07d5700e21 (Mar 06 2020 - 11:24:55 -0600)\nTrying to boot from MMC2\nLoading Environment from EXT4... Card did not respond to voltage select!\nU-Boot 2019.04-00002-g07d5700e21 (Mar 06 2020 - 11:24:55 -0600), Build: jenkins-github_Bootloader-Builder-137\nCPU  : AM335X-GP rev 2.1\nI2C:   ready\nDRAM:  512 MiB\nNo match for driver 'omap_hsmmc'\nNo match for driver 'omap_hsmmc'\nSome drivers were not found\nReset Source: Power-on reset has occurred.\nRTC 32KCLK Source: External.\nMMC:   OMAP SD/MMC: 0, OMAP SD/MMC: 1\nLoading Environment from EXT4... Card did not respond to voltage select!\nBoard: BeagleBone Black\n&lt;ethaddr&gt; not set. Validating first E-fuse MAC\nBeagleBone Black:\n    ...\n</code></pre>"},{"location":"bbb/bootloader/#source-code","title":"Source code","text":"<p>Enter the folder of this lab, that's going to become our main workspace folder:</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/bootloader\"\n$ cd $LAB_PATH\n</code></pre> <p>You can now get U-Boot at the suggested version (git tag <code>v2022.07</code>).</p> <p>Yes, I used an older version w.r.t QEMU (<code>v2023.01</code>) because I had some troubles with USB initialization, which requires some investigation (anything deactivated within the recent defconfig?)</p> <p>We're going to clone the git repository into the home folder, creating a new branch named after the embedded-linux-bbb tutorial just for convenience.</p> <pre><code>$ cd $LAB_PATH\n$ git clone \"https://source.denx.de/u-boot/u-boot\"\n$ cd u-boot/\n$ label=\"v2022.07\"\n$ git checkout -b embedded-linux-bbb $label\n</code></pre> <p>Alternatively, you can directly unpack an archive of the suggested version. This is usually much faster than cloning a big git repository, despite losing all the features of a git repository.</p> <pre><code>$ cd $LAB_PATH\n$ label=\"v2022.07\"\n$ wget \"https://source.denx.de/u-boot/u-boot/-/archive/${label}/u-boot-${label}.tar.bz2\"\n$ tar xfv \"u-boot-${label}.tar.bz2\"\n$ mv u-boot*/ u-boot\n</code></pre>"},{"location":"bbb/bootloader/#configuration","title":"Configuration","text":"<p>Get an understanding of U-Boot\u2019s configuration and compilation steps by reading its <code>README</code> file, and specifically the Building the Software section.</p> <p>U-Boot comes with some sample configuration files for officially supported boards, under the <code>configs</code> folder, named with a <code>_defconfig</code> suffix.</p> <p>Our BeagleBone Black board is based on an ARM Cortex A8, the Texas Instruments AM335X Sitara. Among the officially supported configurations, the one that supports our boars isn't obvious: it's <code>am335x_evm_defconfig</code> (generic AM335 EValuation Module), not <code>am335x_boneblack_vboot_defconfig</code> (only for verified boot on our BBB). Let's make it effective.</p> <pre><code>$ cd $LAB_PATH/u-boot/\n$ ls configs/ | grep am335\nam335x_baltos_defconfig\nam335x_boneblack_vboot_defconfig\nam335x_evm_defconfig\nam335x_evm_spiboot_defconfig\nam335x_guardian_defconfig\nam335x_hs_evm_defconfig\nam335x_hs_evm_uart_defconfig\nam335x_igep003x_defconfig\nam335x_pdu001_defconfig\nam335x_shc_defconfig\nam335x_shc_ict_defconfig\nam335x_shc_netboot_defconfig\nam335x_shc_sdboot_defconfig\nam335x_sl50_defconfig\nphycore-am335x-r2-regor_defconfig\nphycore-am335x-r2-wega_defconfig\n$ make am335x_evm_defconfig\n</code></pre>"},{"location":"bbb/bootloader/#build","title":"Build","text":"<p>To build U-Boot, we need to specify the cross-compile toolchain we built by setting a global variable <code>CROSS_COMPILE</code>. The <code>export</code> keyword makes it available also to sub-processes, including <code>make</code> and the tools called by it. We can choose between the full name <code>arm-training-linux-uclibcgnueabihf-</code> or the shortened alias <code>arm-linux-</code> as the prefix. Also, remmeber to parallelize to save time.</p> <pre><code>$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export MAKEFLAGS=-j$(nproc)\n</code></pre> <p>We're going to use the <code>menuconfig</code> to refine the configuration to suit our needs. The default configuration is fine for our needs, so you don't need any fine tuning, but you can take a look around.</p> <pre><code>$ cd $LAB_PATH/u-boot/\n$ make menuconfig\n</code></pre> <p>See: <code>menuconfig</code></p> <p>You can now <code>&lt;Save&gt;</code> (if needed) and make a backup copy of this configuration:</p> <pre><code>$ cp .config ../u-boot.config\n</code></pre> <p>Install some packages required for compilation:</p> <pre><code>$ sudo apt install  \\\ndevice-tree-compiler libssl-dev parted  \\\npython3-dev python3-distutils swig\n</code></pre> <p>You can now build the bootloader. You have to pass the <code>DEVICE_TREE</code> environment variable to <code>make</code>, to select which Device Tree has to be compiled: <code>am335x-boneblack</code> for the standard BBB (covered by this course). Alternatively, if you wish to run just <code>make</code>, specify our board\u2019s device tree name on <code>Device Tree Control</code> \u2192 <code>Default Device Tree for DT Control</code> option (<code>DEFAULT_DEVICE_TREE</code>, which defaults to <code>am335x-evm</code>).</p> <pre><code>$ make DEVICE_TREE=am335x-boneblack\n</code></pre> <p>This generates several binaries, including <code>MLO</code> and <code>u-boot.img</code>. You can save them into a backup archive if you wish so:</p> <pre><code>$ tar cfJv ../u-boot.tar.xz MLO u-boot.img\n</code></pre>"},{"location":"bbb/bootloader/#bootable-sd-card","title":"Bootable SD card","text":"<p>The TI AM335 romcode will look for an <code>MLO</code> file (MMC Load) in a FAT partition on an SD card. This is precisely what U-Boot compiled for us, together with the U-Boot binary image <code>u-boot.img</code>. Let\u2019s prepare an SD card with such a partition.</p> <p>Plug the micro-SD card into your workstation. Ignore any actions by the file manager, so that no partitions are mounted automatically.</p> <p>If using Windows as the host OS, the SD card might become corrupted upon insertion, because Windows wants to do its own business with it, messing up with partition data. This involves more operations w.r.t. a native Linux host OS as explained within the Bootlin tutorials, so let me add my procedures in quoted blocks like this one.</p> <p>Instead of using the native SD card reader built into my laptop, I'm connecting via a generic USB SD card reader. I insert the USB reader itself, without SD card, and pass control of this USB peripheral to VirtualBox.</p> <p>Type the <code>sudo dmesg</code> command to see which device is used by your workstation. In case the device is <code>/dev/mmcblk0</code>, you will see something like in the following example. Let's assign this name to a variable to be used afterwards.</p> <pre><code>$ sudo dmsg\n    ...\n[46939.425299] mmc0: new high speed SDHC card at address 0007\n[46939.427947] mmcblk0: mmc0:0007 SD16G 14.5 GiB\n    ...\n$ SDCARD_DEV=\"/dev/mmcblk0\"\n$ SDCARD_DEVP=\"${SDCARD_DEV}p\"\n</code></pre> <p>With an USB SD card reader, the device is usually a SCSI-like device (<code>/dev/sdX</code>). In my Lubuntu VM, it's named <code>/dev/sdd</code>. You can confirm your device was added to the device list, for exmaple via <code>lsusb</code> and <code>dmesg</code>. Lubuntu VM<pre><code>$ lsusb\nBus 001 Device 004: ID 14cd:1212 Super Top microSD card reader (SY-T18)\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 002: ID 80ee:0021 VirtualBox USB Tablet\nBus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\n$ sudo dmesg\n    ...\nusb 1-1: new high-speed USB device number 4 using ehci-pci\nusb 1-1: New USB device found, idVendor=14cd, idProduct=1212, bcdDevice= 1.00\nusb 1-1: New USB device strings: Mfr=1, Product=3, SerialNumber=2\nusb 1-1: Product: Mass Storage Device\nusb 1-1: Manufacturer: Generic\nusb 1-1: SerialNumber: 121220160204\nusb-storage 1-1:1.0: USB Mass Storage device detected\nscsi host5: usb-storage 1-1:1.0\nscsi 5:0:0:0: Direct-Access     Mass     Storage Device   1.00 PQ: 0 ANSI: 0 CCS\nsd 5:0:0:0: Attached scsi generic sg4 type 0\nsd 5:0:0:0: [sdd] Media removed, stopped polling\nsd 5:0:0:0: [sdd] Attached SCSI removable disk\n    ...\n$ SDCARD_DEV=\"/dev/sdd\"\n$ SDCARD_DEVP=\"${SDCARD_DEV}\"\n</code></pre></p> <p>Only now you can insert the micro-SD card into the USB reader.</p> <p>Type the <code>mount</code> command to check your currently mounted partitions. If any of its SD partitions are mounted, unmount them.</p> <pre><code>$ sudo umount ${SDCARD_DEVP}*\n</code></pre> <p>We'll erase the existing partition table by simply zero-ing the first 16 MiB of the SD card:</p> <pre><code>$ sudo dd if=/dev/zero of=$SDCARD_DEV bs=1M count=16\n</code></pre> <p>Now, let\u2019s call the <code>cfdisk</code> command to create the partitions that we are going to use.</p> <pre><code>$ sudo cfdisk $SDCARD_DEV\n</code></pre> <p>If <code>cfdisk</code> asks you to <code>Select a label type</code>, choose <code>dos</code>, as we don\u2019t really need a <code>gpt</code> partition table for our labs.</p> <p>In the <code>cfdisk</code> interface, create three primary partitions, starting from the beginning, with the following properties:</p> <ul> <li> <p>One partition, 64 MB big, with the <code>W95 FAT32 (LBA)</code> partition type (<code>c</code> choice).   Mark this partition as bootable.</p> </li> <li> <p>One partition, 32 MB big, that will be used for the root filesystem.   Due to the geometry of the device, the partition might be larger, but it does not matter.   Keep the <code>Linux</code> partition type.</p> </li> <li> <p>One partition filling the remaining space of the SD card image, to be used for the data filesystem.   Keep the <code>Linux</code> partition type.</p> </li> </ul> <p>Select <code>Write</code> when you are done.</p> <p>You could've done something similar with a single <code>parted</code> issue:</p> <pre><code>$ sudo parted -s $SDCARD_DEV --  \\\nmklabel msdos  \\\nmkpart primary fat32 1m 64m  \\\nmkpart primary ext4 64m 96m  \\\nmkpart primary ext4 96m -1s  \\\nset 1 boot on  \\\nprint\nModel: Mass Storage Device (scsi)\nDisk /dev/sdd: 31.6GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\nDisk Flags:\nNumber  Start   End     Size    Type     File system  Flags\n 1      1049kB  64.0MB  62.9MB  primary  fat32        boot, lba\n 2      64.0MB  96.5MB  32.5MB  primary  ext4         lba\n 3      96.5MB  31.6GB  31.5GB  primary  ext4         lba\n</code></pre> <p>We will create further partitions in a later lab, when we need them. To make sure that partition definitions are reloaded by your workstation, remove the micro-SD card and insert it again, or run <code>partprobe</code>.</p> <p>Now create a FAT32 filesystem on this new first partition:</p> <pre><code>$ sudo partprobe\n$ sudo mkfs.vfat -a -F 32 -n boot \"${SDCARD_DEVP}1\"\nmkfs.fat 4.2 (2021-01-31)\nmkfs.fat: Warning: lowercase labels might not work properly on some systems\n</code></pre> <p>Ubuntu uses version <code>4.2</code> of <code>mkfs.vfat</code>, and the FAT generated by this version of the command is incompatible with what the TI AM335x romcode expects. Passing the <code>-a</code> option is workaround described on a Bootlin blog post.</p> <p>You can now make your workstation automatically mount this partition by removing the micro-SD card and plugging it back. It should now be mounted on <code>/media/$USER/boot/</code>.</p> <p>Now, copy the <code>MLO</code> and <code>u-boot.img</code> files to the SD card:</p> <pre><code>$ cd \"$LAB_PATH/u-boot/\"\n$ sdcard_mnt=\"/mnt/sdcard_boot/\"\n$ sudo mkdir -p $sdcard_mnt\n$ sudo mount -t vfat \"${SDCARD_DEVP}1\" $sdcard_mnt\n$ sudo cp MLO u-boot.img $sdcard_mnt\n$ sudo umount $sdcard_mnt\n$ sudo rmdir $sdcard_mnt\n</code></pre> <p>You can now remove the micro-SD card from the host workstation.</p> <p>You should always remove the micro-SD card from the USB reader before un-plugging the USB reader (or before releasing it from the Lubuntu VM). If Windows takes control of the USB reader with the micro-SD card still inserted, Windows might corrupt the boot partition, making it unusable by the TI AM335 romcode.</p>"},{"location":"bbb/bootloader/#quick-test","title":"Quick test","text":"<p>Remove power from BBB, connect the UART cable, insert the micro-SD card, and run <code>picocomBBB</code> in advance. Be ready to press a key (e.g. Space) as soon as the board boots, just after the next instructions.</p> <pre><code>$ picocomBBB\n    ...\nTerminal ready\n</code></pre> <p>To boot the board on the external micro-SD card, you need to press and hold the USER button (<code>S2</code>, close to the USB host port), and then power-up the board. You can then release the USER button.</p> <p>This seems like a very inconvenient way of booting the board, but the selection of attempting to boot from the external micro-SD card remains active across resets, until the board is ultimately powered off. So, you will just need to use the button a few times during the course.</p> <p>If this is too inconvenient for you, you could use U-Boot on the external micro-SD card to flash a new version of U-Boot on the internal eMMC. This would allow you to boot without an external micro-SD card.</p> <p>Here\u2019s what you should get on the serial line:</p> picocomBBB - U-Boot<pre><code>U-Boot SPL 2022.07 (Apr 16 2023 - 15:43:05 +0200)\nTrying to boot from MMC1\n\nU-Boot 2022.07 (Apr 16 2023 - 15:43:05 +0200)\n\nCPU  : AM335X-GP rev 2.1\nModel: TI AM335x BeagleBone Black\nDRAM:  512 MiB\nCore:  160 devices, 18 uclasses, devicetree: separate\nWDT:   Started wdt@44e35000 with servicing (60s timeout)\nNAND:  0 MiB\nMMC:   OMAP SD/MMC: 0, OMAP SD/MMC: 1\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\n&lt;ethaddr&gt; not set. Validating first E-fuse MAC\nNet:   eth2: ethernet@4a100000, eth3: usb_ether\nHit any key to stop autoboot:  0\n=&gt;\n</code></pre> <p>Make sure that the version and compile date are right. Otherwise, try again, because this means that you booted on the internal eMMC.</p> <p>In U-Boot, type the <code>help</code> command, and explore the few commands available.</p> picocomBBB - U-Boot<pre><code>=&gt; help\n?         - alias for 'help'\n  ...\nversion   - print monitor, compiler and linker version\n</code></pre>"},{"location":"bbb/bootloader/#adding-commands-to-u-boot","title":"Adding commands to U-Boot","text":"<p>Check whether the <code>config</code> command is available. This command allows to dump the configuration settings U-Boot was compiled from. If it\u2019s not, go back to U-Boot configuration and enable it.</p> <pre><code>$ cd \"$LAB_PATH/u-boot/\"\n$ make menuconfig\n</code></pre> <p>Let's search <code>config</code> (press / and enter <code>config</code>). You should obtain a list like:</p> <pre><code>Symbol: CMD_CONFIG [=n]\nType  : bool\nPrompt: config\n  Location:\n    -&gt; Command line interface\n(1)   -&gt; Info commands\n  Defined at cmd/Kconfig:138\n  Selects: BUILD_BIN2C [=n]\n\nSymbol: CMD_EECONFIG [=n]\nType  : bool\nPrompt: Enable the 'econfig' command\n  Location:\n(2) -&gt; ARM architecture\n  Defined at board/gateworks/gw_ventana/Kconfig:15\n  Depends on: ARM [=y] &amp;&amp; ARCH_MX6 [=n] &amp;&amp; TARGET_GW_VENTANA [=n]\n\n    ...\n</code></pre> <p>Option marked <code>(1)</code> (<code>CMD_CONFIG</code>) looks like what we need. Press 1 then Y to enable it. After you <code>&lt;Exit&gt;</code> once, you should confirm that your setting was applied.</p> <p>You can also select the default board, as mentioned in the previous paragraphs, so that we don't need to pass the <code>DEVICE_TREE</code> option to <code>make</code> anymore. Let's search <code>DEFAULT_DEVICE_TREE</code> and set it according to your board (e.g. <code>am335x-boneblack</code>).</p> <p>You can then <code>&lt;Save&gt;</code> into <code>.config</code> and exit the program. Save a backup and build again.</p> <pre><code>$ cp .config ../u-boot-config.config\n$ make\n$ tar cfJv ../u-boot-config.tar.xz MLO u-boot.img\n</code></pre> <p>You should update the bootloader on the SD card, so you can test that the command is now available and working as expected.</p> <p>If you are on a Windows host OS, always remember to insert and remove the SD card from the USB SD card reader while the USB reader is under control of the Lubuntu VM. If Windows takes control of the USB reader with the micro-SD card still inserted, Windows might corrupt the boot partition, making it unusable by the TI AM335 romcode.</p> <pre><code>$ sudo umount ${SDCARD_DEVP}*\n$ cd \"$LAB_PATH/u-boot/\"\n$ sdcard_mnt=\"/mnt/sdcard_boot/\"\n$ sudo mkdir -p $sdcard_mnt\n$ sudo mount -t vfat \"${SDCARD_DEVP}1\" $sdcard_mnt\n$ sudo cp MLO u-boot.img $sdcard_mnt\n$ sudo umount $sdcard_mnt\n$ sudo rmdir $sdcard_mnt\n</code></pre> <p>Running the updated micro-SD card on the BBB:</p> picocomBBB - U-Boot<pre><code>U-Boot SPL 2022.07 (Apr 16 2023 - 15:54:05 +0200)\nTrying to boot from MMC1\n\nU-Boot 2022.07 (Apr 16 2023 - 15:54:05 +0200)\n\nCPU  : AM335X-GP rev 2.1\nModel: TI AM335x BeagleBone Black\nDRAM:  512 MiB\nCore:  160 devices, 18 uclasses, devicetree: separate\nWDT:   Started wdt@44e35000 with servicing (60s timeout)\nNAND:  0 MiB\nMMC:   OMAP SD/MMC: 0, OMAP SD/MMC: 1\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\n&lt;ethaddr&gt; not set. Validating first E-fuse MAC\nNet:   eth2: ethernet@4a100000, eth3: usb_ether\nHit any key to stop autoboot:  0\n=&gt; config\n#\n# Automatically generated file; DO NOT EDIT.\n# U-Boot 2022.07 Configuration\n#\n\n#\n# Compiler: arm-linux-gcc (crosstool-NG 1.25.0.95_7622b49) 11.3.0\n#\nCONFIG_CREATE_ARCH_SYMLINK=y\n    ...\n# CONFIG_TOOLS_MKEFICAPSULE is not set\n</code></pre> <p>As you can see, the <code>config</code> command prints verbatim the content of the <code>.config</code> file that was used to build U-Boot.</p>"},{"location":"bbb/bootloader/#test-environment","title":"Test environment","text":"<p>In the U-Boot prompt, make sure that you can set an environment variable:</p> picocomBBB - U-Boot<pre><code>=&gt; setenv foo bar\n=&gt; printenv foo\nfoo=bar\n</code></pre> <p>Run <code>reset</code> to reboot the board, and then check that the <code>foo</code> variable is still set:</p> picocomBBB - U-Boot<pre><code>=&gt; reset\n    ...\nHit any key to stop autoboot:  0\n=&gt; printenv foo\n## Error: \"foo\" not defined\n</code></pre> <p>Environment variables need to be saved across resets! This time, call <code>saveenv</code> before resetting:</p> picocomBBB - U-Boot<pre><code>=&gt; setenv foo bar\n=&gt; saveenv\nSaving Environment to FAT... OK\n=&gt; reset\n   ...\nHit any key to stop autoboot:  0\n=&gt; printenv foo\nfoo=bar\n</code></pre>"},{"location":"bbb/bootloader/#networking","title":"Networking","text":"<p>To load a kernel in the next lab, we have to setup networking between the host machine and the target machine.</p> <p>See Host VM - Networking for information about the IP addresses for this lab.</p> <p>On the U-Boot command line, you have to configure the environment variables for networking: <code>serverip</code> for the host (server) machine, and <code>ipaddr</code> for the target machine, using the dedicated Ethernet port (<code>eth2</code>) as the first (<code>ethprime</code>). To make these settings permanent, save the environment.</p> picocomBBB - U-Boot<pre><code>=&gt; setenv ethprime eth2\n=&gt; setenv serverip 192.168.0.15\n=&gt; setenv ipaddr 192.168.0.69\n=&gt; saveenv\n</code></pre> <p>You can now test the connection to the host:</p> picocomBBB - U-Boot<pre><code>=&gt; ping $serverip\nlink up on port 0, speed 100, full duplex\nUsing ethernet@4a100000 device\nhost 192.168.0.15 is alive\n</code></pre>"},{"location":"bbb/bootloader/#tftp-server","title":"TFTP server","text":"<p>Let\u2019s install a TFTP server on your host machine*, by the <code>tftpd-hda</code> package.</p> <pre><code>$ sudo apt install tftpd-hpa\n$ sudo systemctl restart tftpd-hpa\n</code></pre> <p>By default, files are stored under the <code>/srv/tftp/</code> folder, which should be accessible by the by <code>tftp</code> group. So, let's add our user to it.</p> <pre><code>$ sudo mkdir -p /srv/tftp\n$ sudo chown -R tftp:tftp /srv/tftp\n$ sudo chmod g+rw /srv/tftp/\n$ sudo adduser $USER tftp\n$ newgrp tftp\n</code></pre> <p>The <code>newgrp tftp</code> command makes this group available to the current shell without restarting the host login session. Until the next login session, you have to type this command again for any new shells of the current login session.</p> <p>To test the TFTP connection, put a small text file in the directory exported through TFTP on your host machine, then try to read it back as a TFTP client to check that the server is working properly.</p> <pre><code>$ echo \"Hello, World!\" &gt; /srv/tftp/textfile.txt\n$ cd $LAB_PATH\n$ tftp localhost -v -c get textfile.txt\nConnected to localhost (::1), port 69\ngetting from localhost:textfile.txt to textfile.txt [netascii]\nReceived 15 bytes in 0.0 seconds [6306 bit/s]\n$ cat textfile.txt\nHello, World!\n</code></pre> <p>Back in U-Boot run <code>bdinfo</code>, which allows finding out that the DRAM starts at <code>0x80000000</code>.</p> picocomBBB - U-Boot<pre><code>=&gt; bdinfo\nboot_params = 0x80000100\nDRAM bank   = 0x00000000\n-&gt; start    = 0x80000000\n-&gt; size     = 0x20000000\nflashstart  = 0x00000000\nflashsize   = 0x00000000\nflashoffset = 0x00000000\nbaudrate    = 115200 bps\nrelocaddr   = 0x9ff65000\nreloc off   = 0x1f765000\nBuild       = 32-bit\ncurrent eth = ethernet@4a100000\nethaddr     = 54:4a:16:be:9e:ae\nIP addr     = 192.168.0.69\nfdt_blob    = 0x9df2fc00\nnew_fdt     = 0x9df2fc00\nfdt_size    = 0x000152a0\nlmb_dump_all:\n memory.cnt  = 0x1\n memory[0]      [0x80000000-0x9fffffff], 0x20000000 bytes flags: 0\n reserved.cnt  = 0x1\n reserved[0]    [0x9df2b9b8-0x9fffffff], 0x020d4648 bytes flags: 0\ndevicetree  = separate\narch_number = 0x00000000\nTLB addr    = 0x9fff0000\nirq_sp      = 0x9df2fbf0\nsp start    = 0x9df2fbe0\nEarly malloc usage: 8f8 / 2000\n</code></pre> <p>Therefore, we will use the <code>0x81000000</code> address to test <code>tftp</code>, which is part of the board DRAM. If you want to check where this value comes from, you can check the AM335x and AMIC110 Sitara\u2122 Processors Technical Reference Manual; it\u2019s a big document (more than 5000 pages). In this document, look for ARM Cortex-A8 Memory Map and you will find the SoC memory map. You can see that the address range for the memory controller (EMIF0 SDRAM) starts at the address we are looking for. You can also try with other values in the RAM address range.</p> <p>From the U-Boot prompt, ask the TFTP server that file:</p> picocomBBB - U-Boot<pre><code>=&gt; setenv ram_app_start 0x81000000\n=&gt; tftp $ram_app_start textfile.txt\nlink up on port 0, speed 100, full duplex\nUsing ethernet@4a100000 device\nTFTP from server 192.168.0.15; our IP address is 192.168.0.69\nFilename 'textfile.txt'.\nLoad address: 0x81000000\nLoading: ##################################################  14 Bytes\n         1000 Bytes/s\ndone\nBytes transferred = 14 (e hex)\n</code></pre> <p>The <code>tftp</code> command should have downloaded <code>textfile.txt</code> from your development workstation into the board\u2019s memory at location <code>0x81000000</code>. You can verify that the download was successful by dumping the contents of the memory (<code>md</code>, memory dump):</p> picocomBBB - U-Boot<pre><code>=&gt; md $ram_app_start\n81000000: 6c6c6548 57202c6f 646c726f 00000a21  Hello, World!...\n81000010: 00000000 00000000 00000000 00000000  ................\n81000020: 00000000 00000000 00000000 00000000  ................\n81000030: 00000000 00000000 00000000 00000000  ................\n81000040: 00000000 00000000 00000000 00000000  ................\n81000050: 00000000 00000000 00000000 00000000  ................\n81000060: 00000000 00000000 00000000 00000000  ................\n81000070: 00000000 00000000 00000000 00000000  ................\n81000080: 00000000 00000000 00000000 00000000  ................\n81000090: 00000000 00000000 00000000 00000000  ................\n810000a0: 00000000 00000000 00000000 00000000  ................\n810000b0: 00000000 00000000 00000000 00000000  ................\n810000c0: 00000000 00000000 00000000 00000000  ................\n810000d0: 00000000 00000000 00000000 00000000  ................\n810000e0: 00000000 00000000 00000000 00000000  ................\n810000f0: 00000000 00000000 00000000 00000000  ................\n</code></pre> <p>You can now disconnect and turn off the board.</p>"},{"location":"bbb/bootloader/#backup-and-restore","title":"Backup and restore","text":"<p>If you have trouble generating binaries that work properly, or later make a mistake that causes you to lose your bootloader binary, you can find a working version under <code>$LAB_PATH/data/</code>, to be copied to <code>$LAB_PATH/u-boot/</code>:</p> <pre><code>$ cd $LAB_PATH\n$ mkdir -p u-boot/\n$ cp data/u-boot u-boot/u-boot\n</code></pre>"},{"location":"bbb/bootloader/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/buildroot/","title":"Buildroot","text":""},{"location":"bbb/buildroot/#objectives","title":"Objectives","text":"<ul> <li>discover how a build system is used and how it works, with the example of the Buildroot build system.</li> </ul> <p>Compared to the previous lab, we are going to build a more elaborate system, still containing <code>alsa-utils</code> (and of course its <code>alsa-lib</code> dependency), but this time using Buildroot, an automated build system.</p> <p>The automated build system will also allow us to add more packages and play real audio on our system, thanks to the Music Player Daemon (<code>mpd</code>) and its <code>mpc</code> client.</p>"},{"location":"bbb/buildroot/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>evince</code> <code>graphviz</code></p> <p>plus those from the previous labs.</p> </li> <li> <p>Buildroot, either as:</p> <ul> <li> <p>git repository tag <code>v2022.02</code></p> </li> <li> <p>Source code archive for release <code>v2022.02</code></p> </li> </ul> </li> </ul>"},{"location":"bbb/buildroot/#source-code","title":"Source code","text":"<p>The official Buildroot website is available at https://buildroot.org/. Let's clone the git repository, branching the <code>2022.02</code> release, which is a LTS (Long Term Support, we're just sticking to the original one), naming after this lab.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/buildroot\"\n$ cd $LAB_PATH\n$ label=\"2022.02\"\n$ git clone https://git.buildroot.net/buildroot/\n$ cd buildroot/\n$ git checkout -b embedded-linux-bbb $label\n</code></pre> <p>Several subdirectories or files are visible. The most important ones are:</p> <ul> <li> <p><code>boot</code> contains the Makefiles and configuration items related to the compilation of common bootloaders (GRUB, U-Boot, Barebox, etc.)</p> </li> <li> <p><code>board</code> contains board specific configurations and root filesystem overlays.</p> </li> <li> <p><code>configs</code> contains a set of predefined configurations, similar to the concept of defconfig in the kernel.</p> </li> <li> <p><code>docs</code> contains the documentation for Buildroot.</p> </li> <li> <p><code>fs</code> contains the code used to generate the various root filesystem image formats.</p> </li> <li> <p><code>linux</code> contains the Makefile and configuration items related to the compilation of the Linux kernel.</p> </li> <li> <p><code>Makefile</code> is the main Makefile that we will use to use Buildroot: everything works through Makefiles in Buildroot;</p> </li> <li> <p><code>package</code> is a directory that contains all the Makefiles, patches, and configuration items to compile the user space applications and libraries of your embedded Linux system.   Have a look at various subdirectories and see what they contain.</p> </li> <li> <p><code>system</code> contains the root filesystem skeleton and the device tables used for a static <code>/dev</code>.</p> </li> <li> <p><code>toolchain</code> contains the Makefiles, patches and configuration items to generate the cross-compiling toolchain.</p> </li> </ul>"},{"location":"bbb/buildroot/#configuration","title":"Configuration","text":"<p>As we will want Buildroot to build a kernel with a custom configuration, and our custom patch, let's add our own subdirectory under <code>board</code>. Then, copy our kernel configuration (latest) and kernel patch (latest).</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ mkdir -p board/bootlin/training/\n$ cp ../../tinysystem/kernel-blockfs.config  board/bootlin/training/linux.config\n$ cp ../../hardware/0001-Custom-DTS-for-Bootlin-lab.patch  board/bootlin/training/\n</code></pre> <p>In our case, we would like to:</p> <ul> <li> <p>Generate an embedded Linux system for ARM.</p> </li> <li> <p>Use an already existing external toolchain instead of having Buildroot generating one for us.</p> </li> <li> <p>Compile the Linux kernel and deploy its modules in the root filesystem.</p> </li> <li> <p>Integrate BusyBox, <code>alsa-utils</code>, <code>mpd</code>, <code>mpc</code> and <code>evtest</code> in our embedded Linux system.</p> </li> <li> <p>Integrate the target filesystem into a tarball.</p> </li> </ul> <p>To run the configuration utility of Buildroot, simply run:</p> <pre><code>$ make menuconfig\n</code></pre> <p>Set the following options. Don't hesitate to press the <code>Help</code> button whenever you need more details about a given option!</p> <p>In <code>Target options</code>:</p> <ul> <li> <p><code>Target Architecture</code> = <code>ARM (little endian)</code>.</p> </li> <li> <p><code>Target Architecture Variant</code> = <code>cortex-A8</code>.</p> </li> <li> <p><code>Target ABI</code> = <code>EABIhf</code>.</p> </li> <li> <p><code>Floating point strategy</code> = <code>VFPv3-D16</code>.</p> </li> </ul> <p>In <code>Toolchain</code>:</p> <ul> <li> <p><code>Toolchain type</code> = <code>External toolchain</code>.</p> </li> <li> <p><code>Toolchain</code> = <code>Custom toolchain</code>.</p> </li> <li> <p><code>Toolchain path</code> = <code>$(HOME)/x-tools/arm-training-linux-uclibcgnueabihf</code>, which is the one we built.</p> </li> <li> <p><code>External toolchain gcc version</code> = <code>11.x</code>.</p> </li> <li> <p><code>External toolchain kernel headers series</code> = <code>5.15.x</code>.</p> </li> <li> <p><code>External toolchain C library</code> = <code>uClibc/uClibc-ng</code>.</p> </li> <li> <p>Enable <code>Toolchain has WCHAR support?</code>.</p> </li> <li> <p>Enable <code>Toolchain has SSP support?</code>.</p> </li> <li> <p>Enable <code>Toolchain has C++ support?</code>.</p> </li> </ul> <p>In <code>Kernel</code>:</p> <ul> <li> <p>Enable <code>Linux Kernel</code>.</p> </li> <li> <p><code>Kernel version</code> = <code>Latest version (5.15)</code>.</p> </li> <li> <p><code>Custom kernel patches</code> = <code>board/bootlin/training/0001-Custom-DTS-for-Bootlin-lab.patch</code>,   our hand-made patch.</p> </li> <li> <p><code>Kernel configuration</code> = <code>Using a custom (def)config file</code>.</p> </li> <li> <p><code>Configuration file path</code> = <code>board/bootlin/training/linux.config</code>.</p> </li> <li> <p>Enable <code>Build a Device Tree Blob (DTB)</code>.</p> </li> <li> <p><code>In-tree Device Tree Source file names</code> = <code>am335x-boneblack-custom</code>.</p> </li> </ul> <p>In <code>Target packages</code>:</p> <ul> <li> <p>Keep <code>BusyBox (default version)</code> and keep the BusyBox configuration proposed by Buildroot.</p> </li> <li> <p>Under <code>Audio and video applications</code>:</p> <ul> <li> <p>Enable <code>alsa-utils</code>, and in the submenu:</p> <ul> <li>Only keep <code>speaker-test</code>.</li> </ul> </li> <li> <p>Enable <code>mpd</code>, and in the submenu:</p> <ul> <li>Keep only <code>alsa</code>, <code>vorbis</code> and <code>tcp sockets</code>.</li> </ul> </li> <li> <p>Enable <code>mpd-mpc</code>.</p> </li> </ul> </li> <li> <p>Under <code>Hardware handling</code>:</p> <ul> <li>Enable <code>evtest</code>.   This userspace application allows to test events from input devices.   This way we will be able to test the Nunchuk by getting details about which buttons were pressed.</li> </ul> </li> </ul> <p>In <code>Filesystem images</code>:</p> <ul> <li>Enable <code>tar the root filesystem</code>.</li> </ul> <p>Exit the <code>menuconfig</code> interface saving into the usual <code>.config</code> file. Also make a backup copy for reference.</p> <pre><code>$ cp .config ../buildroot.config\n</code></pre>"},{"location":"bbb/buildroot/#build","title":"Build","text":"<p>Just run the canonical <code>make</code>:</p> <pre><code>$ make\n</code></pre> <p>Buildroot will first create a small environment with the external toolchain, then download, extract, configure, compile, and install each component of the embedded system.</p> <p>All the compilation has taken place in the <code>output/</code> subdirectory. Let's explore its content:</p> <ul> <li> <p><code>build</code> is the directory in which each component built by Buildroot is extracted, and where the build actually takes place.</p> </li> <li> <p><code>host</code> is the directory where Buildroot installs some components for the host.   As Buildroot doesn't want to depend on too many things installed in the developer machines, it installs some tools needed to compile the packages for the target.   In our case it installed <code>pkg-config</code> (since the version of the host may be ancient) and tools to generate the root filesystem image (<code>genext2fs</code>, <code>makedevs</code>, <code>fakeroot</code>).</p> </li> <li> <p><code>images</code> which contains the final images produced by Buildroot. In our case it contains a tarball of the filesystem, called <code>rootfs.tar</code>, plus the compressed kernel and DTB (Device Tree Binary).   Depending on the configuration, there could also a bootloader binary or a full SD card image.</p> </li> <li> <p><code>staging</code>, which contains the \"build\" space of the target system, all the target libraries, with headers and documentation.   It also contains the system headers and the C library, which in our case have been copied from the cross-compiling toolchain.</p> </li> <li> <p><code>target</code> is the target root filesystem. All the applications and libraries, usually stripped, are installed in this directory.   However, it cannot be used directly as the root filesystem, as all the device files are missing: it is not possible to create them without being root, and Buildroot has a policy of not running anything as root.</p> </li> </ul>"},{"location":"bbb/buildroot/#run-the-generated-system","title":"Run the generated system","text":"<p>Go back to the <code>$HOME/embedded-linux-bbb-labs/buildroot/</code> directory. Create a new <code>nfsroot</code> directory that is going to hold our system, exported over NFS. Go into this directory, and untar the rootfs.</p> <pre><code>$ mkdir -p \"$LAB_PATH/nfsroot/\"\n$ cd \"$LAB_PATH/nfsroot/\"\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre> <p>Add this new <code>nfsroot</code> directory to the list of directories exported by NFS in <code>/etc/exports</code>. You could just replace the symlink we used for BusyBox, pointing instead to this new <code>nfsroot</code>.</p> <pre><code>$ sudo rm -f /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/nfsroot/\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-bbb-labs/buildroot/nfsroot/'\n$ sudo chown -R tftp:tftp /srv/nfs\n$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre> <p>Also update the kernel and Device Tree Binaries used by your board, from the ones compiled by Buildroot in <code>output/images/</code>.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/output/\"\n$ cp images/zImage /srv/tftp/zImage-buildroot\n$ cp images/zImage /srv/tftp/zImage\n$ cp $(find images -name \"am335x-boneblack-custom.dtb\") /srv/tftp/\n</code></pre> <p>You should restore U-Boot to work with TFTP and NFS. Run the board, press a key to reach the U-Boot prompt, and restore the environment variables. Finally, reset the board. You should now be able to log in (<code>root</code> account, no password) to reach a shell.</p> picocomBBB - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootcmd $bootcmd_tftp\n=&gt; setenv bootargs $bootargs_nfs\n=&gt; saveenv\n=&gt; reset\n    ...\nWelcome to Buildroot\nbuildroot login: root\n#\n</code></pre>"},{"location":"bbb/buildroot/#loading-the-usb-audio-module","title":"Loading the USB audio module","text":"<p>You can check that no kernel module is loaded yet. Try to load the <code>snd_usb_audio</code> module from the command line.</p> picocomBBB - Buildroot<pre><code># lsmod\nModule                  Size  Used by    Not tainted\n# modprobe snd_usb_audio\nmc: Linux media interface: v0.10\nusbcore: registered new interface driver snd-usb-audio\n</code></pre> <p>Check that Buildroot has deployed the modules for your kernel in <code>/lib/modules/</code>.</p> picocomBBB - Buildroot<pre><code># find /lib/modules/ -name snd-usb-audio.ko\n/lib/modules/5.15.26/kernel/sound/usb/snd-usb-audio.ko\n</code></pre> <p>Let's automate this now! Look at the <code>/etc/inittab</code> file generated by Buildroot (Q to quit <code>less</code>), and at the contents of the <code>/etc/init.d/</code> directory, in particular of the <code>rcS</code> file.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ less etc/inittab\n$ ls etc/init.d/\nrcK  rcS  S01syslogd  S02klogd  S02sysctl  S20urandom  S40network  S95mpd\n</code></pre> File: etc/init.d/rcS<pre><code>#!/bin/sh\n# Start all init scripts in /etc/init.d\n# executing them in numerical order.\n#\nfor i in /etc/init.d/S??* ;do\n# Ignore dangling symlinks (if any).\n[ ! -f \"$i\" ] &amp;&amp; continue\ncase \"$i\" in\n*.sh)\n# Source shell script for speed.\n(\ntrap - INT QUIT TSTP\n                set start\n                . $i\n)\n;;\n*)\n# No sh extension, so fork subprocess.\n$i start\n            ;;\nesac\ndone\n</code></pre> <p>You can see that <code>rcS</code> executes or sources all the <code>/etc/init.d/S??*</code> files. We can add our own which will load the top-level modules that we need.</p> <p>Let's do this by creating an overlay directory, typically under our board-specific directory, that Buildroot adds after building the root filesystem.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ mkdir -p board/bootlin/training/rootfs-overlay/\n</code></pre> <p>Then add a custom startup script, by adding an <code>etc/init.d/S03modprobe</code> executable file to the overlay directory, with content:</p> File: etc/init.d/S03modprobe<pre><code>#!/bin/sh\nmodprobe snd-usb-audio\n</code></pre> <pre><code>$ cd board/bootlin/training/rootfs-overlay/\n$ mkdir -p etc/init.d/\n$ cat &gt; etc/init.d/S03modprobe &lt;&lt;'EOF'\n#!/bin/sh\nmodprobe snd-usb-audio\nEOF\n$ chmod +x etc/init.d/S03modprobe\n</code></pre> <p>Then, go back to Buildroot's configuration interface.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make menuconfig\n$ cp .config ../buildroot-rootfs-overlay.config\n</code></pre> <p>In <code>System configuration</code>:</p> <ul> <li>Set <code>Root filesystem overlay directories</code> = <code>board/bootlin/training/rootfs-overlay</code>.</li> </ul> <p>Build your image again. This should be quick as Buildroot doesn't need to recompile anything. It will just apply the root filesystem overlay.</p> <p>Update your <code>nfsroot</code> directory, reboot the board, and check that the <code>snd_usb_audio</code> module is loaded as expected.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make\n$ cd \"$LAB_PATH/nfsroot/\"\n$ rm -rf *\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre> picocomBBB - Buildroot<pre><code># reboot\n    ...\n# lsmod\nModule                  Size  Used by    Not tainted\nsnd_usb_audio         217088  0\nsnd_hwdep              16384  1 snd_usb_audio\nsnd_usbmidi_lib        28672  1 snd_usb_audio\nmc                     36864  1 snd_usb_audio\nsnd_rawmidi            28672  1 snd_usbmidi_lib\nsnd_pcm               106496  1 snd_usb_audio\nsnd_timer              28672  1 snd_pcm\nsnd                    61440  6 snd_usb_audio,snd_hwdep,snd_usbmidi_lib,snd_rawmidi,snd_pcm,snd_timer\nsoundcore              16384  1 snd\n</code></pre> <p>You can run <code>speaker-test</code> to check that this application works with the USB headset.</p> picocomBBB - Buildroot<pre><code># speaker-test -t sine -l 1\nspeaker-test 1.2.6\nPlayback device is default\nStream parameters are 48000Hz, S16_LE, 1 channels\nSine wave rate is 440.0000Hz\nRate set to 48000Hz (requested 48000Hz)\nBuffer size range from 2229 to 17832\nPeriod size range from 1114 to 1115\nUsing max buffer size 17832\nPeriods = 4\nwas set period_size = 1114\nwas set buffer_size = 17832\n 0 - Front Left\nTime per period = 2.647185\n</code></pre>"},{"location":"bbb/buildroot/#testing-mpd-and-mpc","title":"Testing <code>mpd</code> and <code>mpc</code>","text":"<p>The next thing we want to do is play real sound samples with the Music Player Daemon (MPD). So, let's add music files for MPD to play. Update your root filesystem, and restart your system.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ mkdir -p board/bootlin/training/rootfs-overlay/var/lib/mpd/music\n$ cp ../data/music/* board/bootlin/training/rootfs-overlay/var/lib/mpd/music\n$ make\n$ cd \"$LAB_PATH/nfsroot/\"\n$ rm -rf *\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre> <p>Using the <code>ps</code> command, check that the <code>mpd</code> server was started by the system, as implemented by the <code>/etc/init.d/S95mpd</code> script.</p> picocomBBB - Buildroot<pre><code># reboot\n    ...\n# ps | grep mpd\n  126 root     /usr/bin/mpd\n  134 root     grep mpd\n</code></pre> <p>If that's the case, you are now ready to run <code>mpc</code> client commands to control music playback. First, let's make <code>mpd</code> process the newly added music files. Run <code>mpc update</code> on the target:</p> picocomBBB - Buildroot<pre><code># mpc update\nUpdating DB (#2) ...\nvolume:100%   repeat: off   random: off   single: off   consume: off\n</code></pre> <p>You should see the files getting indexed by displaying the contents of the <code>/var/log/mpd.log</code> file.</p> picocomBBB - Buildroot<pre><code># cat /var/log/mpd.log\nJan 01 00:00 : update: added /6-le-baguette.ogg\nJan 01 00:00 : update: added /7-fireworks.ogg\nJan 01 00:00 : update: added /1-sample.ogg\nJan 01 00:00 : update: added /3-chronos.ogg\nJan 01 00:00 : update: added /4-land-of-pirates.ogg\nJan 01 00:00 : update: added /2-arpent.ogg\nJan 01 00:00 : update: added /5-ukulele-song.ogg\n</code></pre> <p>You can also check the list of available files:</p> picocomBBB - Buildroot<pre><code># mpc listall\n1-sample.ogg\n2-arpent.ogg\n5-ukulele-song.ogg\n3-chronos.ogg\n7-fireworks.ogg\n6-le-baguette.ogg\n4-land-of-pirates.ogg\n</code></pre> <p>To play files, you first need to create a playlist. Let's create a playlist by adding all music files to it, then you should be able to start playing its songs.</p> picocomBBB - Buildroot<pre><code># mpc add /\n# mpc play\n1-sample.ogg\n[playing] #1/7   0:00/0:19 (0%)\nvolume:100%   repeat: off   random: off   single: off   consume: off\n</code></pre> <p>Here are a few further commands for controlling playback:</p> <ul> <li><code>mpc stop</code>: stop playing.</li> <li><code>mpc volume +5</code>: increase the volume by 5%.</li> <li><code>mpc volume -5</code>: reduce the volume by 5%.</li> <li><code>mpc prev</code>: switch to the previous song in the playlist.</li> <li><code>mpc next</code>: switch to the next song in the playlist.</li> <li><code>mpc toggle</code>: toggle between pause and playback modes.</li> </ul> <p>If you find that changing the volume is not available, you can add a custom configuration for MPD, as the standard one provided by Buildroot doesn't support allowing to change the audio playback volume with all sound cards we have tested. We can simply add a custom MPD configuration file to our overlay. Run Buildroot again, update your root filesystem, reboot (to get MPD restarted with the new configuration file), and make sure modifying the volume now works.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ cp ../data/mpd.conf board/bootlin/training/rootfs-overlay/etc/\n$ make\n$ cd \"$LAB_PATH/nfsroot/\"\n$ rm -rf *\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre> picocomBBB - Buildroot<pre><code># reboot\n    ...\n# mpc add /\n# mpc play\n# mpc volume -5\n# mpc volume +5\n</code></pre> <p>Later, we're going to compile and debug a custom MPD client application.</p>"},{"location":"bbb/buildroot/#analyzing-dependencies","title":"Analyzing dependencies","text":"<p>It's always useful to understand the dependencies drawn by the packages we build. First we need to install Graphviz and a PDF viewer:</p> <pre><code>$ sudo apt install evince graphviz\n</code></pre> <p>Now, let's use Buildroot's target to generate a dependency graph. Once generated, it can ve viewed for visual inspection.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make graph-depends\nGetting dependency tree...\ndot  -Tpdf \\\n        -o /home/me/embedded-linux-bbb-labs/buildroot/buildroot/output/graphs/graph-depends.pdf \\\n        /home/me/embedded-linux-bbb-labs/buildroot/buildroot/output/graphs/graph-depends.dot\n$ evince output/graphs/graph-depends.pdf\n$ cp output/graphs/graph-depends.pdf ../graph-depends.pdf\n</code></pre> <p>In particular, you can see that adding MPD and its client required to compile Meson for the host, and in turn, Python 3 for the host too. This substantially contributed to the build time.</p> <p></p>"},{"location":"bbb/buildroot/#adding-a-package","title":"Adding a package","text":"<p>We would also like to build our Nunchuk external module with Buildroot. Fortunately, Buildroot has a <code>kernel-module</code> infrastructure to build kernel modules.</p> <p>First, create a <code>nunchuk-driver</code> subdirectory under package in Buildroot sources.</p> <p>The first thing is to create a <code>package/nunchuk-driver/Config.in</code> file for Buildroot's configuration:</p> File: package/nunchuk-driver/Config.in<pre><code>config BR2_PACKAGE_NUNCHUK_DRIVER\n        bool \"nunchuk-driver\"\ndepends on BR2_LINUX_KERNEL\n        help\n                Linux Kernel module for the I2C Nunchuk.\n</code></pre> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ mkdir -p package/nunchuk-driver/\n$ cat &gt; package/nunchuk-driver/Config.in &lt;&lt;'EOF'\nconfig BR2_PACKAGE_NUNCHUK_DRIVER\n        bool \"nunchuk-driver\"\n        depends on BR2_LINUX_KERNEL\n        help\n                Linux Kernel module for the I2C Nunchuk.\nEOF\n$ cp package/nunchuk-driver/Config.in ../nunchuk-driver-Config.in\n</code></pre> <p>Then add a line to <code>package/Config.in</code> to include this file, for example right before the line including <code>package/nvidia-driver/Config.in</code>, so that the alphabetic order of configuration options is preserved:</p> File: package/Config.in<pre><code>    ...\nmenu \"Hardware handling\"\n...\n        source \"package/msr-tools/Config.in\"\nsource \"package/nanocom/Config.in\"\nsource \"package/neard/Config.in\"\nsource \"package/nunchuk-driver/Config.in\"\nsource \"package/nvidia-driver/Config.in\"\nsource \"package/nvidia-modprobe/Config.in\"\nsource \"package/nvme/Config.in\"\n...\n</code></pre> <pre><code>$ nano package/Config.in\n$ cp package/Config.in ../package-nunchuk-Config.in\n</code></pre> <p>Then, the next and last thing you need to do is to create <code>package/nunchuk-driver/nunchukdriver.mk</code> describing how to build the package. You can see that we're sourcing files from our hardware lab.</p> File: package/nunchuk-driver/nunchukdriver.mk<pre><code>NUNCHUK_DRIVER_VERSION = 1.0\nNUNCHUK_DRIVER_SITE = $(HOME)/embedded-linux-bbb-labs/hardware/data/nunchuk\nNUNCHUK_DRIVER_SITE_METHOD = local\nNUNCHUK_DRIVER_LICENSE = GPL-2.0\n\n$(eval $(kernel-module))\n$(eval $(generic-package))\n</code></pre> <pre><code>$ cat &gt; package/nunchuk-driver/nunchukdriver.mk &lt;&lt;'EOF'\nNUNCHUK_DRIVER_VERSION = 1.0\nNUNCHUK_DRIVER_SITE = $(HOME)/embedded-linux-bbb-labs/hardware/data/nunchuk\nNUNCHUK_DRIVER_SITE_METHOD = local\nNUNCHUK_DRIVER_LICENSE = GPL-2.0\n$(eval $(kernel-module))\n$(eval $(generic-package))\nEOF\n$ cp package/nunchuk-driver/nunchukdriver.mk ../nunchukdriver.mk\n</code></pre> <p>Then, configure Buildroot to build your package. Just follow the menus as described in the configuration file we added before.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make menuconfig\n$ cp .config ../buildroot-nunchuk.config\n</code></pre> <p>In <code>Target packages</code> \u2192 <code>Hardware handling</code>:</p> <ul> <li>Enable <code>nunchuk-driver (NEW)</code>.</li> </ul> <p>Now run Buildroot and update your root filesystem.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make\n  ...\n&gt;&gt;&gt; nunchuk-driver 1.0 Syncing from source dir /home/me/embedded-linux-bbb-labs/hardware/data/nunchuk\n&gt;&gt;&gt; nunchuk-driver 1.0 Configuring\n&gt;&gt;&gt; nunchuk-driver 1.0 Building\n&gt;&gt;&gt; nunchuk-driver 1.0 Building kernel module(s)\n&gt;&gt;&gt; nunchuk-driver 1.0 Installing to target\n&gt;&gt;&gt; nunchuk-driver 1.0 Installing kernel module(s)\n  ...\n$ cd \"$LAB_PATH/nfsroot/\"\n$ rm -rf *\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre> <p>Check that you can load the Nunchuk module now.</p> picocomBBB - Buildroot<pre><code># reboot\n    ...\n# modprobe nunchuk\nnunchuk: loading out-of-tree module taints kernel.\ninput: Wii Nunchuk as /devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1/1-0052/input/input0\nNunchuk device probed successfully\n</code></pre> <p>If everything's fine, add a line to <code>/etc/init.d/S03modprobe</code> for this driver, and update your root filesystem once again.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ cd board/bootlin/training/rootfs-overlay/\n$ echo \"modprobe nunchuk\" &gt;&gt; etc/init.d/S03modprobe\n$ cd \"$LAB_PATH/buildroot/\"\n$ make\n$ cd \"$LAB_PATH/nfsroot/\"\n$ rm -rf *\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre>"},{"location":"bbb/buildroot/#testing-the-nunchuk","title":"Testing the Nunchuk","text":"<p>Now that we have the Nunchuk driver loaded and that Buildroot compiled <code>evtest</code> for the target, thanks to Buildroot, we can now test the input events coming from the Nunchuk.</p> picocomBBB - Buildroot<pre><code># reboot\n    ...\n# evtest\nNo device specified, trying to scan all of /dev/input/event*\nAvailable devices:\n/dev/input/event0:      Wii Nunchuk\nSelect the device event number [0-0]: 0\nInput driver version is 1.0.1\nInput device ID: bus 0x18 vendor 0x0 product 0x0 version 0x0\nInput device name: \"Wii Nunchuk\"\nSupported events:\n  Event type 0 (EV_SYN)\n  Event type 1 (EV_KEY)\n    Event code 304 (BTN_SOUTH)\n    Event code 305 (BTN_EAST)\n    Event code 306 (BTN_C)\n    Event code 307 (BTN_NORTH)\n    Event code 308 (BTN_WEST)\n    Event code 309 (BTN_Z)\n    Event code 310 (BTN_TL)\n    Event code 311 (BTN_TR)\n    Event code 312 (BTN_TL2)\n    Event code 313 (BTN_TR2)\n    Event code 314 (BTN_SELECT)\n    Event code 315 (BTN_START)\n    Event code 316 (BTN_MODE)\n  Event type 3 (EV_ABS)\n    Event code 0 (ABS_X)\n      Value    124\n      Min       30\n      Max      220\n      Fuzz       4\n      Flat       8\n    Event code 1 (ABS_Y)\n      Value    124\n      Min       40\n      Max      200\n      Fuzz       4\n      Flat       8\nProperties:\nTesting ... (interrupt to exit)\nEvent: time 66.081447, type 1 (EV_KEY), code 309 (BTN_Z), value 1\nEvent: time 66.081447, -------------- SYN_REPORT ------------\nEvent: time 66.281432, type 1 (EV_KEY), code 309 (BTN_Z), value 0\nEvent: time 66.281432, -------------- SYN_REPORT ------------\nEvent: time 71.181449, type 1 (EV_KEY), code 306 (BTN_C), value 1\nEvent: time 71.181449, -------------- SYN_REPORT ------------\nEvent: time 71.281437, type 1 (EV_KEY), code 306 (BTN_C), value 0\nEvent: time 71.281437, -------------- SYN_REPORT ------------\n</code></pre> <p>Enter the number corresponding to the Nunchuk device.</p> <p>You can now press the Nunchuk buttons, use the joypad, and see which input events are emitted.</p> <p>By the way, you can also test which input events are exposed by the driver for your audio headset (if any), which doesn't mean that they physically exist.</p>"},{"location":"bbb/buildroot/#commit-your-changes","title":"Commit your changes","text":"<p>As we are going to reuse our Buildroot changes in the next labs, let's commit them into the dedicated Buildroot branch we created (<code>embedded-linux-bbb</code>):</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ git status\nOn branch embedded-linux-bbb\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   package/Config.in\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        board/bootlin/\n        package/nunchuk-driver/\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git add  board/bootlin/  package/nunchuk-driver/  package/Config.in\n$ git commit -as -m \"Bootlin lab changes\"\n</code></pre>"},{"location":"bbb/buildroot/#going-further","title":"Going further","text":"<p>For more music playing fun, you can install the <code>ario</code> or <code>cantata</code> MPD client on your host machine, configure to connect to the IP address of your target system with the default port, and you will also be able to control playback from your host machine.</p> <pre><code>$ sudo apt install ario cantata\n</code></pre> <p>TODO</p>"},{"location":"bbb/buildroot/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-buildroot.cpio.xz\"\n$ cd \"$LAB_PATH/buildroot/\"\n$ tar cfJv \"$LAB_PATH/buildroot-patch.tar.xz\" board/bootlin/ package/nunchuk-driver/ package/Config.in\n$ cd \"$LAB_PATH/buildroot/output/images/\"\n$ tar cfJv \"$LAB_PATH/buildroot-rootfs.tar.xz\" rootfs.tar\n$ cd /srv/tftp/\n$ tar cfJv \"$LAB_PATH/buildroot-tftp.tar.xz\" zImage am335x-boneblack-custom.dtb\n</code></pre>"},{"location":"bbb/buildroot/#git-bundle","title":"git bundle","text":"<p>To create a git bundle with just our patch (to have consistent git commit naming):</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ label=\"2022.02\"\n$ bundle=\"$LAB_PATH/buildroot-$label-bootlin.bundle\"\n$ git bundle create $bundle $label..\n</code></pre> <p>To restore the git bundle:</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ label=\"2022.02\"\n$ bundle=\"$LAB_PATH/buildroot-$label-bootlin.bundle\"\n$ git bundle verify $bundle\nThe bundle contains this ref:\n1dcc6c688d2ecdd1ed3a579584bb6223c209d301 HEAD\nThe bundle requires this ref:\n08967921c4a91eb7d966c31f755a0720914e8bff\n/home/me/embedded-linux-bbb-labs/buildroot/buildroot-2022.02-bootlin.bundle is okay\n$ git checkout -b embedded-linux-bbb $label\n    ...\n$ git bundle list-heads $bundle\n1dcc6c688d2ecdd1ed3a579584bb6223c209d301 HEAD\n$ git pull $bundle\n</code></pre>"},{"location":"bbb/buildroot/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/hardware/","title":"Accessing Hardware Devices","text":""},{"location":"bbb/hardware/#objectives","title":"Objectives","text":"<ul> <li>Learn how to access hardware devices.</li> </ul>"},{"location":"bbb/hardware/#setup","title":"Setup","text":"<p>Go to the <code>$HOME/embedded-linux-bbb-labs/hardware/</code> directory, which provides useful files for this lab. However, we will go on booting the system through NFS, using the root filesystem built by the previous lab.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/hardware\"\n$ cd $LAB_PATH\n</code></pre>"},{"location":"bbb/hardware/#exploring-dev","title":"Exploring <code>/dev</code>","text":"<p>Start by exploring <code>/dev/</code> on your target system.</p> picocomBBB - BusyBox<pre><code># ls /dev/\nbus              ram1             tty26            tty59\nconsole          ram10            tty27            tty6\ncpu_dma_latency  ram11            tty28            tty60\nfull             ram12            tty29            tty61\ngpiochip0        ram13            tty3             tty62\ngpiochip1        ram14            tty30            tty63\ngpiochip2        ram15            tty31            tty7\ngpiochip3        ram2             tty32            tty8\nhwrng            ram3             tty33            tty9\ni2c-0            ram4             tty34            ttyS0\ni2c-2            ram5             tty35            ttyS1\nkmsg             ram6             tty36            ttyS2\nloop-control     ram7             tty37            ttyS3\nloop0            ram8             tty38            ttyS4\nloop1            ram9             tty39            ttyS5\nloop2            random           tty4             ubi_ctrl\nloop3            tty              tty40            urandom\nloop4            tty0             tty41            vcs\nloop5            tty1             tty42            vcs1\nloop6            tty10            tty43            vcs2\nloop7            tty11            tty44            vcs3\nmem              tty12            tty45            vcs4\nmmcblk0          tty13            tty46            vcsa\nmmcblk0p1        tty14            tty47            vcsa1\nmmcblk0p2        tty15            tty48            vcsa2\nmmcblk0p3        tty16            tty49            vcsa3\nmmcblk1          tty17            tty5             vcsa4\nmmcblk1boot0     tty18            tty50            vcsu\nmmcblk1boot1     tty19            tty51            vcsu1\nmmcblk1p1        tty2             tty52            vcsu2\nmmcblk1rpmb      tty20            tty53            vcsu3\nnull             tty21            tty54            vcsu4\nport             tty22            tty55            vga_arbiter\nptmx             tty23            tty56            zero\nptp0             tty24            tty57\nram0             tty25            tty58\n</code></pre> <p>Here are a few noteworthy device files that you will see:</p> <ul> <li> <p>Terminal devices: devices starting with <code>tty</code>.   Terminals are user interfaces taking text as input and producing text as output, and are typically used by interactive shells.   In particular, you will find console which matches the device specified through <code>console=</code> in the kernel command line (U-Boot's <code>bootargs</code>).   You will also find the <code>ttyS0</code> device file we used for the emulated debug serial port.</p> </li> <li> <p>Pseudo-terminal devices: devices starting with <code>pty</code>, used when you connect through SSH for example.   Those are virtual devices, but there are so many in <code>/dev/</code> that we wanted to give a description here.</p> </li> <li> <p>MMC devices and partitions: devices starting with <code>mmcblk</code>.   You should here recognize the MMC devices on your system, and the associated partitions.</p> </li> <li> <p>If you have a real board (not QEMU) and a USB pen drive, you could plug it in, and if your kernel was built with USB host and mass storage support, you should see a new <code>sda</code> device appear, together with the <code>sdaX</code> devices for its partitions.</p> </li> </ul> <p>Don't hesitate to explore <code>/dev/</code> on your workstation too!</p> <pre><code>$ ls /dev/\nautofs           loop1         rtc0      tty2   tty47      ttyS15   vboxguest\nblock            loop10        sda       tty20  tty48      ttyS16   vboxuser\nbsg              loop11        sda1      tty21  tty49      ttyS17   vcs\nbtrfs-control    loop12        sdb       tty22  tty5       ttyS18   vcs1\nbus              loop13        sdb1      tty23  tty50      ttyS19   vcs2\ncdrom            loop14        sdc       tty24  tty51      ttyS2    vcs3\nchar             loop2         sg0       tty25  tty52      ttyS20   vcs4\nconsole          loop3         sg1       tty26  tty53      ttyS21   vcs5\ncore             loop4         sg2       tty27  tty54      ttyS22   vcs6\ncpu              loop5         sg3       tty28  tty55      ttyS23   vcsa\ncpu_dma_latency  loop6         shm       tty29  tty56      ttyS24   vcsa1\ncuse             loop7         snapshot  tty3   tty57      ttyS25   vcsa2\ndisk             loop8         snd       tty30  tty58      ttyS26   vcsa3\ndma_heap         loop9         sr0       tty31  tty59      ttyS27   vcsa4\ndri              loop-control  stderr    tty32  tty6       ttyS28   vcsa5\necryptfs         mapper        stdin     tty33  tty60      ttyS29   vcsa6\nfb0              mcelog        stdout    tty34  tty61      ttyS3    vcsu\nfd               mem           tty       tty35  tty62      ttyS30   vcsu1\nfull             mqueue        tty0      tty36  tty63      ttyS31   vcsu2\nfuse             net           tty1      tty37  tty7       ttyS4    vcsu3\nhidraw0          null          tty10     tty38  tty8       ttyS5    vcsu4\nhpet             nvram         tty11     tty39  tty9       ttyS6    vcsu5\nhugepages        port          tty12     tty4   ttyprintk  ttyS7    vcsu6\nhwrng            ppp           tty13     tty40  ttyS0      ttyS8    vfio\ni2c-0            psaux         tty14     tty41  ttyS1      ttyS9    vga_arbiter\ninitctl          ptmx          tty15     tty42  ttyS10     udmabuf  vhci\ninput            pts           tty16     tty43  ttyS11     uhid     vhost-net\nkmsg             random        tty17     tty44  ttyS12     uinput   vhost-vsock\nlog              rfkill        tty18     tty45  ttyS13     urandom  zero\nloop0            rtc           tty19     tty46  ttyS14     userio   zfs\n</code></pre>"},{"location":"bbb/hardware/#exploring-sys","title":"Exploring <code>/sys</code>","text":"<p>The next thing you can explore is the sysfs filesystem.</p> <p>A good place to start is <code>/sys/class/</code>, which exposes devices classified by the kernel frameworks which manage them.</p> picocomBBB - BusyBox<pre><code># ls /sys/class/\nata_device    extcon        mdio_bus      power_supply  scsi_host\nata_link      firmware      mem           pps           spi_master\nata_port      gpio          misc          ptp           thermal\nbacklight     graphics      mmc_host      pwm           tty\nbdi           i2c-adapter   mtd           regulator     ubi\nblock         i2c-dev       net           remoteproc    udc\ndevcoredump   input         pci_bus       rtc           vc\ndevlink       iommu         pci_epc       scsi_device   vtconsole\ndma           lcd           phy           scsi_disk     wakeup\n</code></pre> <p>For example, go to <code>/sys/class/net/</code>, and you will see all the networking interfaces on your system, whether they are internal, external or virtual ones.</p> picocomBBB - BusyBox<pre><code># ls /sys/class/net/\neth0  lo    sit0  usb0\n</code></pre> <p>Find which subdirectory corresponds to the network connection to your host system, and then check device properties such as:</p> <ul> <li> <p><code>speed</code>: will show you whether this is a gigabit or hundred megabit interface.</p> </li> <li> <p><code>address</code>: will show the device MAC address. No need to get it from a complex command!</p> </li> <li> <p><code>statistics/rx_bytes</code> will show you how many bytes were received on this interface.</p> </li> </ul> <p>Don't hesitate to look for further interesting properties by yourself!</p> picocomBBB - BusyBox<pre><code># ls /sys/class/net/eth0/\naddr_assign_type      flags                 phys_port_name\naddr_len              gro_flush_timeout     phys_switch_id\naddress               ifalias               power\nbroadcast             ifindex               proto_down\ncarrier               iflink                queues\ncarrier_changes       link_mode             speed\ncarrier_down_count    mtu                   statistics\ncarrier_up_count      name_assign_type      subsystem\ndev_id                napi_defer_hard_irqs  testing\ndev_port              netdev_group          threaded\ndevice                operstate             tx_queue_len\ndormant               phydev                type\nduplex                phys_port_id          uevent\n# cat /sys/class/net/eth0/speed\n100\n# cat /sys/class/net/eth0/address\n54:4a:16:be:9e:ae\n# cat /sys/class/net/eth0/statistics/rx_bytes\n925186\n</code></pre> <p>You can also check whether <code>/sys/class/thermal/</code> exists and is not empty on your system. That's the thermal framework, and it allows to access temperature measures from the thermal sensors on your system.</p> picocomBBB - BusyBox<pre><code># ls /sys/class/thermal/\n</code></pre> <p>Next, you can now explore all the buses (virtual or physical) available on your system, by checking the contents of <code>/sys/bus/</code>. In particular, go to <code>/sys/bus/mmc/devices/</code> to see all the MMC devices on your system. Go inside the directory for the first device and check several files (for example):</p> <ul> <li> <p><code>serial</code>: the serial number for your device.</p> </li> <li> <p><code>preferred_erase_size</code>: the preferred erase block for your device. It's recommended that partitions start at multiples of this size.</p> </li> <li> <p><code>name</code>: the product name for your device. You could display it in a user interface or log file, for example.</p> </li> </ul> picocomBBB - BusyBox<pre><code># ls /sys/bus/\nclockevents   genpd         mipi-dsi      pci-epf       soc\nclocksource   gpio          mmc           platform      spi\ncontainer     hid           mmc_rpmb      scsi          usb\ncpu           i2c           nvmem         sdio          virtio\nevent_source  mdio_bus      pci           serial        workqueue\n# ls /sys/bus/mmc/devices/\nmmc0:0001  mmc1:0001\n# ls /sys/bus/mmc/devices/mmc0:0001/\nblock                 hwrev                 scr\ncid                   manfid                serial\ncsd                   name                  ssr\ndate                  ocr                   subsystem\ndriver                oemid                 type\ndsr                   power                 uevent\nerase_size            preferred_erase_size\nfwrev                 rca\n# cat /sys/bus/mmc/devices/mmc0:0001/serial\n0x000015f1\n# cat /sys/bus/mmc/devices/mmc0:0001/preferred_erase_size\n4194304\n# cat /sys/bus/mmc/devices/mmc0:0001/name\nSD16G\n</code></pre> <p>Don't hesitate to spend more time exploring <code>/sys/</code> on your system!</p>"},{"location":"bbb/hardware/#driving-gpios","title":"Driving GPIOs","text":"<p>At this stage, we can only explore GPIOs through the legacy interface in <code>/sys/class/gpio/</code>, because the <code>libgpiod</code> interface commands are provided through a dedicated project which we have to build separately, and BusyBox does not provide a re-implementation for the <code>libgpiod</code> tools. In a later lab, we will build <code>libgpiod</code> tools which use the modern <code>/dev/gpiochipX</code> interface.</p> <p>The first thing to do is to enable this legacy interface by enabling <code>CONFIG_GPIO_SYSFS</code> in the kernel configuration. Also make sure debugfs is enabled (<code>CONFIG_DEBUG_FS</code> and <code>CONFIG_DEBUG_FS_ALLOW_ALL</code>).</p> <p>After rebooting the new kernel, the first thing to do is to mount the debugfs filesystem. Then, you can check information about available GPIOs banks and which GPIOs are already in use.</p> picocomBBB - BusyBox<pre><code># mount -t debugfs debugfs /sys/kernel/debug/\n# cat /sys/kernel/debug/gpio\ngpiochip0: GPIOs 0-31, parent: platform/4804c000.gpio, gpio-0-31:\n gpio-0   (P8_25 [mmc1_dat0]   )\n gpio-1   ([mmc1_dat1]         )\n    ...\n gpio-30  (P8_21 [emmc]        )\n gpio-31  (P8_20 [emmc]        )\ngpiochip1: GPIOs 32-63, parent: platform/481ac000.gpio, gpio-32-63:\n gpio-32  (P9_15B              )\n gpio-33  (P8_18               )\n    ...\n gpio-62  ([mmc0_clk]          )\n gpio-63  ([mmc0_cmd]          )\ngpiochip2: GPIOs 64-95, parent: platform/481ae000.gpio, gpio-64-95:\n gpio-64  ([mii col]           )\n gpio-65  ([mii crs]           )\n    ...\n gpio-94  (NC                  )\n gpio-95  (NC                  )\ngpiochip3: GPIOs 96-127, parent: platform/44e07000.gpio, gpio-96-127:\n gpio-96  ([mdio_data]         )\n gpio-97  ([mdio_clk]          )\n    ...\n gpio-126 (P9_11 [uart4_rxd]   )\n gpio-127 (P9_13 [uart4_txd]   )\n</code></pre> <p>We are going to use one of the free GPIOs on the expansion headers of the board, which is not already used by another device.</p> <p></p> <p>Take one of the M-M breadboard wires and:</p> <ul> <li>Connect one end to pin 12 of connector P9.</li> <li>Connect the other end to pin 1 (<code>DGND</code>) of connector P9.</li> </ul> <p>If you check the description of the P9 connector on the board System Reference Manual, you can see that pin 12 is now called <code>GPIO1_28</code> instead of <code>GPIO_60</code> in the above diagram. This pin is already configured as a GPIO by default \u2014 no need to change pin muxing to use this pin as a GPIO.</p> <p>If you get back to the contents of <code>/sys/kernel/debug/gpio/</code>, you'll recognize the association between <code>gpio-28</code> on GPIO pin bank <code>0</code> (<code>gpiochip0</code>) and header pin <code>P9_12</code>. That's very useful information, but you don't have this level of details for all boards, unfortunately.</p> <p>We now have everything we need to drive this GPIO using the legacy interface. First, let's enable it.</p> picocomBBB - BusyBox<pre><code># cd /sys/class/gpio/\n# ls -1\nexport\ngpiochip0\ngpiochip32\ngpiochip64\ngpiochip96\nunexport\n# echo 28 &gt; export\n# ls -1\nexport\ngpio28\ngpiochip0\ngpiochip32\ngpiochip64\ngpiochip96\nunexport\n</code></pre> <p>If indeed the pin is still available, this should create a new <code>gpio28</code> file should appear in <code>/sys/class/gpio/</code>.</p> <p>We can now configure this pin as input, and check its <code>value</code>. You could use this GPIO to add a button switch to your board, for example. The value should be <code>0</code> as the pin is connected to a ground level.</p> picocomBBB - BusyBox<pre><code># echo in &gt; gpio28/direction\n# cat gpio28/value\n0\n</code></pre> <p>Now, let's connect our GPIO pin to pin 3 (VDD 3.3 V) of connector P9. Check the above diagram if needed. Let's check the <code>value</code> again. The value is <code>1</code> because our pin is connected to a 3.3 V level now.</p> picocomBBB - BusyBox<pre><code># cat gpio28/value\n1\n</code></pre> <p>Note that you could also configure the pin as output and set its value through the <code>value</code> file. This way, you could add an external LED to your board, for example.</p> <p>Before moving on to the next section, you can also check <code>/sys/kernel/debug/gpio/</code> again, and see that <code>gpio-28</code> is now in use, through the sysfs interface, and is configured as an input pin.</p> <p>When you're done, you can see your GPIO free.</p> picocomBBB - BusyBox<pre><code># echo 28 &gt; unexport\n</code></pre>"},{"location":"bbb/hardware/#driving-leds","title":"Driving LEDs","text":"<p>First, make sure your kernel is compiled with:</p> <ul> <li><code>LEDS_CLASS=y</code></li> <li><code>LEDS_GPIO=y</code></li> <li><code>LEDS_TRIGGER_TIMER=y</code></li> </ul> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ cp \"$LAB_PATH/../tinysystem/kernel-busybox.config\" .config\n$ make menuconfig\n$ cp .config \"$LAB_PATH/kernel-leds.config\"\n$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export MAKEFLAGS=-j$(nproc)\n$ export ARCH=arm\n$ make\n$ cp arch/arm/boot/zImage /srv/tftp/zImage-with-LEDs\n$ cp arch/arm/boot/zImage /srv/tftp/zImage\n</code></pre> <p>Then, go to <code>/sys/class/leds/</code> to see all the LEDs that you are allowed to control.</p> picocomBBB - BusyBox<pre><code># cd /sys/class/leds/\n# ls -1\nbeaglebone:green:heartbeat\nbeaglebone:green:mmc0\nbeaglebone:green:usr2\nbeaglebone:green:usr3\nmmc0::\nmmc1::\n</code></pre> <p>Let's control the LED called <code>beaglebone:green:heartbeat</code>. Go into the directory for this LED, and check its <code>trigger</code> (what routine is used to drive its value),</p> picocomBBB - BusyBox<pre><code># cd beaglebone:green:heartbeat/\n# triggers=$(cat trigger)\n# for t in $triggers; do echo $t; done\n[none]\nkbd-scrolllock\nkbd-numlock\nkbd-capslock\nkbd-kanalock\nkbd-shiftlock\nkbd-altgrlock\nkbd-ctrllock\nkbd-altlock\nkbd-shiftllock\nkbd-shiftrlock\nkbd-ctrlllock\nkbd-ctrlrlock\ntimer\ncpu\ncpu0\nmmc0\nmmc1\n</code></pre> <p>As you can see, there are many triggers to choose from, the current being <code>none</code>.</p> <p>You can directly control the LED without a trigger:</p> picocomBBB - BusyBox<pre><code># echo none &gt; trigger\n# echo 1 &gt; brightness\n# echo 0 &gt; brightness\n</code></pre> <p>You could also use the timer trigger to light the LED with specified time on and time off.</p> picocomBBB - BusyBox<pre><code># echo timer &gt; trigger\n# echo 10 &gt; delay_on\n# echo 200 &gt; delay_off\n</code></pre> <p>You can disable all triggers by:</p> picocomBBB - BusyBox<pre><code># echo none &gt; trigger\n</code></pre>"},{"location":"bbb/hardware/#managing-i2c-bus-and-devices","title":"Managing I2C bus and devices","text":""},{"location":"bbb/hardware/#enabling-i2c-bus","title":"Enabling I2C bus","text":"<p>The next thing we want to do is connect a Nintendo Nunchuk joystick to an I2C bus on our board. The I2C bus is very frequently used to connect all sorts of external devices. That's why we're covering it here.</p> <p>As shown on the picture below, the BeagleBone Black has two I2C busses available on its expansion headers: I2C1 and I2C2. Another one exists (I2C0), but it's not available on the external headers.</p> <p></p> <p>In this lab, we will try to use I2C1 on P9 pins 17 and 18, because it's more interesting to use than I2C2, which is already enabled by default.</p> <p>So, let's see which I2C buses are already enabled:</p> picocomBBB - BusyBox<pre><code># i2cdetect -l\ni2c-2   i2c             OMAP I2C adapter                        I2C adapter\ni2c-0   i2c             OMAP I2C adapter                        I2C adapter\n</code></pre> <p>Here you can see that I2C1 is missing.</p> <p>As the bus numbering scheme in Linux doesn't always match the one on the datasheets, let's check the base addresses of the registers of these controllers:</p> picocomBBB - BusyBox<pre><code># ls -l /sys/bus/i2c/devices/i2c-*\nlrwxrwxrwx    1         0 Jan  1 01:15 /sys/bus/i2c/devices/i2c-0 -&gt; \\\n../../../devices/platform/ocp/44c00000.interconnect/\\\n44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0\nlrwxrwxrwx    1         0 Jan  1 01:15 /sys/bus/i2c/devices/i2c-2 -&gt; \\\n../../../devices/platform/ocp/48000000.interconnect/\\\n48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2\n</code></pre> <p>That's not completely straighforward, but you can suppose that:</p> <ul> <li>I2C0 is at address <code>0x44e0b000</code></li> <li>I2C2 is at address <code>0x4819c000</code></li> </ul> <p>Now let's double check the addressings by looking at the TI AM335x SoC datasheet, in the L4_WKUP Peripheral Memory Map section:</p> <ul> <li>I2C0 is at address <code>0x44e0b000</code></li> <li>I2C1 is at address <code>0x4802a000</code></li> <li>I2C2 is at address <code>0x4819c000</code></li> </ul> <p>So, we are lucky that <code>i2c-0</code> in Linux corresponds to I2C0 in the datasheet, and that <code>i2c-2</code> corresponds to I2C2. We're just missing <code>i2c-1</code>.</p>"},{"location":"bbb/hardware/#customizing-device-tree","title":"Customizing Device Tree","text":"<p>Fortunately, I2C1 is already defined in the one of the DTS includes used by the Device Tree for our board. In our case, that's in <code>arch/arm/boot/dts/am33xx-l4.dtsi</code>. Look by yourself in this file, and you will find its definition, but with <code>status = \"disabled\";</code>. This means that this I2C controller is not enabled yet, and it's up to boards using it to do so.</p> <p>We could modify the <code>arch/arm/boot/dts/am335x-boneblack.dts</code> file for our board, but that's not a very good idea as this file is maintained by the kernel developers. The changes that you make could collide with future changes made by the maintainers for this file.</p> <p>A more futureproof idea is to create a new Device Tree file which includes the standard one, and adds custom definitions. So, create a new <code>arch/arm/boot/dts/am335x-boneblack-custom.dts</code> file containing:</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ nano arch/arm/boot/dts/am335x-boneblack-custom.dts\n</code></pre> arch/arm/boot/dts/am335x-boneblack-custom.dts<pre><code>/dts-v1/;\n#include \"am335x-boneblack.dts\"\n&amp;i2c1 {\nstatus = \"okay\";\n};\n</code></pre> <p>As you can see, it's also possible to include <code>dts</code> files, and not only <code>dtsi</code> ones.</p> <p>Modify the <code>arch/arm/boot/dts/Makefile</code> file to add your custom Device Tree, and then have it compiled (<code>make dtbs</code>).</p> arch/arm/boot/dts/Makefile<pre><code>    ...\ndtb-$(CONFIG_SOC_AM33XX) += \\\nam335x-baltos-ir2110.dtb \\\nam335x-baltos-ir3220.dtb \\\nam335x-baltos-ir5221.dtb \\\nam335x-base0033.dtb \\\nam335x-bone.dtb \\\nam335x-boneblack.dtb \\\nam335x-boneblack-custom.dtb \\\nam335x-boneblack-wireless.dtb \\\nam335x-boneblue.dtb \\\nam335x-bonegreen.dtb \\\n...\n</code></pre> <p>Update the board and reboot.</p> <pre><code>$ make dtbs\n  DTC     arch/arm/boot/dts/am335x-boneblack-custom.dtb\n$ cp arch/arm/boot/dts/am335x-boneblack-custom.dtb /srv/tftp/\n</code></pre> picocomBBB - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootcmd_tftp \"tftp 0x81000000 zImage;  tftp 0x82000000 am335x-boneblack-custom.dtb;  bootz 0x81000000 - 0x82000000\"\n=&gt; setenv bootcmd $bootcmd_tftp\n=&gt; saveenv\n=&gt; reset\n</code></pre> <p>Back to the running system, we can now see that there is one more I2C bus:</p> picocomBBB - BusyBox<pre><code># i2cdetect -l\ni2c-1   i2c             OMAP I2C adapter                        I2C adapter\ni2c-2   i2c             OMAP I2C adapter                        I2C adapter\ni2c-0   i2c             OMAP I2C adapter                        I2C adapter\n</code></pre> <p>Run the below command to confirm that the new bus has the same address as in the datasheet (<code>0x4802a000</code>):</p> picocomBBB - BusyBox<pre><code># ls -l /sys/bus/i2c/devices/i2c-1\nlrwxrwxrwx    1         0 Jan  1 00:02 /sys/bus/i2c/devices/i2c-1 -&gt; \\\n  ../../../devices/platform/ocp/48000000.interconnect/\\\n  48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1\n</code></pre> <p>Now, let's use <code>i2cdetect</code>'s capability to probe a bus for devices. Let's start by the bus associated to <code>i2c-0</code>:</p> picocomBBB - BusyBox<pre><code># i2cdetect -y -r 0\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n20: -- -- -- -- UU -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- 34 -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: 50 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --\n</code></pre> <p>We can see three devices on this internal bus:</p> <ul> <li> <p>One at address <code>0x24</code>, indicated by <code>UU</code>, which means that there is a kernel driver actively driving this device.</p> </li> <li> <p>Two other devices at addresses <code>0x34</code> and <code>0x50</code>. We just know that they are currently not bound to a kernel driver.</p> </li> </ul> <p>Now try to probe I2C1:</p> picocomBBB - BusyBox<pre><code># i2cdetect -y -r 1\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          [  469.430509] omap_i2c 4802a000.i2c: timeout waiting for bus ready\n    ...\n</code></pre> <p>You will see that the command will fail to connect to the bus. That's because the corresponding signals are not exposed yet to the outside connectors through pin muxing.</p> <p>So, get back to your custom Device Tree and add pin muxing definitions for I2C1 (we took them from a device tree from another board with the same CPU: <code>arch/arm/boot/dts/am335x-evm.dts</code>) and refer to these definitions in the <code>i2c1</code> node through the <code>pinctrl-names</code> and <code>pinctrl-0</code> properties:</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ nano arch/arm/boot/dts/am335x-boneblack-custom.dts\n</code></pre> arch/arm/boot/dts/am335x-boneblack-custom.dts<pre><code>/dts-v1/;\n#include \"am335x-boneblack.dts\"\n&amp;am33xx_pinmux {\ni2c1_pins: pinmux_i2c1_pins {\npinctrl-single,pins = &lt;\nAM33XX_PADCONF(AM335X_PIN_SPI0_CS0, PIN_INPUT_PULLUP, MUX_MODE2)  /* spi0_cs0.i2c1_scl */\nAM33XX_PADCONF(AM335X_PIN_SPI0_D1, PIN_INPUT_PULLUP, MUX_MODE2)  /* spi0_d1.i2c1_sda */\n&gt;;\n};\n};\n&amp;i2c1 {\npinctrl-names = \"default\";\npinctrl-0 = &lt;&amp;i2c1_pins&gt;;\nstatus = \"okay\";\n};\n</code></pre> <p>You can understand the above values thanks to the pin muxing diagram for connector P9, which was extracted from the board System Reference Manual:</p> <ul> <li> <p><code>AM335X_PIN_SPI0_CS0</code> and <code>AM335X_PIN_SPI0_D1</code> are the offsets of the registers controlling pin muxing for the corresponding pins of the SoC package.</p> </li> <li> <p><code>PIN_INPUT_PULLUP</code> is one of the supported options for these pins. They integrate the pull-up resistors expected for an I2C bus (typically by external resistors).</p> </li> <li> <p><code>MUX_MODE2</code> corresponds to MODE2, to get I2C1_SCL and I2C1_SDA signals on such pins.</p> </li> </ul> <p></p> <p>Recompile your Device Tree and reboot.</p> <pre><code>$ make dtbs\n  DTC     arch/arm/boot/dts/am335x-boneblack-custom.dtb\n$ cp arch/arm/boot/dts/am335x-boneblack-custom.dtb /srv/tftp/\n</code></pre> <p>You should now be able to probe your bus:</p> picocomBBB - BusyBox<pre><code># i2cdetect -y -r 1\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --\n</code></pre> <p>No device is detected yet, because this bus is just used for external devices. It's time to add one though.</p>"},{"location":"bbb/hardware/#adding-i2c-device","title":"Adding I2C device","text":"<p>Let's connect the Nunchuk to the I2C1 bus on the board. To know its pinout, please refer to the excerpt found on the Bootlin website. Connections on the Nunchuk depend on the adapter you're using (if any); please refer to its own pinout.</p> <p></p> <p>If you didn't make any mistakes, your new device should be detected at address <code>0x52</code>:</p> picocomBBB - BusyBox<pre><code># i2cdetect -y -r 1\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- -- 52 -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --\n</code></pre> <p>Later we're going to compile an out-of-tree kernel module to support this device.</p>"},{"location":"bbb/hardware/#plugging-an-audio-usb-headset","title":"Plugging an audio USB headset","text":"<p>In the next labs, we are going to play audio using a USB audio headset. Let's see whether our kernel supports such hardware by plugging the USB headset.</p> <p>Before plugging the device, look at the output of <code>lsusb</code>:</p> picocomBBB - BusyBox<pre><code># lsusb\nBus 001 Device 001: ID 1d6b:0002\n</code></pre> <p>Now, when you plug the USB headset, a number of messages should appear on the console, and running <code>lsusb</code> again should show an additional device:</p> picocomBBB - BusyBox<pre><code># lsusb\nBus 001 Device 001: ID 1d6b:0002\nBus 001 Device 002: ID 046d:0a38\n</code></pre> <p>The device of vendor ID <code>046d</code> and product ID <code>0a38</code> has appeared. Of course, this depends on the actual USB audio device that you used.</p> <p>The device also appears in <code>/sys/bus/usb/devices/</code>, in a directory whose name depends on the topology of the USB bus. When the device is plugged in the kernel messages show:</p> picocomBBB - BusyBox<pre><code># dmesg\n    ...\nusb 1-1: new full-speed USB device number 2 using musb-hdrc\nusb 1-1: New USB device found, idVendor=046d, idProduct=0a38, bcdDevice= 1.15\nusb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0\nusb 1-1: Product: Logitech USB Headset H340\nusb 1-1: Manufacturer: Logitech Inc.\n    ...\n</code></pre> <p>So if we go in <code>/sys/bus/usb/devices/1-1/</code>, we get the sysfs representation of this USB device:</p> picocomBBB - BusyBox<pre><code># cd /sys/bus/usb/devices/1-1/\n# cat idVendor idProduct busnum devnum product\n046d\n0a38\n1\n2\nLogitech USB Headset H340\n</code></pre> <p>However, while the USB device is detected, we currently do not have any driver for this device, so no actual sound card is detected.</p>"},{"location":"bbb/hardware/#in-tree-kernel-modules","title":"In-tree kernel modules","text":"<p>Go back to the kernel source directory.</p> <p>The Linux kernel has a generic driver supporting all USB audio devices supporting the standard USB audio class. This driver can be enabled using the <code>SND_USB_AUDIO</code> configuration option. Look for this parameter in the kernel configuration, and you should find that it is already enabled as a module.</p> <p>So, instead of compiling the corresponding driver as a built-in, that's a good opportunity to practice with kernel modules. So, compile your modules:</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ make modules\n</code></pre> <p>Then, following details given in the lectures, install the modules in our NFS root filesystem (<code>$HOME/embedded-linux-bbb-labs/tinysystem/nfsroot/</code>). Also make sure to update the kernel image (<code>make zImage</code>), and reboot the board.</p> <pre><code>$ export INSTALL_MOD_PATH=\"$LAB_PATH/../tinysystem/nfsroot\"\n$ make\n$ make modules_install\n    ...\n  INSTALL /home/me/embedded-linux-bbb-labs/hardware/../tinysystem/nfsroot/lib/modules/5.15.104/kernel/sound/usb/snd-usbmidi-lib.ko\n  DEPMOD  /home/me/embedded-linux-bbb-labs/hardware/../tinysystem/nfsroot/lib/modules/5.15.104\n$ cp arch/arm/boot/zImage /srv/tftp/zImage\n</code></pre> <p>If using git for the Linux kernel source tree, due to the changes we have made to the kernel source code, the kernel version is now <code>5.15.&lt;x&gt;-dirty</code>, the <code>dirty</code> keyword indicating that the git working tree has uncommitted changes. The modules are therefore installed in <code>/lib/modules/5.15.&lt;x&gt;-dirty/</code>, and the version of the running Linux kernel must match this.</p> <p>After rebooting, try to load the module that we need (<code>snd-usb-audio</code>). By running <code>lsmod</code>, see all the module dependencies that were loaded too.. You can also see that a new USB device driver in <code>/sys/bus/usb/drivers/snd-usb-audio</code>. This directory shows which USB devices are bound to this driver.</p> picocomBBB - BusyBox<pre><code># uname -r\n5.15.104-dirty\n# modprobe snd-usb-audio\nmc: Linux media interface: v0.10\nusbcore: registered new interface driver snd-usb-audio\n# lsmod\nModule                  Size  Used by\nsnd_usb_audio         217088  0\nsnd_hwdep              16384  1 snd_usb_audio\nsnd_usbmidi_lib        28672  1 snd_usb_audio\nmc                     36864  1 snd_usb_audio\nsnd_rawmidi            28672  1 snd_usbmidi_lib\nsnd_pcm               106496  1 snd_usb_audio\nsnd_timer              28672  1 snd_pcm\nsnd                    61440  6 snd_usb_audio,snd_hwdep,snd_usbmidi_lib,snd_rawmidi,snd_pcm,snd_timer\nsoundcore              16384  1 snd\n</code></pre> <p>You can check that <code>/proc/asound/</code> now exists (thanks to loading modules for ALSA, the Linux sound subsystem), and that one sound card is available:</p> picocomBBB - BusyBox<pre><code># ls -1 /proc/asound/\nH340\ncard0\ncards\ndevices\nhwdep\nmodules\noss\npcm\ntimers\nversion\n# cat /proc/asound/cards\n 0 [H340           ]: USB-Audio - Logitech USB Headset H340\n                      Logitech Inc. Logitech USB Headset H340 at usb-musb-hdrc.1-1, full speed\n</code></pre> <p>Check also the <code>/dev/snd/</code> directory, which should now contain some character device files. These will be used by the user-space libraries and applications to access the audio devices.</p> picocomBBB - BusyBox<pre><code># ls /dev/snd/\ncontrolC0  pcmC0D0c   pcmC0D0p   timer\n</code></pre> <p>Modify your startup scripts so that the <code>snd-usb-audio</code> module is always loaded at startup.</p> <pre><code>$ cd \"$LAB_PATH/../tinysystem/nfsroot/\"\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t devtmpfs dev /dev\n/usr/sbin/httpd -h /www/\nmodprobe snd-usb-audio\nEOF\n</code></pre> <p>We cannot test the sound card yet, as we will need to build some software first. Be patient, this is coming soon!</p>"},{"location":"bbb/hardware/#out-of-tree-kernel-modules","title":"Out-of-tree kernel modules","text":"<p>The next device we want to support is the I2C Nintendo Nunchuk. There is a driver in the kernel to support it when connected to a Wiimote controller, but there is no such driver to support it as an I2C device.</p> <p>Fortunately, one is provided in <code>$HOME/embedded-linux-bbb-labs/hardware/data/nunchuk/nunchuk.c</code>. You can check Bootlin's Linux kernel and driver development course to learn how to implement all sorts of device drivers for Linux.</p> <p>Go to this directory, and compile the out-of-tree module as follows:</p> <pre><code>$ cd \"$LAB_PATH/data/nunchuk/\"\n$ make -C \"$LAB_PATH/../kernel/linux\" M=$PWD\nmake: Entering directory '/home/me/embedded-linux-bbb-labs/kernel/linux'\n  CC [M]  /home/me/embedded-linux-bbb-labs/hardware/data/nunchuk/nunchuk.o\n  MODPOST /home/me/embedded-linux-bbb-labs/hardware/data/nunchuk/Module.symvers\n  CC [M]  /home/me/embedded-linux-bbb-labs/hardware/data/nunchuk/nunchuk.mod.o\n  LD [M]  /home/me/embedded-linux-bbb-labs/hardware/data/nunchuk/nunchuk.ko\nmake: Leaving directory '/home/me/embedded-linux-bbb-labs/kernel/linux'\n</code></pre> <p>Here are a few explanations:</p> <ul> <li> <p>The <code>-C</code> option lets make know which <code>Makefile</code> to use, here the toplevel <code>Makefile</code> in the kernel sources.</p> </li> <li> <p><code>M=$PWD</code> tells the kernel <code>Makefile</code> to build external modules from the files in the current directory.</p> </li> </ul> <p>Now, you can install the compiled module in the NFS root filesystem by passing the <code>modules_install</code> target and specifying the target directory through the <code>INSTALL_MOD_PATH</code> variable.</p> <pre><code>$ make -C \"$LAB_PATH/../kernel/linux\" M=$PWD modules_install\nmake: Entering directory '/home/me/embedded-linux-bbb-labs/kernel/linux'\n  INSTALL /home/me/embedded-linux-bbb-labs/hardware/../tinysystem/nfsroot/lib/modules/5.15.104/extra/nunchuk.ko\n  DEPMOD  /home/me/embedded-linux-bbb-labs/hardware/../tinysystem/nfsroot/lib/modules/5.15.104\nmake: Leaving directory '/home/me/embedded-linux-bbb-labs/kernel/linux'\n</code></pre> <p>You can see that this installs out-of-tree kernel modules under <code>lib/modules/&lt;version&gt;/extra/</code>.</p> <p>Back on the target, you can now check that your custom module can be loaded:</p> picocomBBB - BusyBox<pre><code># modprobe nunchuk\nnunchuk: loading out-of-tree module taints kernel.\n</code></pre> <p>See <code>kbuild/modules</code> in kernel documentation for details about building out-of-tree kernel modules.</p> <p>However, run <code>i2cdetect -r 1</code> again. You will see that the Nunchuk is still detected, but still not driven by the kernel. Otherwise, it would be signaled by the <code>UU</code> placeholder.</p> picocomBBB - BusyBox<pre><code># i2cdetect -y -r 1\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- -- --\n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- -- 52 -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --\n</code></pre> <p>You may also look at the <code>nunchuk.c</code> file and notice a Nunchuk device probed successfully message that you didn't see when loading the module.</p> <p>That's because the Linux kernel doesn't know about the Nunchuk device yet, even though the driver for this kind of devices is already loaded. Our device also has to be described in the Device Tree.</p> <p>You can confirm this by having a look at the contents of the <code>/sys/bus/i2c/</code> directory. It contains two subdirectories: <code>devices</code> and <code>drivers</code>. In <code>drivers</code>, there should be a <code>nunchuk</code> subdirectory, but no symbolic link to a device yet. In <code>devices</code> you should see some devices, but not the Nunchuk one yet.</p> picocomBBB - BusyBox<pre><code># ls -1 /sys/bus/i2c/\ndevices\ndrivers\ndrivers_autoprobe\ndrivers_probe\nuevent\n# ls -1 /sys/bus/i2c/drivers/\ndummy\nlp872x\nlp873x\nlp87565\nmenelaus\nnunchuk\npalmas\npcf857x\ntps65023\ntps65217\ntps65218\ntps65910\ntwl\ntwl6040\n# ls -1 /sys/bus/i2c/devices/\n0-0024\n0-0050\n0-0070\n2-0054\n2-0055\n2-0056\n2-0057\ni2c-0\ni2c-1\ni2c-2\n</code></pre>"},{"location":"bbb/hardware/#declaring-i2c-device","title":"Declaring I2C device","text":"<p>To allow the kernel to manage our Nunchuk device, let's declare the device in the custom Device Tree for our board. The declaration of the I2C1 bus will then look as follows:</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ nano arch/arm/boot/dts/am335x-boneblack-custom.dts\n</code></pre> arch/arm/boot/dts/am335x-boneblack-custom.dts - modified i2c1<pre><code>&amp;i2c1 {\npinctrl-names = \"default\";\npinctrl-0 = &lt;&amp;i2c1_pins&gt;;\nstatus = \"okay\";\nclock-frequency = &lt;50000&gt;;\nnunchuk: joystick@52 {\ncompatible = \"nintendo,nunchuk\";\nreg = &lt;0x52&gt;;\n};\n};\n</code></pre> <p>Here are a few notes:</p> <ul> <li> <p>The <code>clock-frequency</code> property is used to configure the bus to operate at 50 KHz.   Although the Nunchuk operates at 100 kHz, our prototyping wiring might degrade the signal, so we prefer to operate with a lower clock frequency.</p> </li> <li> <p>The Nunchuk device is added through a child node in the I2C controller node.</p> </li> <li> <p>For the kernel to probe and drive our device, it's required that the <code>compatible</code> string matches one of the compatible strings supported by the driver.</p> </li> <li> <p>The <code>reg</code> property is the address of the device on the I2C bus. If it doesn't match, the driver will probe the device but won't be able to communicate with it.</p> </li> </ul> <p>Recompile your Device Tree and reboot your kernel with the new binary.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ make dtbs\n  DTC     arch/arm/boot/dts/am335x-boneblack-custom.dtb\n$ cp arch/arm/boot/dts/am335x-boneblack-custom.dtb /srv/tftp/\n</code></pre> <p>You can now load your module again, and this time, you should see that the <code>nunchuk</code> driver probed the Nunchuk device:</p> picocomBBB - BusyBox<pre><code># modprobe -r nunchuk\n# modprobe nunchuk\nnunchuk: loading out-of-tree module taints kernel.\ninput: Wii Nunchuk as /devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1/1-0052/input/input0\nNunchuk device probed successfully\n</code></pre> <p>List the contents of <code>/sys/bus/i2c/drivers/nunchuk</code> once again. You should now see a symbolic link corresponding to our new device.</p> picocomBBB - BusyBox<pre><code># ls -l /sys/bus/i2c/drivers/nunchuk/\n--w-------    1      4096 Jan  1 00:17 bind\nlrwxrwxrwx    1         0 Jan  1 00:17 module -&gt; ../../../../module/nunchuk\n--w-------    1      4096 Jan  1 00:17 uevent\n--w-------    1      4096 Jan  1 00:17 unbind\n</code></pre> <p>Also list <code>/sys/bus/i2c/devices/</code> again. You should now see the Nunchuk device, which can be recognized through its <code>0052</code> address. Follow the symbolic link and you should see a symbolic link back to the Nunchuk driver!</p> picocomBBB - BusyBox<pre><code># ls -l /sys/bus/i2c/devices/\nlrwxrwxrwx    1         0 Jan  1 00:14 0-0024 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0024\nlrwxrwxrwx    1         0 Jan  1 00:14 0-0050 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0050\nlrwxrwxrwx    1         0 Jan  1 00:14 0-0070 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0070\nlrwxrwxrwx    1         0 Jan  1 00:14 1-0052 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1/1-0052\nlrwxrwxrwx    1         0 Jan  1 00:14 2-0054 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0054\nlrwxrwxrwx    1         0 Jan  1 00:14 2-0055 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0055\nlrwxrwxrwx    1         0 Jan  1 00:14 2-0056 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0056\nlrwxrwxrwx    1         0 Jan  1 00:14 2-0057 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0057\nlrwxrwxrwx    1         0 Jan  1 00:14 i2c-0 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0\nlrwxrwxrwx    1         0 Jan  1 00:00 i2c-1 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1\nlrwxrwxrwx    1         0 Jan  1 00:14 i2c-2 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2\n</code></pre> <p>We are not ready to use this input device yet, but at least we can test that we get bytes when buttons or the joypad are used. In the below command, use the same number as in the message you got in the console (<code>event0</code> for <code>input0</code> for example):</p> picocomBBB - BusyBox - Nunchuk Z pressed then released<pre><code># od -x /dev/input/event0\n0000000     02dd    0000    913f    0008    0001    0135    0001    0000\n0000020     02dd    0000    913f    0008    0000    0000    0000    0000\n0000040     02dd    0000    17bb    000a    0001    0135    0000    0000\n0000060     02dd    0000    17bb    000a    0000    0000    0000    0000\n</code></pre> <p>We will use the Nunchuk to control audio playback in an upcoming lab.</p>"},{"location":"bbb/hardware/#setting-board-model-name","title":"Setting board model name","text":"<p>Modify the custom Device Tree file one last time to override the model name for your system. Set the <code>model</code> property to <code>BeagleBone Black media player</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ grep \"model\" arch/arm/boot/dts/am335x-boneblack*.dts\narch/arm/boot/dts/am335x-boneblack.dts: model = \"TI AM335x BeagleBone Black\";\narch/arm/boot/dts/am335x-boneblack-wireless.dts:        model = \"TI AM335x BeagleBone Black Wireless\";\n$ less arch/arm/boot/dts/am335x-boneblack.dts\n    ...\n/ {\n        model = \"TI AM335x BeagleBone Black\";\n        compatible = \"ti,am335x-bone-black\", \"ti,am335x-bone\", \"ti,am33xx\";\n};\n    ...\n$ nano arch/arm/boot/dts/am335x-boneblack-custom.dts\n$ cat arch/arm/boot/dts/am335x-boneblack-custom.dts\n    ...\n/ {\n        model = \"BeagleBone Black media player\";\n};\n    ...\n$ make dtbs\n  DTC     arch/arm/boot/dts/am335x-boneblack-custom.dtb\n$ cp arch/arm/boot/dts/am335x-boneblack-custom.dtb /srv/tftp/\n</code></pre> <p>Recompile the device tree, and reboot the board with it. You should see the new model name in two different places:</p> <ul> <li> <p>In the first kernel messages on the serial console.</p> </li> <li> <p>In <code>/sys/firmware/devicetree/base/model</code>.   This can be handy for a distribution to identify the device it's running on.   By the way, you can explore <code>/sys/firmware/devicetree/</code> and find that every subdirectory corresponds to a DT node, and every file corresponds to a DT property.</p> </li> </ul> picocomBBB - BusyBox<pre><code># cat /sys/firmware/devicetree/base/model\nBeagleBone Black media player\n</code></pre>"},{"location":"bbb/hardware/#committing-kernel-tree-changes","title":"Committing kernel tree changes","text":"<p>Now that our changes to the kernel sources are over, create a branch for your changes and create a patch for them. Please don't skip this step as we need it for the next labs.</p> <p>First, if not done yet, you should set your identity and e-mail address in git:</p> <pre><code>$ git config --global user.email \"mail@example.com\"\n$ git config --global user.name \"User Name\"\n</code></pre> <p>This is necessary to create a commit with the <code>git commit -s</code> command, as required by the Linux kernel contribution guidelines.</p> <p>Let\u2019s create the branch and the patch now:</p> <pre><code>$ git status\nOn branch embedded-linux-bbb\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   arch/arm/boot/dts/Makefile\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        arch/arm/boot/dts/am335x-boneblack-custom.dts\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git add arch/arm/boot/dts/am335x-boneblack-custom.dts\n$ git commit -as -m \"Custom DTS for Bootlin lab\"\n[embedded-linux-bbb bb7e1269527c] Custom DTS for Bootlin lab\n 2 files changed, 28 insertions(+)\n create mode 100644 arch/arm/boot/dts/am335x-boneblack-custom.dts\n$ label=\"v5.15.104\"\n$ git tag \"$label-nunchuk\"\n</code></pre> <p>We can now create the patch with <code>git format-patch</code>. This should generate a <code>0001-Custom-DTS-for-Bootlin-lab.patch</code> file.</p> <pre><code>$ label=\"v5.15.104\"\n$ git format-patch $label\n0001-Custom-DTS-for-Bootlin-lab.patch\n$ cp \"0001-Custom-DTS-for-Bootlin-lab.patch\" $LAB_PATH\n</code></pre> <p>Creating the branch will impact the versions of the kernel and the modules. Compile your kernel and install your modules again and see the version changes through the new base directory for modules.</p> <p>To save space for the next lab, remove the old directory under <code>lib/modules/</code> containing the \u201ddirty\u201d modules.</p> <p>Don\u2019t forget to update the kernel your board boots.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ export INSTALL_MOD_PATH=\"$LAB_PATH/../tinysystem/nfsroot\"\n$ make\n$ make modules\n$ make modules_install\n$ cp arch/arm/boot/zImage /srv/tftp/zImage\n</code></pre> <pre><code>$ cd \"$LAB_PATH/../tinysystem/nfsroot/lib/modules/\"\n$ ls -1\n5.15.104-00001-gbb7e1269527c\n5.15.104-dirty\n$ rm -rf \"5.15.104-dirty/\"\n</code></pre> <pre><code>$ cd \"$LAB_PATH/data/nunchuk/\"\n$ make -C \"$LAB_PATH/../kernel/linux\" M=$PWD\n$ make -C \"$LAB_PATH/../kernel/linux\" M=$PWD modules_install\n</code></pre> <p>Reboot your board and make sure everything's alright!</p> picocomBBB - BusyBox<pre><code># uname -r\n5.15.104-00001-gbb7e1269527c\n# modprobe nunchuk\nnunchuk: loading out-of-tree module taints kernel.\ninput: Wii Nunchuk as /devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1/1-0052/input/input0\nNunchuk device probed successfully\n</code></pre>"},{"location":"bbb/hardware/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ cd \"$LAB_PATH/../tinysystem/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-hardware.cpio.xz\"\n$ cd /srv/tftp/\n$ tar cfJv \"$LAB_PATH/hardware-tftp.tar.xz\" zImage am335x-boneblack-custom.dtb\n</code></pre>"},{"location":"bbb/hardware/#git-bundle","title":"git bundle","text":"<p>To create a git bundle with just our patch (to have consistent git commit naming):</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ label=\"v5.15.104\"\n$ bundle=\"$LAB_PATH/kernel-linux-$label-nunchuk.bundle\"\n$ git bundle create $bundle $label..\n</code></pre> <p>To restore the git bundle:</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ label=\"v5.15.104\"\n$ bundle=\"$LAB_PATH/kernel-linux-$label-nunchuk.bundle\"\n$ git bundle verify $bundle\nThe bundle contains this ref:\nbb7e1269527c6b56c1c5b15b1b1a5c05a2f114f2 HEAD\nThe bundle requires this ref:\n115472395b0a9ea522ba0e106d6dfd7a73df8ba6\n/home/me/embedded-linux-bbb-labs/hardware/kernel-linux-v5.15.104-nunchuk.bundle is okay\n$ git checkout -b embedded-linux-bbb $label\n    ...\n$ git bundle list-heads $bundle\nbb7e1269527c6b56c1c5b15b1b1a5c05a2f114f2 HEAD\n$ git pull $bundle\n</code></pre>"},{"location":"bbb/hardware/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/integration/","title":"System integration","text":""},{"location":"bbb/integration/#objectives","title":"Objectives","text":"<ul> <li>Get familiar with the <code>systemd</code> init system.</li> </ul> <p>Compared to the previous lab, we go on increasing the complexity of the system, this time by using the systemd init system, and by taking advantage of it to add a few extra features, in particular ones that will be useful for debugging in the next lab.</p>"},{"location":"bbb/integration/#setup","title":"Setup","text":"<p>Since <code>systemd</code> requires the GNU C library, we are going to make a new Buildroot build in a new working directory, and using a different cross-compiling toolchain.</p> <p>So, create the <code>$HOME/embedded-linux-bbb-labs/integration/</code> directory and go inside of it.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/integration\"\n$ mkdir -p $LAB_PATH\n$ cd $LAB_PATH\n</code></pre> <p>Make a new clone of Buildroot from the existing local git repository, and checkout our <code>embedded-linux-bbb</code> branch:</p> <pre><code>$ git clone ../buildroot/buildroot/\n$ cd buildroot/\n$ git switch embedded-linux-bbb\n</code></pre>"},{"location":"bbb/integration/#root-filesystem-overlay","title":"Root filesystem overlay","text":"<p>Remove <code>etc/init.d/</code> from the root filesystem overlay, because it was for BusyBox, not systemd.</p> <pre><code>$ rm -rf board/bootlin/training/rootfs-overlay/etc/init.d/\n</code></pre>"},{"location":"bbb/integration/#buildroot-configuration","title":"Buildroot configuration","text":"<p>Let's make a new Buildroot configuration from scratch.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make distclean\n$ make menuconfig\n$ cp .config ../buildroot.config\n</code></pre> <p>In <code>Target options</code>:</p> <ul> <li> <p><code>Target Architecture</code> = <code>ARM (little endian)</code>.</p> </li> <li> <p><code>Target Architecture Variant</code> = <code>cortex-A8</code>.</p> </li> <li> <p><code>Target ABI</code> = <code>EABIhf</code>.</p> </li> <li> <p><code>Floating point strategy</code> = <code>VFPv3-D16</code>.</p> </li> </ul> <p>In <code>Toolchain</code>:</p> <ul> <li> <p><code>Toolchain type</code> = <code>External toolchain</code>.</p> </li> <li> <p><code>Toolchain</code> = <code>Bootlin toolchains</code>.   This time, we will use a Bootlin ready-made toolchain for <code>glibc</code>, as this is necessary for using systemd.</p> </li> <li> <p><code>Toolchain origin</code> = <code>Toolchain to be downloaded and installed</code>.</p> </li> <li> <p><code>Bootlin toolchain variant</code> = <code>armv7-eabihf glibc bleeding-edge 2021.11-1</code>.</p> </li> <li> <p>Enable <code>Copy gdb server to the Target</code>.</p> </li> </ul> <p>In <code>System configuration</code>:</p> <ul> <li> <p><code>Init system</code> = <code>systemd</code>.</p> </li> <li> <p><code>Root filesystem overlay directories</code> = <code>board/bootlin/training/rootfs-overlay</code>.</p> </li> </ul> <p>In <code>Kernel</code>:</p> <ul> <li> <p>Enable <code>Linux Kernel</code>.</p> </li> <li> <p><code>Kernel version</code> = <code>Latest version (5.15)</code>.</p> </li> <li> <p><code>Custom kernel patches</code> = <code>board/bootlin/training/0001-Custom-DTS-for-Bootlin-lab.patch</code>.</p> </li> <li> <p><code>Kernel configuration</code> = <code>Using a custom (def)config file</code>.</p> </li> <li> <p><code>Configuration file path</code> = <code>board/bootlin/training/linux.config</code>.</p> </li> <li> <p>Enable <code>Build a Device Tree Blob (DTB)</code>.</p> </li> <li> <p><code>In-tree Device Tree Source file names</code> = <code>am335x-boneblack-custom</code>.</p> </li> </ul> <p>In <code>Target packages</code>:</p> <ul> <li> <p><code>Audio and video applications</code>:</p> <ul> <li> <p>Enable <code>mpd</code>, and in the submenu:</p> <ul> <li>Keep only <code>alsa</code>, <code>vorbis</code>, and <code>tcp sockets</code>.</li> </ul> </li> <li> <p>Enable <code>mpd-mpc</code>.</p> </li> </ul> </li> <li> <p><code>Hardware handling</code>:</p> <ul> <li>Enable <code>nunchuk driver</code>.</li> </ul> </li> <li> <p><code>Networking applications</code>:</p> <ul> <li>Enable <code>dropbear</code>, a lightweight SSH server used instead of OpenSSH in most embedded devices.   Disable <code>client programs</code>, which are not needed.</li> </ul> </li> </ul> <p>In <code>Filesystem images</code>:</p> <ul> <li>Enable <code>tar the root filesystem</code>.</li> </ul>"},{"location":"bbb/integration/#build-and-test","title":"Build and test","text":"<p>Now build the full system.</p> <pre><code>$ make\n    ...\n</code></pre> <p>Once the build is over, generate the dependency graph again and find out the new dependencies introduced by using systemd.</p> <pre><code>$ make graph-depends\n    ...\n$ evince output/graphs/graph-depends.pdf\n$ cp output/graphs/graph-depends.pdf ../graph-depends.pdf\n</code></pre> <p></p> <p>To test the new system, create a new <code>nfsroot</code> directory, extract then new root filesystem into it, and boot your board on it through NFS.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ cp output/images/zImage /srv/tftp/\n$ mkdir -p \"$LAB_PATH/nfsroot/\"\n$ cd \"$LAB_PATH/nfsroot/\"\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n$ sudo rm -f /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/nfsroot/\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-bbb-labs/integration/nfsroot/'\n$ sudo chown -R tftp:tftp /srv/nfs\n$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre> <p>You should see the system booting through systemd, with all the systemd targets and system services starting one by one, with a total boot time which looks slower than before. That's because the system configuration is more complex, but also more versatile, being ready to run more complex services and applications.</p> <p>You can ask systemd to show you the various running services:</p> picocomBBB - systemd<pre><code># systemctl status\n\u25cf\n    State: degraded\n     Jobs: 0 queued\n   Failed: 1 units\n    Since: Thu 1970-01-01 00:00:13 UTC; 52 years 0 months ago\n   CGroup: /\n           \u251c\u2500init.scope\n           \u2502 \u2514\u25001 /sbin/init\n           \u2514\u2500system.slice\n             \u251c\u2500dbus.service\n             \u2502 \u2514\u2500165 /usr/bin/dbus-daemon --system --address=systemd: --no\n             \u251c\u2500dropbear.service\n             \u2502 \u2514\u2500171 /usr/sbin/dropbear -F -R\n             \u251c\u2500mpd.service\n             \u2502 \u2514\u2500167 /usr/bin/mpd --systemd\n             \u251c\u2500system-serial\\x2dgetty.slice\n             \u2502 \u2514\u2500serial-getty@ttyS0.service\n             \u2502   \u251c\u2500168 -sh\n             \u2502   \u251c\u2500185 systemctl status\n             \u2502   \u2514\u2500186 less\n             \u251c\u2500systemd-journald.service\n             \u2502 \u2514\u250092 /usr/lib/systemd/systemd-journald\n             \u251c\u2500systemd-networkd.service\n             \u2502 \u2514\u2500113 /usr/lib/systemd/systemd-networkd\n             \u251c\u2500systemd-resolved.service\n             \u2502 \u2514\u2500130 /usr/lib/systemd/systemd-resolved\n             \u251c\u2500systemd-timesyncd.service\n             \u2502 \u2514\u2500129 /usr/lib/systemd/systemd-timesyncd\n             \u2514\u2500systemd-udevd.service\n               \u2514\u2500104 /usr/lib/systemd/systemd-udevd\n~\nstandard input lines 10-30/30 (END)\n</code></pre> <p>You can also check all the mounted filesystems and be impressed:</p> <pre><code># mount\n192.168.0.15:/srv/nfs on / type nfs (rw,relatime,vers=3,rsize=4096,wsize=4096,namlen=255,hard,nolock,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=192.168.0.15,mountvers=3,mountproto=tcp,local_lock=all,addr=192.168.0.15)\ndevtmpfs on /dev type devtmpfs (rw,relatime,size=242424k,nr_inodes=60606,mode=755)\nproc on /proc type proc (rw,nosuid,nodev,noexec,relatime)\nsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)\ntmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)\ndevpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)\ntmpfs on /run type tmpfs (rw,nosuid,nodev,size=100452k,nr_inodes=819200,mode=755)\ncgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)\nmqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime)\ndebugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime)\ntracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime)\ntmpfs on /tmp type tmpfs (rw,nosuid,nodev,nr_inodes=1048576)\nconfigfs on /sys/kernel/config type configfs (rw,nosuid,nodev,noexec,relatime)\n</code></pre>"},{"location":"bbb/integration/#inspecting-the-system","title":"Inspecting the system","text":"<p>On the target, look at the contents of <code>/lib/systemd/</code>. You will see the implementation of most systemd targets and services.</p> picocomBBB - systemd<pre><code># ls -p /lib/systemd/\nlibsystemd-shared-250.so         systemd-pstore\nnetwork/                         systemd-remount-fs\nntp-units.d/                     systemd-reply-password\nresolv.conf                      systemd-resolved\nsystem/                          systemd-shutdown\nsystem-generators/               systemd-sleep\nsystem-preset/                   systemd-socket-proxyd\nsystem-shutdown/                 systemd-sulogin-shell\nsystem-sleep/                    systemd-sysctl\nsystemd                          systemd-time-wait-sync\nsystemd-ac-power                 systemd-timedated\nsystemd-boot-check-no-failures   systemd-timesyncd\nsystemd-cgroups-agent            systemd-udevd\nsystemd-fsck                     systemd-update-done\nsystemd-growfs                   systemd-update-helper\nsystemd-hostnamed                systemd-vconsole-setup\nsystemd-journald                 systemd-xdg-autostart-condition\nsystemd-makefs                   user/\nsystemd-modules-load             user-environment-generators/\nsystemd-network-generator        user-generators/\nsystemd-networkd                 user-preset/\nsystemd-networkd-wait-online\n</code></pre> <p>In particular, check out <code>/lib/systemd/user/</code>, containing some unnecessary targets in our case, such as <code>bluetooth.target</code>.</p> picocomBBB - systemd<pre><code># ls /lib/systemd/user/\napp.slice                       session.slice\nbackground.slice                shutdown.target\nbasic.target                    smartcard.target\nbluetooth.target                sockets.target\ndefault.target                  sound.target\nexit.target                     systemd-exit.service\ngraphical-session-pre.target    systemd-tmpfiles-clean.service\ngraphical-session.target        systemd-tmpfiles-clean.timer\nmpd.service                     systemd-tmpfiles-setup.service\nmpd.socket                      timers.target\npaths.target                    xdg-desktop-autostart.target\nprinter.target\n</code></pre> <p>However, check the <code>mpd.service</code> file for our MPD server. This should help you to realize all the options provided by systemd to start and control system services, while keeping the system secure, and their resources under control. You won't be able to match this level of control and security in a hand-made system.</p> File: /lib/systemd/user/mpd.service<pre><code>[Unit]\nDescription=Music Player Daemon\nDocumentation=man:mpd(1) man:mpd.conf(5)\nAfter=network.target sound.target\n[Service]\nType=notify\nExecStart=/usr/bin/mpd --systemd\n# Enable this setting to ask systemd to watch over MPD, see\n# systemd.service(5).  This is disabled by default because it causes\n# periodic wakeups which are unnecessary if MPD is not playing.\n#WatchdogSec=120\n# allow MPD to use real-time priority 40\nLimitRTPRIO=40\nLimitRTTIME=infinity\n# for io_uring\nLimitMEMLOCK=64M\n# disallow writing to /usr, /bin, /sbin, ...\nProtectSystem=yes\n# more paranoid security settings\nNoNewPrivileges=yes\nProtectKernelTunables=yes\nProtectControlGroups=yes\n# AF_NETLINK is required by libsmbclient, or it will exit() .. *sigh*\nRestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX AF_NETLINK\nRestrictNamespaces=yes\n# Note that \"ProtectKernelModules=yes\" is missing in the user unit\n# because systemd 232 is unable to reduce its own capabilities\n# (\"Failed at step CAPABILITIES spawning /usr/bin/mpd: Operation not\n# permitted\")\n[Install]\nWantedBy=default.target\n</code></pre>"},{"location":"bbb/integration/#automatic-module-loading","title":"Automatic module loading","text":"<p>Check the currently loaded modules on your system.</p> picocomBBB - systemd<pre><code># lsmod\nModule                  Size  Used by\ninput_leds             16384  0\nhid_generic            16384  0\nsnd_usb_audio         217088  0\nsnd_hwdep              16384  1 snd_usb_audio\nsnd_usbmidi_lib        28672  1 snd_usb_audio\nmc                     36864  1 snd_usb_audio\nsnd_rawmidi            28672  1 snd_usbmidi_lib\nusbhid                 32768  0\njoydev                 20480  0\nsnd_soc_hdmi_codec     16384  1\nsnd_soc_simple_card    16384  0\nsnd_soc_simple_card_utils    20480  1 snd_soc_simple_card\nomap_aes_driver        24576  0\npm33xx                 16384  0\nomap_crypto            16384  1 omap_aes_driver\nomap_sham              28672  0\nlibaes                 16384  1 omap_aes_driver\nti_emif_sram           16384  1 pm33xx\ncrypto_engine          16384  2 omap_aes_driver,omap_sham\nsnd_soc_davinci_mcasp    28672  2\nsnd_soc_ti_udma        16384  1 snd_soc_davinci_mcasp\nsnd_soc_ti_edma        16384  1 snd_soc_davinci_mcasp\nsnd_soc_ti_sdma        16384  1 snd_soc_davinci_mcasp\ntilcdc                 32768  0\nsnd_soc_core          172032  7 snd_soc_davinci_mcasp,snd_soc_hdmi_codec,snd_soc_simple_card_utils,snd_soc_ti_sdma,snd_soc_ti_edma,snd_soc_ti_udma,snd_soc_simple_card\nsnd_pcm_dmaengine      16384  1 snd_soc_core\nsnd_pcm               106496  5 snd_soc_davinci_mcasp,snd_usb_audio,snd_pcm_dmaengine,snd_soc_hdmi_codec,snd_soc_core\nsnd_timer              28672  1 snd_pcm\nsnd                    61440  8 snd_hwdep,snd_usb_audio,snd_soc_hdmi_codec,snd_timer,snd_rawmidi,snd_usbmidi_lib,snd_soc_core,snd_pcm\nsoundcore              16384  1 snd\nnunchuk                16384  0\nomap_mailbox           20480  1\ntda998x                28672  0\ndrm_kms_helper        192512  3 tda998x,tilcdc\ncfbfillrect            16384  1 drm_kms_helper\nsyscopyarea            16384  1 drm_kms_helper\nrtc_omap               20480  2 pm33xx\ncfbimgblt              16384  1 drm_kms_helper\nsysfillrect            16384  1 drm_kms_helper\nomap_wdt               16384  0\nsysimgblt              16384  1 drm_kms_helper\nfb_sys_fops            16384  1 drm_kms_helper\nwatchdog               20480  1 omap_wdt\nwkup_m3_ipc            16384  1 pm33xx\ncfbcopyarea            16384  1 drm_kms_helper\ntps65218_pwrbutton     16384  0\ndrm                   385024  4 tda998x,tilcdc,drm_kms_helper\ndrm_panel_orientation_quirks    16384  1 drm\nat24                   20480  0\nwkup_m3_rproc          16384  1\ncpufreq_dt             16384  0\nsha256_generic         16384  0\nlibsha256              16384  1 sha256_generic\nsha256_arm             24576  0\ncfg80211              643072  0\n</code></pre> <p>Surprise: both the Nunchuk and USB audio modules are already loaded. We didn't have anything to set up and systemd automatically load the modules associated to connected hardware. Let's find out why.</p> <p>On the target, go to <code>/lib/udev/rules.d/</code>. You will find all the standard rules for Udev, the part of systemd which handles hardware events, takes care of the permissions and ownership of device files, notifies other userspace programs, and among others, loads kernel modules.</p> picocomBBB - systemd<pre><code># ls /lib/udev/rules.d/\n50-udev-default.rules             64-btrfs.rules\n60-autosuspend.rules              70-camera.rules\n60-block.rules                    70-joystick.rules\n60-cdrom_id.rules                 70-memory.rules\n60-drm.rules                      70-mouse.rules\n60-evdev.rules                    70-touchpad.rules\n60-fido-id.rules                  75-net-description.rules\n60-input-id.rules                 75-probe_mtd.rules\n60-persistent-alsa.rules          78-sound-card.rules\n60-persistent-input.rules         80-drivers.rules\n60-persistent-storage-tape.rules  80-net-setup-link.rules\n60-persistent-storage.rules       81-net-dhcp.rules\n60-persistent-v4l.rules           90-vconsole.rules\n60-sensor.rules                   99-systemd.rules\n60-serial.rules                   README\n</code></pre> <p>Open <code>80-drivers.rules</code>, which is the rule allowing Udev to load kernel modules for detected devices. Its most important line defines <code>MODALIAS</code>:</p> File: /lib/udev/rules.d/80-drivers.rules<pre><code># do not edit this file, it will be overwritten on update\nACTION!=\"add\", GOTO=\"drivers_end\"\nENV{MODALIAS}==\"?*\", RUN{builtin}+=\"kmod load '$env{MODALIAS}'\"\nSUBSYSTEM==\"tifm\", ENV{TIFM_CARD_TYPE}==\"SD\", RUN{builtin}+=\"kmod load tifm_sd\"\nSUBSYSTEM==\"tifm\", ENV{TIFM_CARD_TYPE}==\"MS\", RUN{builtin}+=\"kmod load tifm_ms\"\nSUBSYSTEM==\"memstick\", RUN{builtin}+=\"kmod load ms_block mspro_block\"\nSUBSYSTEM==\"i2o\", RUN{builtin}+=\"kmod load i2o_block\"\nSUBSYSTEM==\"module\", KERNEL==\"parport_pc\", RUN{builtin}+=\"kmod load ppdev\"\nKERNEL==\"mtd*ro\", ENV{MTD_FTL}==\"smartmedia\", RUN{builtin}+=\"kmod load sm_ftl\"\nLABEL=\"drivers_end\"\n</code></pre> <p>This is when the <code>modules.alias</code> file comes into play. When a new device is found, the kernel passes a <code>MODALIAS</code> environment variable to Udev, containing which bus this happened on, and the attributes of the device on this bus. Thanks to the module aliases, the right module gets loaded. We already explained that in the lectures when talking about the output of <code>make modules_install</code>.</p> <p>Find where the <code>modules.alias</code> file is located, and you will find the two lines that allowed to load our <code>snd_usb_audio</code> and <code>nunchuk</code> modules:</p> picocomBBB - systemd<pre><code># modules_alias_path=$(find / -name modules.alias)\n# echo $modules_alias_path\n/usr/lib/modules/5.15.26/modules.alias\n# cat $modules_alias_path | grep snd_usb_audio\n    ...\nalias usb:v*p*d*dc*dsc*dp*ic01isc01ip*in* snd_usb_audio\nalias usb:v046Dp0A38d*dc*dsc*dp*ic*isc*ip*in* snd_usb_audio\n    ...\n# cat $modules_alias_path | grep nunchuk\nalias of:N*T*Cnintendo,nunchukC* nunchuk\nalias of:N*T*Cnintendo,nunchuk nunchuk\n</code></pre> <p>For <code>snd_usb_audio</code>, there are many possible matching values, so it isn't straighforward to be sure which matched your particular device.</p> <p>However, you can find in sysfs which <code>MODALIAS</code> was emitted for your device:</p> picocomBBB - systemd<pre><code># cd /sys/class/sound/card0/device/\n# ls -la\ntotal 0\ndrwxr-xr-x    4 root     root             0 Jan 18  2022 .\ndrwxr-xr-x    8 root     root             0 Jan 18  2022 ..\n-rw-r--r--    1 root     root          4096 May  6 11:15 authorized\n-r--r--r--    1 root     root          4096 May  6 11:15 bAlternateSetting\n-r--r--r--    1 root     root          4096 May  6 11:15 bInterfaceClass\n-r--r--r--    1 root     root          4096 May  6 11:15 bInterfaceNumber\n-r--r--r--    1 root     root          4096 May  6 11:15 bInterfaceProtocol\n-r--r--r--    1 root     root          4096 May  6 11:15 bInterfaceSubClass\n-r--r--r--    1 root     root          4096 May  6 11:15 bNumEndpoints\nlrwxrwxrwx    1 root     root             0 May  6 11:15 driver -&gt; ../../../../../../../../../bus/usb/drivers/snd-usb-audio\n-r--r--r--    1 root     root          4096 May  6 11:15 modalias\ndrwxr-xr-x    2 root     root             0 May  6 11:15 power\ndrwxr-xr-x    3 root     root             0 May  6 11:15 sound\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 subsystem -&gt; ../../../../../../../../../bus/usb\n-r--r--r--    1 root     root          4096 May  6 11:15 supports_autosuspend\n-rw-r--r--    1 root     root          4096 Jan 18  2022 uevent\n# cat modalias\nusb:v046Dp0A38d0115dc00dsc00dp00ic01isc01ip00in00\n</code></pre> <p>With a bit of patience, you could find the matching line within the <code>modules.alias</code> file.</p> <p>If you want to see the information sent to Udev by the kernel when a new device is plugged in, here are a few debugging commands.</p> <p>First unplug your device and run <code>udevadm monitor</code>. Then plug in your headset again. You will find all the events emitted by the kernel, and with the same string (with <code>UDEV</code> instead of <code>KERNEL</code>), the time when Udev finished processing each event.</p> picocomBBB - systemd<pre><code># udevadm monitor\nmonitor will print the received events for:\nUDEV - the event which udev sends out after rule processing\nKERNEL - the kernel uevent\n[ 1602.288834] usb 1-1: new full-speed USB device number 5 using musb-hdrc\n[ 1602.670092] usb 1-1: New USB device found, idVendor=046d, idProduct=0a38, bcdDevice= 1.15\n[ 1602.678406] usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0\n[ 1602.685741] usb 1-1: Product: Logitech USB Headset H340\n[ 1602.691101] usb 1-1: Manufacturer: Logitech Inc.\nKERNEL[1602.716705] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1 (usb)\nKERNEL[1602.722002] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0 (usb)\nKERNEL[1602.849792] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0 (sound)\nKERNEL[1602.853994] add      /devices/platform/ocp/4740[ 1602.870857] PM: Cannot get wkup_m3_ipc handle\n0000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0/pcmC0D0p (sound)\nKERNEL[1602.858805] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0/pcmC0D0c (sound)\nKERNEL[1602.872313] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0/controlC0 (sound)\nKERNEL[1602.873192] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0 (usb)\nKERNEL[1602.873919] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.1 (usb)\nKERNEL[1602.874634] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.1 (usb)\nKERNEL[1602.875370] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.2 (usb)\nKERNEL[1602.876096] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.2 (usb)\nKERNEL[1602.876771] add  [ 1602.964976] input: Logitech Inc. Logitech USB Headset H340 Consumer Control as /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input7\n    /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3 (usb)\nKERNEL[1602.949111] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004 (hid)\nKERNEL[1602.980402] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input7 (input)\n[ 1603.049480] input: Logitech Inc. Logitech USB Headset H340 as /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8\nKERNEL[1603.057724] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A[ 1603.076705] hid-generic 0003:046D:0A38.0004: input,hiddev96: USB HID v1.11 Device [Logitech Inc. Logitech USB Headset H340] on usb-musb-hdrc.1-1/input3\n38.0004/input/input7/event1 (input)\nKERNEL[1603.058370] add    [ 1603.094087] PM: Cannot get wkup_m3_ipc handle\n  /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8 (input)\nKERNEL[1603.063218] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8/event2 (input)\nKERNEL[1603.063593] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8/input8::mute (leds)\nKERNEL[1603.063797] add      /class/usbmisc (class)\nKERNEL[1603.083788] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/usbmisc/hiddev0 (usbmisc)\nKERNEL[1603.084236] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004 (hid)\nKERNEL[1603.084543] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3 (usb)\nKERNEL[1603.084907] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1 (usb)\nUDEV  [1603.110810] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1 (usb)\nUDEV  [1603.118580] add      /class/usbmisc (class)\nUDEV  [1603.129548] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0 (usb)\nUDEV  [1603.163585] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0 (sound)\nUDEV  [1603.177859] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0/pcmC0D0c (sound)\nUDEV  [1603.183681] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0/pcmC0D0p (sound)\nUDEV  [1603.195790] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.2 (usb)\nUDEV  [1603.203962] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.1 (usb)\nUDEV  [1603.218135] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.1 (usb)\nUDEV  [1603.221134] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3 (usb)\nUDEV  [1603.227523] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004 (hid)\nUDEV  [1603.236292] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.2 (usb)\nUDEV  [1603.251374] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/usbmisc/hiddev0 (usbmisc)\nKERNEL[1603.267946] change   /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0 (sound)\nUDEV  [1603.293198] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8 (input)\nUDEV  [1603.300618] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input7 (input)\nUDEV  [1603.301505] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0/controlC0 (sound)\nUDEV  [1603.317818] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0 (usb)\nUDEV  [1603.332349] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8/input8::mute (leds)\nUDEV  [1603.387225] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input7/event1 (input)\nUDEV  [1603.396360] add      /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004/input/input8/event2 (input)\nUDEV  [1603.396747] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3/0003:046D:0A38.0004 (hid)\nUDEV  [1603.407306] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.3 (usb)\nUDEV  [1603.417180] bind     /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1 (usb)\nUDEV  [1603.427970] change   /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0 (sound)\n</code></pre> <p>You can also see the <code>MODALIAS</code> values carried by these events:</p> picocomBBB - systemd<pre><code># udevadm monitor --env\n    ...\nUDEV  [1763.405675] change   /devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0 (sound)\nACTION=change\nDEVPATH=/devices/platform/ocp/47400000.target-module/47401c00.usb/musb-hdrc.1/usb1/1-1/1-1:1.0/sound/card0\nSUBSYSTEM=sound\nSYNTH_UUID=0\nSEQNUM=2433\nUSEC_INITIALIZED=1761986039\nSOUND_INITIALIZED=1\nID_VENDOR=Logitech_Inc.\nID_VENDOR_ENC=Logitech\\x20Inc.\nID_VENDOR_ID=046d\nID_MODEL=Logitech_USB_Headset_H340\nID_MODEL_ENC=Logitech\\x20USB\\x20Headset\\x20H340\nID_MODEL_ID=0a38\nID_REVISION=0115\nID_SERIAL=Logitech_Inc._Logitech_USB_Headset_H340\nID_TYPE=audio\nID_BUS=usb\nID_USB_INTERFACES=:010100:010200:030000:\nID_USB_INTERFACE_NUM=00\nID_USB_DRIVER=snd-usb-audio\nID_ID=usb-Logitech_Inc._Logitech_USB_Headset_H340-00\nID_PATH=platform-musb-hdrc.1-usb-0:1:1.0\nID_PATH_TAG=platform-musb-hdrc_1-usb-0_1_1_0\nSOUND_FORM_FACTOR=headset\n</code></pre> <p>As far as the Nunchuk is concerned, we cannot easily remove it from the Device Tree and add it back, but it's easier to find its <code>MODALIAS</code> value:</p> picocomBBB - systemd<pre><code># cd /sys/bus/i2c/devices/\n# ls -la\ntotal 0\ndrwxr-xr-x    2 root     root             0 Jan 18  2022 .\ndrwxr-xr-x    4 root     root             0 Jan 18  2022 ..\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 0-0024 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0024\nlrwxrwxrwx    1 root     root             0 May  6 11:18 0-0034 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0034\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 0-0050 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0050\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 0-0070 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0/0-0070\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 1-0052 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1/1-0052\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 2-0054 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0054\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 2-0055 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0055\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 2-0056 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0056\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 2-0057 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2/2-0057\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 i2c-0 -&gt; ../../../devices/platform/ocp/44c00000.interconnect/44c00000.interconnect:segment@200000/44e0b000.target-module/44e0b000.i2c/i2c-0\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 i2c-1 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@0/4802a000.target-module/4802a000.i2c/i2c-1\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 i2c-2 -&gt; ../../../devices/platform/ocp/48000000.interconnect/48000000.interconnect:segment@100000/4819c000.target-module/4819c000.i2c/i2c-2\n</code></pre> <p>Here you will recognize our Nunchuk device through its <code>0x52</code> address.</p> picocomBBB - systemd<pre><code># cd \"1-0052/\"\n# ls -la\ntotal 0\ndrwxr-xr-x    4 root     root             0 Jan 18  2022 .\ndrwxr-xr-x    5 root     root             0 Jan 18  2022 ..\nlrwxrwxrwx    1 root     root             0 May  6 11:15 driver -&gt; ../../../../../../../../../bus/i2c/drivers/nunchuk\ndrwxr-xr-x    3 root     root             0 May  6 11:15 input\n-r--r--r--    1 root     root          4096 May  6 11:19 modalias\n-r--r--r--    1 root     root          4096 Jan  1  2000 name\nlrwxrwxrwx    1 root     root             0 May  6 11:19 of_node -&gt; ../../../../../../../../../firmware/devicetree/base/ocp/interconnect@48000000/segment@0/target-module@2a000/i2c@0/joystick@52\ndrwxr-xr-x    2 root     root             0 May  6 11:19 power\nlrwxrwxrwx    1 root     root             0 Jan 18  2022 subsystem -&gt; ../../../../../../../../../bus/i2c\n-rw-r--r--    1 root     root          4096 Jan 18  2022 uevent\n# cat modalias\nof:NjoystickT(null)Cnintendo,nunchuk\n</code></pre> <p>Here the bus is <code>of</code>, meaning Open Firmware, which was the former name of the Device Tree. When an event was emitted by the kernel with this <code>MODALIAS</code> string, the <code>nunchuk</code> module got loaded by Udev thanks to the matching alias.</p> <p>This actually happened when systemd ran the coldplugging operation: at system startup, it asked the kernel to emit hotplug events for devices already present when the system booted:</p> <pre><code>[ OK ] Finished Coldplug All udev Devices.\n</code></pre> <p>On non-x86 platforms, that's typically for devices described in the Device Tree. This way, both static and hotplugged devices can be handled in the same way, using the same Udev rules.</p>"},{"location":"bbb/integration/#testing","title":"Testing","text":"<p>Make sure that audio playback still works on your system:</p> picocomBBB - systemd<pre><code># mpc update\nUpdating DB (#1) ...\nvolume:100%   repeat: off   random: off   single: off   consume: off\n# mpc add /\n# mpc play\n1-sample.ogg\n[playing] #1/7   0:00/0:19 (0%)\nvolume:100%   repeat: off   random: off   single: off   consume: off\n# mpc stop\nvolume:100%   repeat: off   random: off   single: off   consume: off\n</code></pre> <p>If it doesn't, look at the systemd logs in your serial console history (<code>dmesg</code>). systemd should let you know about the failing services and the commands to run to get more details.</p>"},{"location":"bbb/integration/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ cd \"$LAB_PATH/buildroot/output/images/\"\n$ tar cfJv \"$LAB_PATH/integration-images.tar.xz\" *\n</code></pre>"},{"location":"bbb/integration/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/kernel/","title":"Linux Kernel","text":""},{"location":"bbb/kernel/#objectives","title":"Objectives","text":"<ul> <li> <p>Get the kernel sources from git, using the official Linux source tree.</p> </li> <li> <p>Fetch the sources for the stable Linux releases, by declaring a remote tree and getting stable branches from it.</p> </li> <li> <p>Set up a cross-compiling environment.</p> </li> <li> <p>Cross compile the kernel for the BeagleBone Black board (ARM Cortex-A8).</p> </li> <li> <p>Use U-Boot to download the kernel to the target board.</p> </li> <li> <p>Check that the custom kernel starts the system.</p> </li> </ul>"},{"location":"bbb/kernel/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages: those from the previous labs.</p> </li> <li> <p>Linux kernel, either as:</p> <ul> <li> <p>Linus Torvalds' git repository tag <code>5.15</code></p> </li> <li> <p>Source code archive for bleeding-edge release <code>5.15</code></p> </li> <li> <p>Stable git repository tag <code>5.15.104</code></p> </li> <li> <p>Source code archive for stable release <code>5.15.104</code></p> </li> </ul> </li> </ul>"},{"location":"bbb/kernel/#main-repository","title":"Main repository","text":"<p>Let's first create the <code>kernel</code> folder under or lab folder:</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/kernel\"\n$ mkdir -p $LAB_PATH\n$ cd $LAB_PATH\n</code></pre> <p>To begin working with the Linux kernel sources, we need to clone its reference git tree, the one managed by Linus Torvalds himself.</p> <p>This requires downloading some gigabytes of data. If you have a very fast access to the Internet, you can do it directly by connecting to the official git repository (our main remote repository):</p> <pre><code>$ git clone \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux/\"\n$ cd linux\n</code></pre> <p>If your internet access is not fast enough, you can download a git snapshot of a specific version; for example, release <code>5.15</code>. You just have to extract this archive in the current <code>kernel</code> directory, just like we did for the previous labs:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"5.15\"\n$ wget \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-${label}.tar.gz\"\n$ tar xfv \"linux-${label}.tar.gz\"\n$ mv linux*/ linux\n$ cd linux\n</code></pre>"},{"location":"bbb/kernel/#stable-releases","title":"Stable releases","text":"<p>The Linux kernel repository from Linus Torvalds contains all the main releases of Linux, but not the stable releases: they are maintained by a separate team, and hosted in a separate repository.</p> <p>After having downloaded the main repository, we have to add this separate <code>stable</code> repository as additional remote to be able to use the stable releases.</p> <pre><code>$ cd $LAB_PATH/linux\n$ git remote add stable \"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux/\"\n$ git fetch stable\n$ git branch -a\n</code></pre> <p>We're going to checkout the stable branch for version <code>5.15.y</code>, aliased as a branch named after our labs; alternatively, we can choose the specific version <code>5.15.104</code>:</p> <pre><code>$ label=\"linux-5.15.y\"  # for the ongoing branch\n$ label=\"v5.15.104\"     # for our specific version\n$ git checkout -b embedded-linux-bbb \"stable/${label}\"\n</code></pre> <p>Again, if you internet speed is slow, or you want to save space, you can download a specific release archive directly. You can find the list by browsing the repository webpage; we tested this lab with version <code>5.15.104</code>, an LTS branch. Of course, this is an alternative to the main releases, so make sure that one wasn't extracted into our <code>linux</code> subfolder.</p> <pre><code>$ cd $LAB_PATH\n$ rm -rf linux/\n$ label=\"5.15.104\"\n$ wget \"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-${label}.tar.gz\"\n$ tar xfv \"linux-${label}.tar.gz\"\n$ mv linux*/ linux\n$ cd linux\n</code></pre>"},{"location":"bbb/kernel/#version-check","title":"Version check","text":"<p>First, execute the following command to check which version you currently have:</p> <pre><code>$ make kernelversion\n5.15.104\n</code></pre> <p>You can also open the <code>Makefile</code> and look at the first lines to find this information:</p> <pre><code>$ head -n6 Makefile | tail -n+2\nVERSION = 5\nPATCHLEVEL = 15\nSUBLEVEL = 104\nEXTRAVERSION =\nNAME = Trick or Treat\n</code></pre>"},{"location":"bbb/kernel/#configuration","title":"Configuration","text":"<p>To cross-compile Linux, you need to have a cross-compiling toolchain. We will use the cross-compiling toolchain that we previously produced, so we just need to add it to the <code>PATH</code>. We also need the <code>CROSS_COMPILE</code> prefix, and the <code>ARCH</code> label of the CPU architecture. You'd better parallelize with the <code>-j</code> option to save time. Quick reminder:</p> <pre><code>$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export ARCH=arm\n$ export MAKEFLAGS=-j$(nproc)\n</code></pre> <p>By running <code>make help</code>, look for the proper <code>Makefile</code> target to configure the kernel for your processor (within <code>less</code>, press the <code>[Q]</code> key to quit). In our case, look for a configuration for boards in the OMAP2 and later family, which the AM335x of the BeagleBone belongs to: <code>omap2plus_defconfig</code>. So, apply this configuration, and then run <code>make menuconfig</code>.</p> <pre><code>$ make help | grep omap2\n  omap2plus_defconfig         - Build for omap2plus\n$ make omap2plus_defconfig\n$ make menuconfig\n</code></pre> <p>See: <code>menuconfig</code></p> <ul> <li> <p>Set <code>GCC_PLUGINS=n</code> (disabled), which skips building special GCC plugins we don't need, requiring extra dependencies for the build.</p> </li> <li> <p>Add options to support USB host and networking over USB device:</p> <ul> <li> <p>Set <code>USB=y</code> (static), i.e. search for it (/), and press Y to switch from module to static.</p> </li> <li> <p>Set <code>USB_GADGET=y</code>.</p> </li> <li> <p>Set <code>USB_MUSB_HDRC=y</code>, the driver for the USB OTG controller.</p> </li> <li> <p>Set <code>USB_MUSB_DSPS=y</code>.</p> </li> <li> <p>Set <code>USB_MUSB_DUAL_ROLE=y</code> (via choice menu) to use the USB OTG both in host and device (gadget) modes.   This will be needed to use the board's USB host port.</p> </li> <li> <p>Check the dependencies of <code>AM335X_PHY_USB</code> and find the way to set <code>AM335X_PHY_USB=y</code>.</p> <ul> <li> <p>Use the search tool of <code>menuconfig</code> against <code>AM335X_PHY_USB</code>.</p> </li> <li> <p>You can see that it depends on: <code>USB_SUPPORT [=y] &amp;&amp; (ARM [=y] || COMPILE_TEST [=n]) &amp;&amp; NOP_USB_XCEIV [=m]</code>.   We're missing <code>NOP_USB_XCEIV</code>, because it's compiled as module right now, so we cannot have <code>AM335X_PHY_USB=y</code>.</p> </li> <li> <p>Search for and set <code>NOP_USB_XCEIV=y</code>.</p> </li> <li> <p>Search again <code>AM335X_PHY_USB</code> to confirm the dependency is now resolved.</p> </li> <li> <p>Set <code>AM335X_PHY_USB=y</code> and confirm the dependency chain is all static.</p> </li> </ul> </li> <li> <p>Set <code>USB_ETH=y</code>.</p> </li> <li> <p>Set <code>USB_ETH_RNDIS=y</code>.</p> </li> <li> <p>Set <code>INPUT_EVDEV=y</code>, to have the same default setting as in our labs with the STM32MP1 boards.</p> </li> </ul> </li> <li> <p>Add static support (instead of module) for the hardware random generator.   Without it, you would get annoying messages and lower performance.</p> <ul> <li>Set <code>CONFIG_HW_RANDOM=y</code>.</li> <li>Set <code>CONFIG_HW_RANDOM_OMAP=y</code>.</li> <li>Set <code>CONFIG_HW_RANDOM_OMAP3=y</code>.</li> </ul> </li> </ul> <p>Now you can <code>&lt;Save&gt;</code> and backup:</p> <pre><code>$ cp .config ../kernel.config\n</code></pre>"},{"location":"bbb/kernel/#cross-compiling","title":"Cross compiling","text":"<p>You\u2019re now ready to cross-compile your kernel. Simply run <code>make</code> and wait for the kernel to be compiled. The build takes some time to perform \u2014 a clean build took around 10 minutes on an Intel i7 7700 laptop with 4 cores, of course within the Lubuntu VM.</p> <pre><code>$ make\n    ...\n  Kernel: arch/arm/boot/zImage is ready\n</code></pre> <p>Look at the end of the kernel build output to see which file contains the kernel image. You can also see the Device Tree <code>.dtb</code> files which got compiled. Find which <code>.dtb</code> file corresponds to your board. TODO</p> <pre><code>$ find . -name \"am335x-bone*.dtb\"\n./arch/arm/boot/dts/am335x-boneblue.dtb\n./arch/arm/boot/dts/am335x-bonegreen-wireless.dtb\n./arch/arm/boot/dts/am335x-bonegreen.dtb\n./arch/arm/boot/dts/am335x-bone.dtb\n./arch/arm/boot/dts/am335x-boneblack.dtb\n./arch/arm/boot/dts/am335x-boneblack-wireless.dtb\n</code></pre>"},{"location":"bbb/kernel/#bootloader","title":"Bootloader","text":"<p>As we are going to boot the Linux kernel from our U-Boot installation, we need to set the <code>bootargs</code> environment variable according to the Linux kernel command line.</p> <p>Let's connect <code>picocomBBB</code> and run our U-Boot on the board. Press any key as soon as the board boots, to stop U-Boot and enter its prompt.</p> <p>A separate shell is suggested for <code>picocomBBB</code> instances from now on.</p> picocomBBB - U-Boot<pre><code>$ picocomBBB\n    ...\nTerminal ready\n    ...\nHit any key to stop autoboot:  0\n=&gt;\n</code></pre> <p>Enter the prompt (press a key before the timeout) and set the <code>bootargs</code> environment variable:</p> picocomBBB - U-Boot<pre><code>=&gt; setenv bootargs console=ttyS0,115200n8\n=&gt; saveenv\n</code></pre> <p>We use TFTP to load the kernel image on the board:</p> <p>On your workstation, copy the <code>zImage</code> and DTB (<code>am335x-boneblack.dtb</code>) to the directory exposed by the TFTP server (<code>/srv/tftp/</code>).</p> <pre><code>$ cd \"$LAB_PATH/linux/\"\n$ cp \"arch/$ARCH/boot/zImage\" /srv/tftp/\n$ cp \"arch/$ARCH/boot/dts/am335x-boneblack.dtb\" /srv/tftp/\n</code></pre> <p>On the target (within the U-Boot prompt, accessed by pressing a key before the initial timeout), load <code>zImage</code> from TFTP into RAM, as well as the DTB, and let the kerbel boot rom RAM with its device tree. You should see Linux boot and finally panicking. This is expected: we haven\u2019t provided a working root filesystem for our device yet!</p> picocomBBB - U-Boot<pre><code>=&gt; tftp 0x81000000 zImage\n    ...\n=&gt; tftp 0x82000000 am335x-boneblack.dtb\n    ...\n=&gt; bootz 0x81000000 - 0x82000000\n    ...\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\n</code></pre> <p>You can now automate all of this every time the board is booted or reset. Reset the board (<code>S1</code> button), enter U-Boot prompt, and set the <code>bootcmd</code> environment variable, chaining the previous commands in sequence in a long line.</p> picocomBBB - U-Boot<pre><code>=&gt; setenv bootcmd_tftp \"tftp 0x81000000 zImage;  tftp 0x82000000 am335x-boneblack.dtb;  bootz 0x81000000 - 0x82000000\"\n=&gt; setenv bootcmd $bootcmd_tftp\n=&gt; saveenv\n</code></pre> <p>Restart the board again to make sure that booting the kernel is now automated.</p> picocomBBB - U-Boot<pre><code>=&gt; reset\n    ...\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\n</code></pre> <p>You can now disconnect and turn off the board.</p>"},{"location":"bbb/kernel/#backup-and-restore","title":"Backup and restore","text":"<p>This isn't really required now, because we're going to recompile the kernel and adapt the U-Boot configuration again. Anyway, in case you need them, you can backup a snapshot of the images up to this point.</p> <pre><code>$ cd /srv/tftp/\n$ tar cfJv \"$LAB_PATH/kernel-tftp.tar.xz\" zImage am335x-boneblack.dtb\n</code></pre> <p>To restore the content:</p> <pre><code>$ sudo mkdir -p /srv/tftp/\n$ sudo chown tftp:tftp /srv/tftp\n$ cd /srv/tftp/\n$ tar xfv \"$LAB_PATH/kernel-tftp.tar.xz\"\n</code></pre>"},{"location":"bbb/kernel/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/thirdparty/","title":"Third-party libraries and apps","text":""},{"location":"bbb/thirdparty/#objectives","title":"Objectives","text":"<ul> <li>Learn how to leverage existing libraries and applications: how to configure, compile and install them.</li> </ul> <p>To illustrate how to use existing libraries and applications, we will extend the small root filesystem built in the BusyBox lab to add the ALSA libraries and tools to run basic sound support tests, and the libgpiod library and executables to manage GPIOs. ALSA stands for Advanced Linux Sound Architecture, and it's the Linux audio subsystem.</p> <p>We'll see that manually re-using existing libraries is quite tedious, so that more automated procedures are necessary to make it easier. However, learning how to perform these operations manually will significantly help you when you face issues with more automated tools.</p>"},{"location":"bbb/thirdparty/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>autoconf-archive</code> <code>meson</code> <code>pkg-config</code></p> </li> <li> <p>alsa-lib</p> <ul> <li>Archived source code release <code>1.2.7.1</code></li> </ul> </li> <li> <p>alsa-utils</p> <ul> <li>Archived source code release <code>1.2.6</code></li> </ul> </li> <li> <p>libgpiod, either as:</p> <ul> <li> <p>git repository</p> </li> <li> <p>Source code archive for commit <code>7311e1d5</code> (after release <code>1.6.3</code>)</p> </li> </ul> </li> <li> <p>ipcalc</p> <ul> <li>Archived source code release <code>1.0.1</code></li> </ul> </li> </ul>"},{"location":"bbb/thirdparty/#figuring-out-library-dependencies","title":"Figuring out library dependencies","text":"<p>We're going to integrate the <code>alsa-utils</code>, <code>libgpiod</code> and <code>ipcalc</code> executables. In our case, the dependency chain for <code>alsa-utils</code> is quite simple: it only depends on the <code>alsa-lib</code> library. Instead, <code>libgpiod</code> and <code>ipcalc</code> are standalone and thus don't have any dependencies.</p> <p>Of course, all these libraries rely on the C library, which is not mentioned here, because it is already part of the root filesystem built in the BusyBox lab. You might wonder how to figure out this dependency tree by yourself. Basically, there are several ways, that can be combined:</p> <ul> <li>Read the library documentation, which often mentions the dependencies.</li> <li>Read the help message of the configure script (by running <code>./configure --help</code>).</li> <li>By running the configure script, compiling and looking at the errors.</li> </ul> <p>To configure, compile and install all the components of our system, we're going to start from the bottom of the tree with <code>alsa-lib</code>, then continue with <code>alsa-utils</code>. Then, we will also build <code>libgpiod</code> and <code>ipcalc</code>.</p>"},{"location":"bbb/thirdparty/#preparation","title":"Preparation","text":"<p>For our cross-compilation work, we will need two separate spaces:</p> <ul> <li> <p>A staging space in which we will directly install all the packages: non-stripped versions of the libraries, headers, documentation and other files needed for the compilation. This staging space can be quite big, but will not be used on our target, only for compiling libraries or applications;</p> </li> <li> <p>A target space, in which we will only copy the required files from the staging space: binaries and libraries, after stripping, configuration files needed at runtime, etc. This target space will take a lot less space than the staging space, and it will contain only the files that are really needed to make the system work on the target.</p> </li> </ul> <p>To sum up, the staging space will contain everything that's needed for compilation, while the target space will contain only what's needed for execution.</p> <p>Create the <code>$HOME/embedded-linux-bbb-labs/thirdparty/</code> directory, and inside create two directories: <code>staging</code> and <code>target</code>.</p> <p>For the target, we need a basic system with BusyBox and initialization scripts. We're going to re-use the system built in the BusyBox lab, so copy this system in the <code>target</code> directory.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/thirdparty\"\n$ mkdir -p \"$LAB_PATH/target/\"\n$ mkdir -p \"$LAB_PATH/staging/\"\n$ cd $LAB_PATH\n$ cp -arv ../tinysystem/nfsroot/* target/\n    ...\n</code></pre>"},{"location":"bbb/thirdparty/#testing","title":"Testing","text":"<p>Make sure the <code>target/</code> directory is exported by your NFS server to your board by modifying <code>/etc/exports</code> and restarting your NFS server. You can of course change our previous <code>/srv/nfs/</code> symlink to point to this directory. Make your board boot from this new directory through NFS.</p> <pre><code>$ sudo rm -f /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/target/\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-bbb-labs/thirdparty/target/'\n$ sudo chown -R tftp:tftp /srv/nfs\n$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre> <p>Revert U-Boot to use TFTP and NFS:</p> picocomBBB - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootcmd $bootcmd_tftp\n=&gt; setenv bootargs $bootargs_nfs\n=&gt; saveenv\n=&gt; reset\n    ...\n</code></pre>"},{"location":"bbb/thirdparty/#alsa-lib","title":"<code>alsa-lib</code>","text":"<p><code>alsa-lib</code> is a library supposed to handle the interaction with the ALSA subsystem. It is available at https://alsa-project.org/.</p>"},{"location":"bbb/thirdparty/#source-code","title":"Source code","text":"<p>Download version <code>1.2.7.1</code>, and extract it in <code>$HOME/embeddedlinux-qemu-labs/thirdparty/</code>.</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.2.7.1\"\n$ wget \"https://www.alsa-project.org/files/pub/lib/alsa-lib-${label}.tar.bz2\"\n$ tar xfv \"alsa-lib-${label}.tar.bz2\"\n$ mv alsa-lib*/ alsa-lib\n$ cd alsa-lib/\n</code></pre> <p>Tip: if the website for any of the source packages that we need to download in the next sections is down, a great mirror that you can use is http://sources.buildroot.net/.</p>"},{"location":"bbb/thirdparty/#configuration","title":"Configuration","text":"<p>Back to <code>alsa-lib</code> sources, look at the <code>configure</code> script and see that it has been generated by <code>autoconf</code> (the header contains a sentence like Generated by GNU Autoconf 2.69). Most of the time, <code>autoconf</code> comes with <code>automake</code>, that generates Makefiles from <code>Makefile.am</code> files. So <code>alsa-lib</code> uses a rather common build system. Let's try to configure and build it:</p> <pre><code>$ export MAKEFLAGS=-j$(nproc)\n$ head -n3 configure\n#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.69 for alsa-lib 1.2.7.1.\n$ ./configure\n$ make\n</code></pre> <p>If you look at the generated binaries, you'll see that they are x86 ones because we compiled the sources with <code>gcc</code>, the default compiler. This is obviously not what we want, so let's clean up the generated objects and tell the configure script to use the ARM cross-compiler.</p> <pre><code>$ file aserver/aserver.o\naserver/aserver.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped\n$ make clean\n$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ CC=arm-linux-gcc ./configure\n    ...\nchecking whether we are cross compiling... configure: error: in `/home/me/embedded-linux-bbb-labs/thirdparty/alsa-lib':\nconfigure: error: cannot run C compiled programs.\nIf you meant to cross compile, use `--host'.\nSee `config.log' for more details\n</code></pre> <p>Of course, the <code>arm-linux-gcc</code> cross-compiler must be in your <code>PATH</code> prior to running the configure script. The <code>CC</code> environment variable is the classical name for specifying the compiler to use. Quickly, you should get an error, as highlighted above.</p> <p>If you look at the <code>config.log</code> file, you can see that the <code>configure</code> script compiles a binary with the cross-compiler and then tries to run it on the development workstation. This is a rather usual thing to do for a <code>configure</code> script, and that's why it tests so early that it's actually doable, and bails out if not.</p> config.log<pre><code>    ...\nconfigure:3719: arm-linux-gcc -o conftest    conftest.c  &gt;&amp;5\nconfigure:3723: $? = 0\nconfigure:3730: ./conftest\narm-binfmt-P: Could not open '/lib/ld-uClibc.so.0': No such file or directory\nconfigure:3734: $? = 255\nconfigure:3741: error: in `/home/me/embedded-linux-bbb-labs/thirdparty/alsa-lib':\nconfigure:3743: error: cannot run C compiled programs.\nIf you meant to cross compile, use `--host'.\nSee `config.log' for more details\n    ...\n</code></pre> <p>Obviously, it cannot work in our case, and the scripts exits. The job of the <code>configure</code> script is to test the configuration of the system. To do so, it tries to compile and run a few sample applications to test if this library is available, if this compiler option is supported, etc. But in our case, running the test examples is definitely not possible.</p> <p>We need to tell the <code>configure</code> script that we are cross-compiling, and this can be done using the <code>--build</code> and <code>--host</code> options, as described in the <code>help</code> of the <code>configure</code> script.</p> ./configure --help<pre><code>    ...\nSystem types:\n  --build=BUILD     configure for building on BUILD [guessed]\n  --host=HOST       cross-compile to build programs to run on HOST [BUILD]\n    ...\n</code></pre> <p>The <code>--build</code> option allows to specify on which system the package is built, while the <code>--host</code> option allows to specify on which system the package will run. By default, the value of the <code>--build</code> option is guessed, and the value of <code>--host</code> is the same as the value of the <code>--build</code> option. The value is guessed using the <code>./config.guess</code> script, which on your system should return <code>x86_64-pc-linux-gnu</code>. See the <code>autoconf</code> manual for more details on these options.</p> <p>So, let's override the value of the <code>--host</code> option:</p> <pre><code>$ ./configure --host=arm-linux\n</code></pre> <p>Note that <code>CC</code> is not required anymore. It is implied by <code>--host</code>.</p> <p>The <code>configure</code> script should end properly now, and create a <code>Makefile</code>. However, there is one subtle last issue to handle: because the C library used in our toolchain (uClibc-ng) does not support symbol versioning, we need to tell <code>alsa-lib</code> about this by passing <code>--without-versioned</code>. Without this option, <code>alsa-lib</code> will build fine, but it will not work properly at runtime.</p>"},{"location":"bbb/thirdparty/#build","title":"Build","text":"<p>So, you should configure <code>alsa-lib</code> and <code>run</code> the make command, which should run just fine.</p> <pre><code>$ make clean\n$ ./configure --host=arm-linux --without-versioned\n$ make\n</code></pre> <p>Look at the result of compiling in <code>src/.libs/</code>: a set of object files and a set of <code>libasound.so*</code> files.</p> <pre><code>$ ls -l src/.libs/\ntotal 4304\n-rw-rw-r-- 1 me me   36160 Apr 22 10:45 async.o\n-rw-rw-r-- 1 me me   15828 Apr 22 10:45 confeval.o\n-rw-rw-r-- 1 me me   70424 Apr 22 10:45 confmisc.o\n-rw-rw-r-- 1 me me  237212 Apr 22 10:45 conf.o\n-rw-rw-r-- 1 me me   19108 Apr 22 10:45 dlmisc.o\n-rw-rw-r-- 1 me me   11532 Apr 22 10:45 error.o\n-rw-rw-r-- 1 me me   18688 Apr 22 10:45 input.o\nlrwxrwxrwx 1 me me      15 Apr 22 10:45 libasound.la -&gt; ../libasound.la\n-rw-rw-r-- 1 me me     937 Apr 22 10:45 libasound.lai\nlrwxrwxrwx 1 me me      18 Apr 22 10:45 libasound.so -&gt; libasound.so.2.0.0\nlrwxrwxrwx 1 me me      18 Apr 22 10:45 libasound.so.2 -&gt; libasound.so.2.0.0\n-rwxrwxr-x 1 me me 3981232 Apr 22 10:45 libasound.so.2.0.0\n-rw-rw-r-- 1 me me    3524 Apr 22 10:45 names.o\n-rw-rw-r-- 1 me me   20296 Apr 22 10:45 output.o\n-rw-rw-r-- 1 me me    6468 Apr 22 10:45 shmarea.o\n-rw-rw-r-- 1 me me    7292 Apr 22 10:45 socket.o\n-rw-rw-r-- 1 me me    7532 Apr 22 10:45 userfile.o\n</code></pre> <p>The <code>libasound.so*</code> files are a dynamic version of the library. The shared library itself is <code>libasound.so.2.0.0</code>, which was generated by the following command line:</p> Compilation of libasound.so.2.0.0 by make<pre><code>$ arm-linux-gcc -shared conf.o confmisc.o input.o output.o async.o  \\\nerror.o dlmisc.o socket.o shmarea.o userfile.o names.o  \\\n-lm -ldl -lpthread -lrt -Wl,-soname -Wl,libasound.so.2  \\\n-o libasound.so.2.0.0\n</code></pre> <p>It creates the symbolic links <code>libasound.so</code> and <code>libasound.so.2</code>.</p> Symbolic linking of libasound.so.2.0.0 by make<pre><code>$ ln -s libasound.so.2.0.0 libasound.so.2\n$ ln -s libasound.so.2.0.0 libasound.so\n</code></pre> <p>These symlinks are needed for two different reasons:</p> <ul> <li> <p><code>libasound.so</code> is used at compile time when you want to compile an application that is dynamically linked against the library. To do so, you pass the <code>-l&lt;LIBNAME&gt;</code> option to the compiler, which will look for a file named <code>lib&lt;LIBNAME&gt;.so</code>. In our case, the compilation option is <code>-lasound</code> and the name of the library file is <code>libasound.so</code>. So, the <code>libasound.so</code> symlink is needed at compile time.</p> </li> <li> <p><code>libasound.so.2</code> is needed because it is the SONAME of the library. SONAME stands for Shared Object Name. It is the name of the library as it will be stored in applications linked against this library. It means that at runtime, the dynamic loader will look for exactly this name when looking for the shared library. So, this symbolic link is needed at runtime.</p> </li> </ul> <p>To know what's the SONAME of a library, you can use:</p> <pre><code>$ arm-linux-readelf -d src/.libs/libasound.so.2.0.0\n\nDynamic section at offset 0xdff20 contains 24 entries:\n  Tag        Type                         Name/Value\n 0x00000001 (NEEDED)                     Shared library: [libc.so.0]\n 0x00000001 (NEEDED)                     Shared library: [ld-uClibc.so.1]\n 0x0000000e (SONAME)                     Library soname: [libasound.so.2]\n 0x0000000c (INIT)                       0x23b1c\n 0x0000000d (FINI)                       0xbc22c\n 0x00000019 (INIT_ARRAY)                 0xed2fc\n 0x0000001b (INIT_ARRAYSZ)               4 (bytes)\n 0x0000001a (FINI_ARRAY)                 0xed300\n 0x0000001c (FINI_ARRAYSZ)               8 (bytes)\n 0x00000004 (HASH)                       0x114\n 0x6ffffef5 (GNU_HASH)                   0x4318\n 0x00000005 (STRTAB)                     0x1021c\n 0x00000006 (SYMTAB)                     0x7a7c\n 0x0000000a (STRSZ)                      52374 (bytes)\n 0x0000000b (SYMENT)                     16 (bytes)\n 0x00000003 (PLTGOT)                     0xf0000\n 0x00000002 (PLTRELSZ)                   7776 (bytes)\n 0x00000014 (PLTREL)                     REL\n 0x00000017 (JMPREL)                     0x21cbc\n 0x00000011 (REL)                        0x1ceb4\n 0x00000012 (RELSZ)                      19976 (bytes)\n 0x00000013 (RELENT)                     8 (bytes)\n 0x6ffffffa (RELCOUNT)                   2084\n 0x00000000 (NULL)                       0x0\n</code></pre> <p>and look at the <code>(SONAME)</code> line. You'll also see that this library needs the C library, because of the <code>(NEEDED)</code> line on <code>libc.so.0</code>. The mechanism of SONAME allows to change the library without recompiling the applications linked with this library.</p> <p>Let's imagine that a security problem is found in the <code>alsa-lib</code> release that provides <code>libasound.so.2.0.0</code>, and fixed in the next <code>alsa-lib</code> release, which will now provide <code>libasound.so.2.0.1</code>. You can just recompile the library, install it on your target system, change the <code>libasound.so.2</code> link so that it points to <code>libasound.so.2.0.1</code> and restart your applications. It will work, because your applications don't look specifically for <code>libasound.so.2.0.0</code> but for the SONAME <code>libasound.so.2</code>. However, it also means that as a library developer, if you break the ABI of the library, you must change the SONAME: change from <code>libasound.so.2</code> to <code>libasound.so.3</code>.</p>"},{"location":"bbb/thirdparty/#installation","title":"Installation","text":"<p>Finally, the last step is to tell the <code>configure</code> script where the library is going to be installed. Most <code>configure</code> scripts consider that the installation prefix is <code>/usr/local/</code> (so that the library is installed in <code>/usr/local/lib/</code>, the headers in <code>/usr/local/include/</code>, etc.). Instead, in our system we simply want the libraries to be installed in the <code>/usr/</code> prefix, so let's tell the <code>configure</code> script about this:</p> <pre><code>$ make clean\n$ ./configure --host=arm-linux --without-versioned --prefix=/usr/\n$ make\n</code></pre> <p>For this library, this option may not change anything to the resulting binaries. But, for safety it is always recommended to make sure that the prefix matches where your library will be running on the target system.</p> <p>Do not confuse the prefix (where the application or library will be running on the target system) with the location where the application or library will be installed on your host while building the root filesystem.</p> <p>For example, <code>libasound</code> is installed in <code>$HOME/embedded-linux-bbb-labs/thirdparty/target/usr/lib/</code> because this is the directory where we are building the root filesystem. But, once our target system is running, it looks for <code>libasound</code> in <code>/usr/lib/</code>.</p> <p>The prefix corresponds to the path in the target system and never on the host. So, one should never pass a prefix like <code>$HOME/embedded-linux-bbb-labs/thirdparty/target/usr/</code>, otherwise at runtime the application or library may look for files inside this directory on the target system, which obviously doesn't exist! By default, most build systems install the application or library in the given prefix (<code>/usr/</code> or <code>/usr/local/</code>), but with most build systems (including <code>autotools</code>), the installation prefix can be overridden,  different from the configuration prefix.</p> <p>We now only have the installation process left to do. First, let's make the installation in the staging space:</p> <pre><code>$ make DESTDIR=\"$LAB_PATH/staging\" install\n$ cd \"$LAB_PATH/staging/\"\n$ tree -C | less -R\n</code></pre> <p>Now look at what has been installed by <code>alsa-lib</code>:</p> <ul> <li> <p>Some configuration files in <code>/usr/share/alsa/</code>:</p> <pre><code>$ ls -p usr/share/alsa/\nalsa.conf  cards/  ctl/  pcm/\n</code></pre> </li> <li> <p>The headers in <code>/usr/include/</code>:</p> <pre><code>$ ls -p usr/include/\nalsa/  asoundlib.h  sys/\n</code></pre> </li> <li> <p>The shared library and its <code>libtool</code> (<code>.la</code>) file in <code>/usr/lib/</code>:</p> <pre><code>$ ls -p usr/lib/\nlibasound.la  libasound.so.2      libatopology.la  libatopology.so.2      pkgconfig/\nlibasound.so  libasound.so.2.0.0  libatopology.so  libatopology.so.2.0.0\n</code></pre> </li> <li> <p>A pkgconfig file in <code>/usr/lib/pkgconfig/</code> \u2014 we'll come back to these later:</p> <pre><code>$ ls -p usr/lib/pkgconfig/\nalsa.pc  alsa-topology.pc\n</code></pre> </li> </ul> <p>Finally, let's install the library in the <code>target</code> space:</p> <ol> <li> <p>Create the <code>target/usr/lib</code> directory, it will contain the stripped version of the library.</p> </li> <li> <p>Copy the dynamic version of the library. Only <code>libasound.so.2</code> and <code>libasound.so.2.0.0</code> are needed, since <code>libasound.so.2</code> is the SONAME of the library and <code>libasound.so.2.0.0</code> is the real binary.</p> </li> <li> <p>Measure the size of the <code>target/usr/lib/libasound.so.2.0.0</code> library before stripping.</p> </li> <li> <p>Strip the library.</p> </li> <li> <p>Measure the size of the <code>target/usr/lib/libasound.so.2.0.0</code> library again after stripping. How many unnecessary bytes were saved?</p> </li> </ol> <pre><code>$ cd $LAB_PATH\n$ cp -av staging/usr/lib/libasound.so.2* target/usr/lib/\n'staging/usr/lib/libasound.so.2' -&gt; 'target/usr/lib/libasound.so.2'\n'staging/usr/lib/libasound.so.2.0.0' -&gt; 'target/usr/lib/libasound.so.2.0.0'\n$ du -h target/usr/lib/libasound.so.2.0.0\n3.8M    target/usr/lib/libasound.so.2.0.0\n$ arm-linux-strip target/usr/lib/libasound.so.2.0.0\n$ du -h target/usr/lib/libasound.so.2.0.0\n904K    target/usr/lib/libasound.so.2.0.0\n</code></pre> <p>Then, we need to install the <code>alsa-lib</code> configuration files:</p> <pre><code>$ mkdir -p target/usr/share\n$ cp -arv staging/usr/share/alsa/ target/usr/share/\n    ...\n</code></pre> <p>Now, we need to adjust one small detail in one of the configuration files. Indeed, <code>/usr/share/alsa/alsa.conf</code> assumes a UNIX group called <code>audio</code> exists, which is not the case on our very small system; let's set to root instead (group id <code>0</code>). Edit this file and replace <code>defaults.pcm.ipc_gid audio</code> with <code>defaults.pcm.ipc_gid 0</code> instead.</p> <pre><code>$ sed -i \"s/defaults.pcm.ipc_gid audio/defaults.pcm.ipc_gid 0/g\"  \\\ntarget/usr/share/alsa/alsa.conf\n</code></pre> <p>And we're done with <code>alsa-lib</code>!</p>"},{"location":"bbb/thirdparty/#alsa-utils","title":"<code>alsa-utils</code>","text":""},{"location":"bbb/thirdparty/#source-code_1","title":"Source code","text":"<p>Download <code>alsa-utils</code> from the ALSA offical webpage. We tested the lab with version <code>1.2.6</code>. Once uncompressed, we quickly discover that the <code>alsa-utils</code> build system is based on the autotools, so we will work once again with a regular <code>configure</code> script.</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.2.6\"\n$ wget \"https://www.alsa-project.org/files/pub/utils/alsa-utils-${label}.tar.bz2\"\n$ tar xfv \"alsa-utils-${label}.tar.bz2\"\n$ mv alsa-utils*/ alsa-utils\n$ cd alsa-utils/\n</code></pre>"},{"location":"bbb/thirdparty/#configuration_1","title":"Configuration","text":"<p>As we've seen previously, we have to provide the prefix, host options, and the <code>CC</code> variable. We should quiclky get an error in the execution of the configure script.</p> <pre><code>$ ./configure --host=arm-linux --prefix=/usr\n    ...\nchecking for libasound headers version &gt;= 1.2.5 (1.2.5)... not present.\nconfigure: error: Sufficiently new version of libasound not found.\n</code></pre> <p>Again, we can check in <code>config.log</code> what the configure script is trying to do.</p> File: config.log<pre><code>    ...\nconfigure:8080: checking for libasound headers version &gt;= 1.2.5 (1.2.5)\nconfigure:8127: arm-linux-gcc -c -g -O2  conftest.c &gt;&amp;5\nconftest.c:12:10: fatal error: alsa/asoundlib.h: No such file or directory\n   12 | #include &lt;alsa/asoundlib.h&gt;\n      |          ^~~~~~~~~~~~~~~~~~\ncompilation terminated.\n    ...\n</code></pre> <p>Of course, since <code>alsa-utils</code> uses <code>alsa-lib</code>, it includes its header file! So, we need to tell the C compiler where the headers can be found. They aren't in the default directory <code>/usr/include/</code>, but in the equivalent directory of our staging space. The <code>help</code> text of the <code>configure</code> script says:</p> File: configure<pre><code>    ...\nSome influential environment variables:\n    ...\n  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I&lt;include dir&gt; if\n              you have headers in a nonstandard directory &lt;include dir&gt;\n    ...\n</code></pre> <p>Let's use it! Now, it should stop a bit later, this time with another error.</p> <pre><code>$ CPPFLAGS=-I\"$LAB_PATH/staging/usr/include\"  \\\n./configure --host=arm-linux --prefix=/usr\n    ...\nchecking for libasound headers version &gt;= 1.2.5 (1.2.5)... found.\n    ...\nchecking for snd_ctl_open in -lasound... no\nconfigure: error: No linkable libasound was found.\n</code></pre> <p>The configure script tries to compile an application against <code>libasound</code> (see the <code>-lasound</code> option): <code>alsa-utils</code> uses <code>alsa-lib</code>, so the <code>configure</code> script wants to make sure this library is already installed. Unfortunately, the <code>ld</code> linker doesn't find it. So, let's tell the linker where to look for libraries using the <code>-L</code> option followed by the directory where our libraries are (in <code>staging/usr/lib</code>). This <code>-L</code> option can be passed to the linker by using the <code>LDFLAGS</code> at <code>configure</code> time, as told by the help text of the configure script:</p> File: configure<pre><code>    ...\nSome influential environment variables:\n    ...\n  LDFLAGS     linker flags, e.g. -L&lt;lib dir&gt; if you have libraries in a\n              nonstandard directory &lt;lib dir&gt;\n    ...\n</code></pre> <p>Let's use this LDFLAGS variable:</p> <pre><code>$ LDFLAGS=-L\"$LAB_PATH/staging/usr/lib\"  \\\nCPPFLAGS=-I\"$LAB_PATH/staging/usr/include\"  \\\n./configure --host=arm-linux --prefix=/usr\n    ...\nchecking panel.h usability... no\nchecking panel.h presence... no\nchecking for panel.h... no\nconfigure: error: required curses helper header not found\n</code></pre> <p>Once again, it should fail a bit further down the tests, this time complaining about a missing curses helper header. <code>curses</code> (or <code>ncurses</code>, new curses) is a graphical framework to design text UIs within the terminal.</p> <p>This is only used by <code>alsamixer</code>, one of the tools provided by <code>alsa-utils</code>, that we are not going to use. Hence, we can just disable the build of <code>alsamixer</code>. Of course, if we wanted it, we would have had to build <code>ncurses</code> first, just like we built <code>alsa-lib</code>.</p>"},{"location":"bbb/thirdparty/#build_1","title":"Build","text":"<p>Then, run the compilation with <code>make</code>. Hopefully, it works!</p> <pre><code>$ LDFLAGS=-L\"$LAB_PATH/staging/usr/lib\"  \\\nCPPFLAGS=-I\"$LAB_PATH/staging/usr/include\"  \\\n./configure --host=arm-linux --prefix=/usr --disable-alsamixer\n$ make\n</code></pre>"},{"location":"bbb/thirdparty/#installation_1","title":"Installation","text":"<p>Let's now begin the installation process. Before really installing in the <code>staging</code> directory, let's install in a dummy directory, to see what's going to be installed \u2014 this dummy directory will not be used afterwards, it is only to verify what will be installed before polluting the staging space.</p> <pre><code>$ make DESTDIR=/tmp/alsa-utils install\n</code></pre> <p>The <code>DESTDIR</code> variable can be used with all Makefiles based on <code>automake</code>. It allows to override the installation directory: instead of being installed in the configuration <code>prefix</code> directory, the files will be installed in <code>$DESTDIR/configuration-prefix</code>. Now, let's see what has been installed in <code>/tmp/alsa-utils/</code>;</p> <pre><code>$ tree -C /tmp/alsa-utils/ | less -R\n/tmp/alsa-utils/\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 systemd\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 system\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 alsa-restore.service\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 alsa-state.service\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 sound.target.wants\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 alsa-restore.service -&gt; ../alsa-restore.service\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 alsa-state.service -&gt; ../alsa-state.service\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 udev\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 rules.d\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 90-alsa-restore.rules\n\u251c\u2500\u2500 usr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aconnect\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsabat\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaloop\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsatplg\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaucm\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amidi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amixer\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplay\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplaymidi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecord -&gt; aplay\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecordmidi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqdump\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqnet\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 iecset\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 speaker-test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sbin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsabat-test.sh\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaconf\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsactl\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 alsa-info.sh\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 share\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 alsa\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 init\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 00main\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ca0106\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 default\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 hda\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 help\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 info\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 speaker-test\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 sample_map.csv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 man\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fr\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 man8\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 alsaconf.8\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 man1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aconnect.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsabat.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsactl.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsa-info.sh.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaloop.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amidi.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amixer.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplay.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplaymidi.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecord.1 -&gt; aplay.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecordmidi.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqdump.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqnet.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer-list.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer-transfer.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 iecset.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 speaker-test.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 man7\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 man8\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 alsaconf.8\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 sounds\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 alsa\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Front_Center.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Front_Left.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Front_Right.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Noise.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Rear_Center.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Rear_Left.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Rear_Right.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Side_Left.wav\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 Side_Right.wav\n\u2514\u2500\u2500 var\n    \u2514\u2500\u2500 lib\n        \u2514\u2500\u2500 alsa\n24 directories, 62 files\n</code></pre> <p>So, we have</p> <ul> <li>The <code>systemd</code> service definitions in <code>lib/systemd/</code>.</li> <li>The <code>udev</code> rules in <code>lib/udev/</code>.</li> <li>The <code>alsa-utils</code> binaries in <code>/usr/bin/</code> and <code>/usr/sbin/</code>.</li> <li>Some sound samples in <code>/usr/share/sounds/</code>.</li> <li>The various translations in <code>/usr/share/locale/</code>.</li> <li>The manual pages in <code>/usr/share/man/</code>, explaining how to use the various tools.</li> <li>Some configuration samples in <code>/usr/share/alsa/</code>.</li> </ul> <p>Now, let's make the installation in the <code>staging</code> space: Then, let's manually install only the necessary files in the <code>target</code> space. We are only interested in <code>speaker-test</code>:</p> <pre><code>$ make DESTDIR=\"$LAB_PATH/staging\" install\n$ cd $LAB_PATH\n$ cp -a staging/usr/bin/speaker-test target/usr/bin/\n$ arm-linux-strip target/usr/bin/speaker-test\n</code></pre> <p>You may need to add the missing libraries from the toolchain install directory.</p> <p>We're finally done with <code>alsa-utils</code>!</p>"},{"location":"bbb/thirdparty/#quick-test","title":"Quick test","text":"<p>Now test that all is working fine by running the <code>speaker-test</code> utility on your board.</p> <p>Now you can launch your machine as usual, with rootfs on NFS, and test <code>speaker-test</code> in a shell:</p> picocomBBB - BusyBox<pre><code># speaker-test -t sine -l 1\nspeaker-test 1.2.6\nPlayback device is default\nStream parameters are 48000Hz, S16_LE, 1 channels\nSine wave rate is 440.0000Hz\nRate set to 48000Hz (requested 48000Hz)\nBuffer size range from 2229 to 17832\nPeriod size range from 1114 to 1115\nUsing max buffer size 17832\nPeriods = 4\nwas set period_size = 1114\nwas set buffer_size = 17832\n 0 - Front Left\nTime per period = 2.642531\n</code></pre> <p>There you are: you built and ran your first program depending on a library different from the C library!</p>"},{"location":"bbb/thirdparty/#libgpiod","title":"<code>libgpiod</code>","text":""},{"location":"bbb/thirdparty/#compiling","title":"Compiling","text":"<p>We are now going to use <code>libgpiod</code> instead of the deprecated interface in <code>/sys/class/gpio</code>. Its executables (<code>gpiodetect</code>, <code>gpioset</code>, <code>gpioget</code>, etc.) will allow us to drive and manage GPIOs from shell scripts.</p> <p>We are going to need code that is more recent than the latest release at the time of this writing (<code>1.6.3</code>), and checkout a commit that we tested (<code>7311e1d5</code>).</p> <pre><code>$ cd $LAB_PATH\n$ label=\"7311e1d5\"\n$ git clone https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git\n$ cd libgpiod/\n$ git checkout -b embedded-linux-bbb $label\n</code></pre> <p>Alternatively, you could use an archive of that commit (see also: git commit hash expansion).</p> <pre><code>$ cd $LAB_PATH\n$ label=\"7311e1d5b9473ab561977bd730acb793821a683f\"\n$ wget \"https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/snapshot/libgpiod-${label}.tar.gz\"\n$ tar xfv \"libgpiod-${label}.tar.gz\"\n$ mv libgpiod*/ libgpiod\n$ cd libgpiod/\n</code></pre> <p>As we are not starting from a release, we will need to install further development tools to generate some files like the configure script:</p> <pre><code>$ sudo apt install autoconf-archive pkg-config\n</code></pre> <p>Now let's generate the files which are present in a release via <code>autogen.sh</code>.</p> <pre><code>$ ./autogen.sh\n    ...\n</code></pre> <p>Run <code>./configure --help</code> script, and see that this script provides an <code>--enable-tools</code> option, which allows to build the user-space executables that we want.</p> <pre><code>$ ./configure --help\n    ...\nOptional Features:\n    ...\n  --enable-tools          enable libgpiod command-line tools [default=no]\n    ...\n</code></pre> <p>As this project doesn't have any external library dependency, let's configure libgpiod in a similar way as alsa-utils, so that we can run <code>make</code>. Installation to the staging space can be done using the classical <code>DESTDIR</code> mechanism.</p> <pre><code>$ ./configure --host=arm-linux --prefix=/usr --enable-tools\n$ make\n$ make DESTDIR=\"$LAB_PATH/staging\" install\n</code></pre> <p>Finally, only manually install and strip the files needed at runtime in the target space.</p> <pre><code>$ cd $LAB_PATH\n$ cp -a staging/usr/lib/libgpiod.so.2* target/usr/lib/\n$ arm-linux-strip target/usr/lib/libgpiod*\n$ cp -a staging/usr/bin/gpio* target/usr/bin/\n$ arm-linux-strip target/usr/bin/gpio*\n</code></pre>"},{"location":"bbb/thirdparty/#testing_1","title":"Testing","text":"<p>First, connect <code>GPIO1_28</code> (pin 12 of connector P9) connected to ground (pin 1 of connector P9), as done for the Accessing Hardware Devices lab.</p> <p>Reboot the board, then run the <code>gpiodetect</code> command to check that you can list the various GPIO banks on your system.</p> picocomBBB - BusyBox<pre><code># gpiodetect\ngpiochip0 [gpio-0-31] (32 lines)\ngpiochip1 [gpio-32-63] (32 lines)\ngpiochip2 [gpio-64-95] (32 lines)\ngpiochip3 [gpio-96-127] (32 lines)\n</code></pre> <p>So, <code>GPIO1_28</code> should be part of <code>gpiochip0</code>.</p> <p>We can then get details on GPIOE GPIOs by running <code>gpioinfo gpiochip0</code>, or on all GPIOs by simply running <code>gpioinfo</code>.</p> picocomBBB - BusyBox<pre><code># gpioget gpiochip0 28\n0\n</code></pre> <p>Now, connect your wire to 3.3 V (pin 3 or 4 of connector P9). You should now read:</p> picocomBBB - BusyBox<pre><code># gpioget gpiochip0 28\n1\n</code></pre> <p>You see that you didn\u2019t have to configure the GPIO as input. libgpiod did that for you.</p> <p>If you have an LED and a small breadboard (or M-F breadboard wires), you could also try to drive the GPIO in output mode. Connect the short pin of the LED to GND, and the long one to the GPIO Then then following command should light up the diode for 5 seconds (for example):</p> picocomBBB - BusyBox<pre><code># gpioset -m time -s 5 gpiochip0 28=1\n</code></pre> <p>The <code>gpioset</code> command offers many more options. Run <code>gpioset -h</code> to check by yourself.</p>"},{"location":"bbb/thirdparty/#ipcalc","title":"<code>ipcalc</code>","text":"<p>After practicing with autotools based packages, let's build <code>ipcalc</code>, which is using Meson as build system. We won't really need this utility in our system, but at least it has no dependencies and therefore offers an easy way to build our first Meson based package.</p> <p>So, first install the <code>meson</code> package:</p> <pre><code>$ sudo apt install meson\n</code></pre>"},{"location":"bbb/thirdparty/#source-code_2","title":"Source code","text":"<p>In the main lab directory, then let's check out the sources through git:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.0.1\"\n$ git clone https://gitlab.com/ipcalc/ipcalc.git\n$ cd ipcalc/\n$ git checkout -b embedded-linux-bbb $label\n</code></pre> <p>Alternatively, you can retrieve an archived release:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.0.1\"\n$ wget \"https://gitlab.com/ipcalc/ipcalc/-/archive/${label}/ipcalc-${label}.tar.bz2\"\n$ tar xfv \"ipcalc-${label}.tar.bz2\"\n$ mv ipcalc*/ ipcalc\n$ cd ipcalc/\n</code></pre>"},{"location":"bbb/thirdparty/#configuration_2","title":"Configuration","text":"<p>To cross-compile with Meson, we need to create a cross file. Let's create the <code>$LAB_PATH/cross-file.txt</code> file with the following content:</p> File: $LAB_PATH/cross-file.txt<pre><code>[binaries]\nc = 'arm-linux-gcc'\n[host_machine]\nsystem = 'linux'\ncpu_family = 'arm'\ncpu = 'cortex-a9'\nendian = 'little'\n</code></pre> <p>Command-line shortcut:</p> <pre><code>$ cd \"$LAB_PATH/ipcalc/\"\n$ cat &gt; ../cross-file.txt &lt;&lt;'EOF'\n[binaries]\nc = 'arm-linux-gcc'\n[host_machine]\nsystem = 'linux'\ncpu_family = 'arm'\ncpu = 'cortex-a9'\nendian = 'little'\nEOF\n</code></pre> <p>We also need to create a special directory for building:</p> <pre><code>$ mkdir cross-build\n$ cd cross-build/\n</code></pre>"},{"location":"bbb/thirdparty/#build_2","title":"Build","text":"<p>We can now have Meson create the Ninja build files for us:</p> <pre><code>$ meson --cross-file ../../cross-file.txt --prefix /usr ..\nThe Meson build system\n    ...\nC compiler for the host machine: arm-linux-gcc (gcc 11.3.0 \"arm-linux-gcc (crosstool-NG 1.25.0.95_7622b49) 11.3.0\")\nC linker for the host machine: arm-linux-gcc ld.bfd 1.25.0.95\nC compiler for the build machine: cc (gcc 11.3.0 \"cc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0\")\nC linker for the build machine: cc ld.bfd 2.38\nBuild machine cpu family: x86_64\nBuild machine cpu: x86_64\nHost machine cpu family: arm\nHost machine cpu: cortex-a9\nTarget machine cpu family: arm\nTarget machine cpu: cortex-a9\n    ...\nBuild targets in project: 1\nipcalc 1.0.1\n  User defined options\n    Cross files: ../../cross-file.txt\n    prefix     : /usr\nFound ninja-1.10.1 at /usr/bin/ninja\nWARNING: Cross file does not specify strip binary, result will not be stripped.\n</code></pre> <p>We're finally ready to build <code>ipcalc</code>:</p> <pre><code>$ ninja\n[7/7] Linking target ipcalc\n</code></pre>"},{"location":"bbb/thirdparty/#installation_2","title":"Installation","text":"<p>And now install <code>ipcalc</code> into the <code>staging</code> space. Check that the <code>staging/usr/bin/ipcalc</code> file is indeed an ARM executable!</p> <pre><code>$ DESTDIR=\"$LAB_PATH/staging\" ninja install\n[0/1] Installing files.\nInstalling ipcalc to /home/me/embedded-linux-bbb-labs/thirdparty/staging/usr/bin\n$ file \"$LAB_PATH/staging/usr/bin/ipcalc\"\n/home/me/embedded-linux-bbb-labs/thirdparty/staging/usr/bin/ipcalc: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, with debug_info, not stripped\n</code></pre> <p>The last thing to do is to copy it to the target space and strip it.</p> <pre><code>$ cd $LAB_PATH\n$ cp staging/usr/bin/ipcalc target/usr/bin/\n$ arm-linux-strip target/usr/bin/ipcalc\n</code></pre> <p>Note that we could have asked <code>ninja install</code> to strip the executable for us when installing it into the <code>staging</code> directory. To do, this, we would have added a <code>strip</code> entry in the cross file, and passed <code>--strip</code> to Meson. However, it's better to keep files unstripped in the <code>staging</code> space, in case we need to debug them!</p>"},{"location":"bbb/thirdparty/#quick-test_1","title":"Quick test","text":"<p>You can now test that <code>ipcalc</code> works on the target:</p> picocomBBB - BusyBox<pre><code># ipcalc 192.168.0.15\nAddress:        192.168.0.15\nAddress space:  Private Use\n</code></pre>"},{"location":"bbb/thirdparty/#final-touch","title":"Final touch","text":"<p>To finish this lab completely, and to be consistent with what we've done before, let's strip the C library and its loader too. Let's compare the size of the binaries to confirm.</p> <pre><code>$ du -hs target/lib/ target/usr/lib/\n78M     target/lib/\n976K    target/usr/lib/\n$ so_files=$(find target -name \"*.so*\")\n$ chmod +w $so_files\n$ arm-linux-strip $so_files\n$ ko_files=$(find target -name \"*.ko\")\n$ chmod +w $ko_files\n$ arm-linux-strip $ko_files\n$ du -hs target/lib/ target/usr/lib/\n17M     target/lib/\n976K    target/usr/lib/\n</code></pre>"},{"location":"bbb/thirdparty/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ cd $LAB_PATH\n$ tar cfJv thirdparty-staging.tar.xz staging/\n$ tar cfJv thirdparty-target.tar.xz target/\n$ cd target/\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; ../thirdparty-target.cpio.xz\n</code></pre>"},{"location":"bbb/thirdparty/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/tinysystem/","title":"Tiny embedded system with BusyBox","text":""},{"location":"bbb/tinysystem/#objectives","title":"Objectives","text":"<ul> <li> <p>Make a tiny yet full-featured embedded system.</p> </li> <li> <p>Be able to configure and build a Linux kernel that boots on a directory on your workstation, shared through the network by NFS.</p> </li> <li> <p>Be able to create and configure a minimalistic root filesystem from scratch (ex nihilo, out of nothing, entirely hand made...) for your target board.</p> </li> <li> <p>Understand how small and simple an embedded Linux system can be.</p> </li> <li> <p>Be able to install BusyBox on this filesystem.</p> </li> <li> <p>Be able to create a simple startup script based on <code>/sbin/init</code>.</p> </li> <li> <p>Be able to set up a simple web interface for the target.</p> </li> </ul>"},{"location":"bbb/tinysystem/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>nfs-kernel-server</code></p> <p>plus those from the previous labs.</p> </li> <li> <p>BusyBox, either as:</p> <ul> <li> <p>git repository tag <code>1_35_0</code></p> </li> <li> <p>Source code archive for release <code>1_35_0</code></p> </li> </ul> </li> </ul>"},{"location":"bbb/tinysystem/#overview","title":"Overview","text":"<p>While developing a root filesystem for a device, a developer needs to make frequent changes to the filesystem contents, like modifying scripts or adding newly compiled programs.</p> <p>It isn\u2019t practical at all to reflash the root filesystem on the target every time a change is made. Fortunately, it is possible to set up networking between the development workstation and the target. Then, workstation files can be accessed by the target through the network, using NFS.</p> <p>Unless you test a boot sequence, you no longer need to reboot the target to test the impact of script or application updates.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/tinysystem\"\n</code></pre>"},{"location":"bbb/tinysystem/#kernel-configuration","title":"Kernel configuration","text":"<p>We'll re-use the kernel sources from the kernel lab.</p> <p>In the kernel configuration (see: <code>menuconfig</code>) verify that you have all the options needed for booting the system using a root filesystem mounted over NFS. Also enable the automatic mount of <code>devtmpfs</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux\"\n$ cp ../kernel.config .config\n$ make menuconfig\n</code></pre> <p>In <code>File systems</code>:</p> <ul> <li> <p>Enable <code>Network File Systems</code> (<code>NETWORK_FILESYSTEMS</code>), which should enable also the client for v2 and v3.   Inside this menu entry:</p> <ul> <li>Enable <code>Root file system on NFS</code> (<code>ROOT_NFS</code>).</li> </ul> </li> </ul> <p>In <code>Device Drivers</code> \u2192 <code>Generic Driver Options</code>:</p> <ul> <li>Enable <code>Maintain a devtmpfs filesystem to mount at /dev</code> (<code>CONFIG_DEVTMPFS_MOUNT</code>).</li> </ul> <p>Everything should already be as expected. If necessary, backup the new configuration and rebuild the kernel:</p> <pre><code>$ cp .config \"$LAB_PATH/kernel-busybox.config\"\n$ make\n</code></pre>"},{"location":"bbb/tinysystem/#nfs-server","title":"NFS server","text":"<p>A NFS server is provided by the <code>nfs-kernel-server</code> package:</p> <pre><code>$ sudo apt install nfs-kernel-server\n</code></pre> <p>Create a <code>nfsroot</code> directory in the current lab directory. We're going to use this folder as our NFS root folder. If we were to add it directly, we would need to specify the whole path when requesting files from it, which might become verbose, and exposes our private paths to the public. Instead, we can create a symbolic link at <code>/srv/nfs/</code>, and we can assign it the same <code>tftp</code> group of the previous labs:</p> <pre><code>$ mkdir -p \"$LAB_PATH/nfsroot\"\n$ sudo rm -rf /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/nfsroot\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-bbb-labs/tinysystem/nfsroot'\n$ sudo chown -R tftp:tftp /srv/nfs\n</code></pre> <p>Once installed, edit the <code>/etc/exports</code> file (as root) to export our <code>nfsroot</code> to the whole <code>192.168.0.x</code> subnet, with some specific options:</p> File: /etc/exports - line to append<pre><code>/srv/nfs 192.168.0.0/255.255.255.0(rw,no_root_squash,no_subtree_check)\n</code></pre> <p>A quick way is by appending that line to the file via a shell command. In our example we use <code>tee</code> (we cannot <code>sudo echo \"text\" &gt;&gt; file</code>!):</p> <pre><code>$ NET_IP=\"192.168.0.0\"\n$ NET_MASK=\"255.255.255.0\"\n$ line=\"$NFS_ROOT $NET_IP/$NET_MASK(rw,no_root_squash,no_subtree_check)\"\n$ echo $line | sudo tee -a /etc/exports\n/srv/nfs 192.168.0.0/255.255.255.0(rw,no_root_squash,no_subtree_check)\n</code></pre> <p>Make sure that the path and the options are on the same line. Also make sure that there is no space between the IP address and the NFS options, otherwise default options will be used for this IP address, causing your root filesystem to be read-only.</p> <p>Then, restart the NFS server with the new configuration:</p> <pre><code>$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre>"},{"location":"bbb/tinysystem/#booting-the-system","title":"Booting the system","text":"<p>Let's connect <code>picocomBBB</code> and run our U-Boot on the board. Press any key as soon as the board boots, to stop U-Boot and enter its prompt.</p> <p>A separate shell is suggested for <code>picocomBBB</code> instances from now on.</p> picocomBBB - U-Boot<pre><code>$ picocomBBB\n    ...\nTerminal ready\n    ...\nHit any key to stop autoboot:  0\n=&gt;\n</code></pre> <p>Before booting the kernel, we need to tell it that the root filesystem should be mounted over NFS, by setting some kernel parameters. So, add the required settings to the <code>bootargs</code> environment variable (on a single long line!), and save it permanently:</p> picocomBBB - U-Boot<pre><code>=&gt; setenv netmask 255.255.255.0\n=&gt; setenv servernfs /srv/nfs\n=&gt; setenv netif eth0\n=&gt; setenv bootargs_nfs \"console=ttyS0,115200n8  root=/dev/nfs  ip=$ipaddr::$serverip:$netmask::$netif  nfsroot=$serverip:$servernfs,nfsvers=3,tcp  rw\"\n=&gt; setenv bootargs $bootargs_nfs\n=&gt; printenv bootargs\nbootargs=console=ttyS0,115200n8 root=/dev/nfs ip=192.168.0.69::192.168.0.15:255.255.255.0::eth0 nfsroot=192.168.0.15:/srv/nfs,nfsvers=3,tcp rw\n=&gt; saveenv\n</code></pre> <ul> <li> <p><code>console</code>: the debug console.</p> </li> <li> <p><code>root</code>: mounting to the standard virtual device for NFS.</p> </li> <li> <p><code>ip</code>: a detailed string with all the network parameters, for the maximum portability.</p> </li> <li> <p><code>nfsroot</code>: the path to the NFS folder on the server, as seen form the net, with the specified protocol.</p> </li> <li> <p><code>rw</code>: read and write permissions.</p> </li> </ul> <p>Now, reboot your system. The kernel should be able to mount the root filesystem over NFS (it might take some time to get there).</p> picocomBBB - U-Boot &amp; Kernel<pre><code>=&gt; reset\n    ...\nVFS: Mounted root (nfs filesystem) on device 0:16.\n    ...\n</code></pre> <p>If the kernel fails to mount the NFS filesystem, look carefully at the error messages in the console. If this doesn\u2019t give any clue, you can also have a look at the NFS server logs in <code>/var/log/syslog</code>.</p> <p>However, at this stage, the kernel should stop because of the following issue:</p> picocomBBB - Kernel<pre><code>    ...\nVFS: Mounted root (nfs filesystem) on device 0:16.\ndevtmpfs: error mounting -2\n    ...\n---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---\n</code></pre> <p>This happens because the kernel is trying to mount the devtmpfs filesystem in <code>/dev/</code> in the root filesystem. This virtual filesystem contains device files for all the devices known to the kernel, and with <code>CONFIG_DEVTMPFS_MOUNT</code>, our kernel tries to automatically mount <code>devtmpfs</code> on <code>/dev</code>.</p> <p>To address this, just create a <code>dev</code> directory under <code>nfsroot</code>:</p> <pre><code>$ mkdir -p \"$LAB_PATH/nfsroot/dev/\"\n</code></pre> <p>Now reset the board. The kernel should complain for the last time, saying that it can\u2019t find an <code>init</code> application:</p> picocomBBB - Kernel<pre><code>    ...\nVFS: Mounted root (nfs filesystem) on device 0:16.\ndevtmpfs: mounted\n    ...\n---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---\n</code></pre> <p>Obviously, our root filesystem being mostly empty, there isn\u2019t such an application yet. In the next paragraph, you will add BusyBox to your root filesystem, and finally make it usable.</p>"},{"location":"bbb/tinysystem/#root-filesystem-with-busybox","title":"Root filesystem with BusyBox","text":"<p>Download the sources of BusyBox release <code>1.35.0</code>:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1_35_0\"\n$ git clone https://git.busybox.net/busybox\n$ cd busybox/\n$ git checkout -b embedded-linux-bbb $label\n</code></pre> <p>Alternatively, you can get a source code archive:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1_35_0\"\n$ wget \"https://git.busybox.net/busybox/snapshot/busybox-${label}.tar.bz2\"\n$ tar xfv \"busybox-${label}.tar.bz2\"\n$ mv busybox*/ busybox\n$ cd busybox/\n</code></pre> <p>Now, configure BusyBox with the configuration file provided in the <code>data/</code> directory. Then, you can run <code>make menuconfig</code> to further customize the configuration. At least, keep the setting that builds a static BusyBox. Compiling it statically in the first place makes it easy to set up the system, because there are no dependencies. Later on, we will set up shared libraries and recompile BusyBox.</p> <pre><code>$ cp \"$LAB_PATH/data/busybox-1.35.config\" .config\n$ make menuconfig\n</code></pre> <p>Build BusyBox using the toolchain that you used to build the kernel.</p> <pre><code>$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export MAKEFLAGS=-j$(nproc)\n$ make\n</code></pre> <p>Going back to the BusyBox configuration interface, check the installation directory. Set it to the path to your <code>nfsroot</code> directory if necessary.</p> <pre><code>$ make menuconfig\n</code></pre> <p><code>Settings</code> \u2192 <code>Install Options</code> \u2192 <code>Destination path for 'make install'</code> (<code>PREFIX</code>) = <code>../nfsroot</code></p> <p>Now run <code>make install</code> to install BusyBox in this directory.</p> <pre><code>$ cp .config ../busybox-static.config\n$ make install\n</code></pre> <p>Try to boot your new system on the board. You should now reach a command line prompt, allowing you to execute the commands of your choice.</p> picocomBBB - BusyBox<pre><code>    ...\ncan't run '/etc/init.d/rcS': No such file or directory\n\nPlease press Enter to activate this console.\n</code></pre> <p>You can press Enter to enter a root login shell. Ignore any warning messages for now.</p>"},{"location":"bbb/tinysystem/#virtual-filesystems","title":"Virtual filesystems","text":"<p>Within the target shell, run the <code>ps</code> command. You can see that it complains that the <code>/proc</code> directory does not exist. The <code>ps</code> command and other process-related commands use the <code>proc</code> virtual filesystem to get their information from the kernel.</p> picocomBBB - BusyBox<pre><code># ps\n  PID USER       VSZ STAT COMMAND\nps: can't open '/proc': No such file or directory\n</code></pre> <p>From the command line of the target, create the <code>proc</code>, <code>sys</code> and <code>etc</code> directories in your root filesystem:</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ mkdir proc sys etc\n</code></pre> <p>Now mount the <code>proc</code> virtual filesystem. Now that <code>/proc</code> is available, test again the <code>ps</code> command.</p> picocomBBB - BusyBox<pre><code># mount -t proc proc /proc\n# ps\n  PID USER       VSZ STAT COMMAND\n    1 0          512 S    /sbin/init\n    2 0            0 SW   [kthreadd]\n    3 0            0 IW&lt;  [rcu_gp]\n    4 0            0 IW&lt;  [rcu_par_gp]\n    5 0            0 IW&lt;  [netns]\n    ...\n</code></pre> <p>Note that you can also now halt your target with the <code>halt</code> command, thanks to <code>proc</code> being mounted. The <code>halt</code> command can find the list of mounted filesystems in <code>/proc/mounts</code>, and unmount them in a clean way before shutting down.</p> picocomBBB - BusyBox<pre><code># halt\nstarting pid 88, tty '': 'umount -a -r'\numount: devtmpfs busy - remounted read-only\nstarting pid 89, tty '': 'swapoff -a'\nswapoff: can't open '/etc/fstab': No such file or directory\nThe system is going down NOW!\nSent SIGTERM to all processes\nSent SIGKILL to all processes\nRequesting system halt\nreboot: System halted\n</code></pre> <p>You can now disconnect and turn off the board, this time more safely.</p>"},{"location":"bbb/tinysystem/#system-configuration-and-startup","title":"System configuration and startup","text":"<p>The first user space program that gets executed by the kernel is <code>/sbin/init</code>, whose configuration file is <code>/etc/inittab</code>.</p> <p>In the BusyBox sources, read details about <code>/etc/inittab</code> in the <code>examples/inittab</code> file (press Q to quit from <code>less</code>). Let's create it from the example template; we'll tweak it soon.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ less ../busybox/examples/inittab\n$ cp ../busybox/examples/inittab etc/inittab\n$ nano etc/inittab\n</code></pre> <p>Comment out any getty respawn from <code>etc/inittab</code>, otherwise those shells would keep respawning in our emulated board. Save (Ctrl+O) and exit (Ctrl+X).</p> File: $LAB_PATH/nfsroot/etc/inittab - respawning getty commented out<pre><code>    ...\n# /sbin/getty invocations for selected ttys\n#tty4::respawn:/sbin/getty 38400 tty5\n#tty5::respawn:/sbin/getty 38400 tty6\n...\n</code></pre> <p>If you enter the login shell after startup, you should get an annoying message:</p> picocomBBB - BusyBox<pre><code>Please press Enter to activate this console.\nstarting pid 59, tty '': '-/bin/sh'\nBusyBox v1.35.0 (2023-05-02 22:18:33 CEST) built-in shell (ash)\nEnter 'help' for a list of built-in commands.\n-/bin/sh: can't access tty; job control turned off\n#\n</code></pre> <p>Without job control, we cannot manage jobs, like termination via Ctrl+C. A quick way is to force <code>ttyS0</code> (the emulated board debug serial port) as the default login shell:</p> File: $LAB_PATH/nfsroot/etc/inittab - forced login shell device<pre><code>    ...\n# Start an \"askfirst\" shell on the console (whatever that may be)\nttyS0::askfirst:-/bin/sh\n    ...\n</code></pre> <p>TODO: Use some command line tools to comment out the above lines.</p> <p>Create the standard <code>/etc/init.d/rcS</code> startup script, to mount the <code>/proc</code> and <code>/sys</code> filesystems.</p> File: $LAB_PATH/nfsroot/etc/init.d/rcS<pre><code>#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\n</code></pre> <p>Quick typing from the shell:</p> <pre><code>$ mkdir -p etc/init.d/\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nEOF\n$ chmod +x etc/init.d/rcS\n</code></pre> <p>Try again by restarting the board, and you can notice that those warning messages are now gone.</p> picocomBBB - BusyBox<pre><code>VFS: Mounted root (nfs filesystem) on device 0:16.\ndevtmpfs: mounted\nFreeing unused kernel image (initmem) memory: 1024K\nRun /sbin/init as init process\nstarting pid 77, tty '': '/etc/init.d/rcS'\nPlease press Enter to activate this console.\nstarting pid 80, tty '/dev/ttyS0': '-/bin/sh'\nBusyBox v1.35.0 (2023-05-02 22:25:02 CEST) built-in shell (ash)\nEnter 'help' for a list of built-in commands.\n#\n</code></pre> <p>You can keep the board running for the next paragraphs. We're going to change files on-the-fly; those changes can be accessed directly from the board via NFS.</p> <p>You might want to backup the current <code>nfsroot</code>. We're going to use <code>cpio</code> to preserve symlinks.</p> <pre><code>$ cd $LAB_PATH/nfsroot/\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-static.cpio.xz\"\n</code></pre>"},{"location":"bbb/tinysystem/#switching-to-shared-libraries","title":"Switching to shared libraries","text":"<p>Take the <code>hello.c</code> program supplied in the lab <code>data</code> directory. Cross-compile it for ARM, dynamically-linked with the libraries (just use our <code>arm-linux</code> toolchain), and run it on the target. You should face a very misleading <code>not found</code> error, which is not because the <code>hello</code> executable is not found, but because something else was not found while trying to execute this executable.</p> <pre><code>$ cd $LAB_PATH/data/\n$ arm-linux-gcc -o hello hello.c\n$ cp hello ../nfsroot/bin/\n</code></pre> picocomBBB - BusyBox<pre><code># hello\n-/bin/sh: hello: not found\n</code></pre> <p>It\u2019s missing the <code>ld-uClibc.so.0</code> executable, which is the dynamic linker required to execute any program compiled with shared libraries. Using the <code>find</code> command, look for any library files in the toolchain install directory, and copy them to the <code>lib/</code> directories on the target. We're going to use a regex to find all the matches for possible shared object file name extensions. Also copy any binary executables (like <code>ldd</code>) to their respective fodlers.</p> <pre><code>$ cd \"$TC_BASE/$TC_NAME/sysroot/\"\n$ so_regex=\".+\\.so\\(\\.[0-9]+\\)*\"\n$ find . -regex $so_regex | sort\n./lib/ld-uClibc-1.0.39.so\n./lib/ld-uClibc.so.0\n./lib/ld-uClibc.so.1\n./lib/libatomic.so\n./lib/libatomic.so.1\n./lib/libatomic.so.1.2.0\n./lib/libc.so.0\n./lib/libc.so.1\n./lib/libgcc_s.so\n./lib/libgcc_s.so.1\n./lib/libitm.so\n./lib/libitm.so.1\n./lib/libitm.so.1.0.0\n./lib/libstdc++.so\n./lib/libstdc++.so.6\n./lib/libstdc++.so.6.0.29\n./lib/libthread_db-1.0.39.so\n./lib/libthread_db.so.1\n./lib/libuClibc-1.0.39.so\n./usr/lib/libc.so\n./usr/lib/libthread_db.so\n$ mkdir -p \"$LAB_PATH/nfsroot/lib/\"\n$ mkdir -p \"$LAB_PATH/nfsroot/usr/lib/\"\n$ mkdir -p \"$LAB_PATH/nfsroot/sbin/\"\n$ mkdir -p \"$LAB_PATH/nfsroot/usr/sbin/\"\n$ cp lib/libc.so* \"$LAB_PATH/nfsroot/lib/\"\n$ cp lib/ld-uClibc.so* \"$LAB_PATH/nfsroot/lib/\"\n$ cp usr/bin/ldd \"$LAB_PATH/nfsroot/usr/bin/\"\n</code></pre> <p>Now <code>hello</code> works as expected, and you can also execute <code>ldd</code> against it to see the library dependencies:</p> picocomBBB - BusyBox<pre><code># hello\nHello world!\n# ldd bin/hello\n        libc.so.0 =&gt; /lib/libc.so.0 (0xb6f04000)\n        ld-uClibc.so.1 =&gt; /lib/ld-uClibc.so.0 (0xb6f8b000)\n# ldd bin/busybox\n        not a dynamic executable\n</code></pre> <p>If you still get the same error message, work, just try again a few seconds later. Such a delay can be needed because the NFS client can take a little time (at most 30-60 seconds) before seeing the changes made on the NFS server.</p> <p>Once the small test program works, we're going to recompile BusyBox without the static compilation option, so that BusyBox takes advantages of the shared libraries that are now present on the target. Before doing that, measure the size of the busybox executable.</p> <pre><code>$ cd $LAB_PATH\n$ du -h nfsroot/bin/busybox\n356K    nfsroot/bin/busybox\n$ cd busybox/\n$ make menuconfig\n</code></pre> <p>In <code>Settings</code>:</p> <ul> <li>Disable <code>Build static binary (no shared libs)</code> (<code>STATIC</code>)</li> </ul> <p>Now <code>halt</code> and quit QEMU, backup the new configuration, and build BusyBox again. As you will see, the executable is now smaller, because it's using shared libraries.</p> <pre><code>$ cp .config ../busybox-dynamic.config\n$ make clean\n$ make install\n$ du -h ../nfsroot/bin/busybox\n212K    ../nfsroot/bin/busybox\n</code></pre> <p>Restart the board, reaching the BusyBox shell successfully. You can confirm that the current <code>busybox</code> executable depends on shared libraries:</p> picocomBBB - BusyBox<pre><code># ldd bin/busybox\n        libc.so.0 =&gt; /lib/libc.so.0 (0xb6eb0000)\n        ld-uClibc.so.1 =&gt; /lib/ld-uClibc.so.0 (0xb6f37000)\n</code></pre>"},{"location":"bbb/tinysystem/#implement-a-web-interface-for-your-device","title":"Implement a web interface for your device","text":"<p>Replicate <code>$LAB_PATH/data/www/</code> to the <code>/www</code> directory in your target root filesystem.</p> <pre><code>$ cd $LAB_PATH\n$ cp -r data/www/ nfsroot/\n</code></pre> <p>Then, run the BusyBox http server from the BusyBox shell; it will automatically background itself.</p> picocomBBB - BusyBox<pre><code># /usr/sbin/httpd -h /www/\n</code></pre> <p>Now, test that your web interface works well by opening http://192.168.0.69/index.html within the host machine (Lubuntu VM).</p> <p>See how the dynamic pages are implemented. Very simple, isn\u2019t it?</p> <p>If you use a proxy, configure your host browser so that it doesn\u2019t go through the proxy to connect to the target IP address, or simply disable proxy usage.</p> <p>Finish by adding the command that starts the web server to your startup script, so that it is always started on your target.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ echo \"/usr/sbin/httpd -h /www/\" &gt;&gt; etc/init.d/rcS\n</code></pre> <p>You can <code>reboot</code> BusyBox and see that the web server was started automatically (press Ctrl+C to quit <code>top</code>). You can then <code>halt</code> the board.</p> picocomBBB - BusyBox<pre><code># top\nMem: 14136K used, 104336K free, 0K shrd, 0K buff, 868K cached\nCPU:  0.5% usr  1.5% sys  0.0% nic 97.9% idle  0.0% io  0.0% irq  0.0% sirq\nLoad average: 0.00 0.00 0.00 1/59 66\n  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND\n   66    62 0        R     1016  0.8   0  1.7 top\n   31     2 0        IW       0  0.0   0  0.3 [kworker/0:1-eve]\n    1     0 0        S     1016  0.8   0  0.0 /sbin/init\n   63     1 0        S     1016  0.8   0  0.0 /sbin/init\n   64     1 0        S     1016  0.8   0  0.0 /sbin/init\n   65     1 0        S     1016  0.8   0  0.0 /sbin/init\n   62     1 0        S     1012  0.8   0  0.0 -/bin/sh\n   61     1 0        S     1008  0.8   0  0.0 /usr/sbin/httpd -h /www/\n    8     2 0        IW       0  0.0   0  0.0 [kworker/u8:0-nf]\n   10     2 0        SW       0  0.0   0  0.0 [ksoftirqd/0]\n   11     2 0        IW       0  0.0   0  0.0 [rcu_sched]\n   55     2 0        IW&lt;      0  0.0   0  0.0 [kworker/u9:2-xp]\n   41     2 0        IW&lt;      0  0.0   0  0.0 [kworker/u9:0-xp]\n   46     2 0        IW       0  0.0   0  0.0 [kworker/0:2-eve]\n   29     2 0        SW       0  0.0   0  0.0 [kdevtmpfs]\n   35     2 0        SW       0  0.0   0  0.0 [kcompactd0]\n   43     2 0        IW       0  0.0   0  0.0 [kworker/u8:2-ev]\n    2     0 0        SW       0  0.0   0  0.0 [kthreadd]\n   38     2 0        IW       0  0.0   0  0.0 [kworker/u8:1-nf]\n    6     2 0        IW       0  0.0   0  0.0 [kworker/0:0-eve]\n</code></pre>"},{"location":"bbb/tinysystem/#backup-and-restore","title":"Backup and restore","text":"<p>Everything looks fine now, so you're free to make a backup archive of the dynamic <code>nfsroot</code>:</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-dynamic.cpio.xz\"\n</code></pre> <p>In case you wish to restore the snapshot:</p> <pre><code>$ cd $LAB_PATH\n$ rm -rf nfsroot/\n$ mkdir -p nfsroot/\n$ xzcat nfsroot-dynamic.cpio.xz | cpio -iduv -D nfsroot/\n</code></pre>"},{"location":"bbb/tinysystem/#boot-with-initramfs","title":"Boot with initramfs","text":"<p>It's usual to run an initramfs instead of a boot from NFS: the initramfs copies data from the SD card into RAM, and executes a preliminary boot from there.</p> <p>FYI: https://landley.net/writing/rootfs-howto.html</p> <p>Configure your kernel to include the contents of the <code>nfsroot</code> directory as an initramfs image archive file <code>/initrd.cpio.gz</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ export ARCH=arm\n$ make menuconfig\n$ cp .config \"$LAB_PATH/kernel-initramfs.config\"\n</code></pre> <p>In <code>General setup</code>:</p> <ul> <li> <p>Enable <code>Initial RAM filesystem and RAM disk (initramfs/initrd) support</code> (<code>BLK_DEV_INITRD</code>)</p> </li> <li> <p>Set <code>Initramfs source file(s)</code> (<code>INITRAMFS_SOURCE</code>) = <code>../../tinysystem/nfsroot</code>.</p> </li> <li> <p>Enable <code>Support initial ramdisk/ramfs compressed using gzip</code> (<code>RD_GZIP</code>).</p> </li> </ul> <p>Now <code>&lt;Save&gt;</code> the <code>.config</code> and save a backup copy.</p> <p>Before building and running the updated kernel, in the toplevel directory you have to create an <code>/init</code> link pointing to <code>/sbin/init</code>. This is required because the kernel will try to execute the <code>/init</code> executable \u2014 we simply redirect it to the standard one. You can then archive your initrams image archive.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ ln -s sbin/init init\n</code></pre> <p>You should also mount <code>devtmpfs</code> from the <code>/etc/init.d/rcS</code> script, because it cannot be mounted automatically by the kernel when booting from an initramfs.</p> <pre><code>$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t devtmpfs dev /dev\n/usr/sbin/httpd -h /www/\nEOF\n</code></pre> <p>You can now rebuild the kernel, <code>make</code> will take care of the changes to rebuild. Copy the newly generated kernel image to the TFTP server. You can see the difference in size between the two <code>zImage</code> versions, since initramfs includes our <code>nfsroot</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ make\n    ...\n  Kernel: arch/arm/boot/zImage is ready\n$ mv /srv/tftp/zImage /srv/tftp/zImage-without-initramfs\n$ cp arch/arm/boot/zImage /srv/tftp/zImage-with-initramfs\n$ cp arch/arm/boot/zImage /srv/tftp/zImage\n$ du -h /srv/tftp/zImage*\n5.4M    /srv/tftp/zImage\n5.4M    /srv/tftp/zImage-with-initramfs\n4.7M    /srv/tftp/zImage-without-initramfs\n</code></pre> <p>You can now reboot your board, which this time is booting the kernel from initramfs instead of NFS. You won\u2019t need to modify your <code>root=/srv/nfs</code> setting in the kernel command line (<code>bootargs</code>), because it will just be ignored for an initramfs.</p> picocomBBB - BusyBox<pre><code>    ...\nFreeing unused kernel image (initmem) memory: 2048K\nRun /init as init process\nPlease press Enter to activate this console.\n</code></pre> <p>Let's archive the current state for the future.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-initramfs.cpio.xz\"\n$ cd /srv/tftp\n$ tar cfJv \"$LAB_PATH/zImage-initramfs.tar.xz\" zImage\n</code></pre> <p>In case you wish to restore the snapshot:</p> <pre><code>$ cd $LAB_PATH\n$ rm -rf nfsroot/\n$ mkdir -p nfsroot/\n$ xzcat nfsroot-initramfs.cpio.xz | cpio -iduv -D nfsroot/\n$ tar xfv zImage-initramfs.tar.xz\n$ mv zImage /srv/tftp\n</code></pre> <p>Now go back to booting the system through NFS, which is more convenient for these labs: an initiramfs requires to be rebuilt for each change in your root filesystem, while NFS does it automatically.</p> <pre><code>$ cp /srv/tftp/zImage-without-initramfs /srv/tftp/zImage\n</code></pre> <p>At reboot it should complain about <code>/dev</code> being busy, as we're trying to mount it twice with the updated <code>rcS</code> script; just ignore this message.</p>"},{"location":"bbb/tinysystem/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/toolchain/","title":"Building a cross-compile toolchain","text":""},{"location":"bbb/toolchain/#objectives","title":"Objectives","text":"<p>After this lab, you will be able to:</p> <ul> <li> <p>Configure the crosstool-NG tool.</p> </li> <li> <p>Execute crosstool-NG and build up your own cross-compiling toolchain.</p> </li> </ul>"},{"location":"bbb/toolchain/#required-tools","title":"Required tools","text":"<ul> <li> <p>Ubuntu packages:</p> <p><code>autoconf</code> <code>bison</code> <code>build-essential</code> <code>flex</code> <code>gawk</code> <code>git</code> <code>help2man</code> <code>libncurses-dev</code> <code>libtool-bin</code> <code>qemu-user</code> <code>texinfo</code> <code>unzip</code> <code>wget</code> <code>xz-utils</code></p> </li> <li> <p>crosstool-NG, either from:</p> <ul> <li> <p>GitHub repository</p> </li> <li> <p>Source code archive of commit <code>7622b490</code></p> </li> </ul> </li> </ul>"},{"location":"bbb/toolchain/#source-code","title":"Source code","text":"<p>First, install some packages required for compilation:</p> <pre><code>$ sudo apt install \\\nautoconf bison build-essential cpio flex gawk git help2man \\\nlibncurses-dev libtool-bin texinfo unzip wget xz-utils\n</code></pre> <p>Enter the folder of this lab, that's going to become our main workspace folder:</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-bbb-labs/toolchain\"\n$ cd $LAB_PATH\n</code></pre> <p>You can now get crosstool-NG at the suggested version (git commit <code>7622b490</code>).</p> <p>We're going to clone the git repository into the home folder, creating a new branch named after the embedded-linux-bbb tutorial just for convenience.</p> <pre><code>$ git clone \"https://github.com/crosstool-ng/crosstool-ng\"\n$ cd crosstool-ng/\n$ label=\"7622b490\"\n$ git checkout -b embedded-linux-bbb ${label}\n</code></pre> <p>Alternatively, you can directly unpack an archive of the suggested version. This is usually much faster than cloning a big git repository, despite losing all the features of a git repository.</p> <pre><code>$ label=\"7622b490a359f6cc6b212859b99d32020a8542e7\"\n$ wget \"https://github.com/crosstool-ng/crosstool-ng/archive/${label}.zip\"\n$ unzip \"${label}.zip\"\n$ mv crosstool-ng*/ crosstool-ng\n</code></pre> <p>See: git commit hash expansion</p>"},{"location":"bbb/toolchain/#bootstrap","title":"Bootstrap","text":"<p>Now that the source code is available, its content requires some initial setup to become available. The local <code>bootstrap</code> executable takes care of this initial setup.</p> <pre><code>$ cd $LAB_PATH/crosstool-ng/\n$ ./bootstrap\n</code></pre> <p>We're going to compile and install everything locally, so you must configure the code base for that, via the canonical <code>configure</code> executable. To improve compile time from now on, let's provide the number of processors to <code>make</code>.</p> <pre><code>$ export MAKEFLAGS=-j$(nproc)\n$ ./configure --enable-local\n$ make\n</code></pre> <p>From now on, the generated <code>ct-ng</code> executable is our main command for the toolchain generation.</p>"},{"location":"bbb/toolchain/#configuration","title":"Configuration","text":"<p>A single installation of crosstool-NG allows to produce as many toolchains as you want, for different architectures, with different C libraries and different versions of the various components.</p> <p>crosstool-NG comes with a set of ready-made configuration files for various typical setups, called samples. They can be listed by calling the <code>list-samples</code> command.</p> <p>We're going to load the sample for the ARM Cortex A9 processor, so let's filter the results:</p> <pre><code>$ ./ct-ng list-samples | grep a8\n[L...]   arm-cortex_a8-linux-gnueabi\n</code></pre> <p>Our target sample is <code>arm-cortexa9_neon-linux-gnueabihf</code>, so let's configure for it, generating a <code>.config</code> file:</p> <pre><code>$ ./ct-ng arm-cortex_a8-linux-gnueabi\n    ...\nNow configured for \"arm-cortex_a8-linux-gnueabi\"\n</code></pre> <p>We can refine the configuration via a useful user interface called <code>menuconfig</code>:</p> <pre><code>$ ./ct-ng menuconfig\n</code></pre> <p>See: <code>menuconfig</code></p> <p>In <code>Path and misc options</code>:</p> <ul> <li> <p>To resume a failed compilation, enable the following options.   Without these, you have to restart the whole compilation from scratch, which usually takes a long time.</p> <ul> <li>Enable <code>Debug crosstool-NG</code> (<code>DEBUG_CT</code>)</li> <li>Enable <code>Save intermediate steps</code> (<code>CT_DEBUG_CT_SAVE_STEPS</code>)</li> <li>Enable <code>gzip saved states</code> (<code>CT_DEBUG_CT_SAVE_STEPS_GZIP</code>)</li> <li>Enable <code>Interactive shell on failed commands</code> (<code>CT_DEBUG_INTERACTIVE</code>)</li> </ul> </li> <li> <p>Set <code>Number of parallel jobs</code> (<code>CT_PARALLEL_JOBS</code>) = number of processors.   This improves the performance of the building pipeline.</p> </li> <li> <p>Set <code>Maximum log level to see:</code> (<code>LOG_DEBUG</code>) = <code>DEBUG</code>.   This way we can have more details on what happened during the build in case something went wrong.   This isn't strictly required, and might produce too many messages. I'm keeping it to <code>EXTRA</code> actually.</p> </li> </ul> <p>In <code>Debug facilities</code>:</p> <ul> <li>Remove all the options here.   Some debugging tools can be provided in the toolchain, but they can also be built by filesystem building tools. Do this before anything else: removing features often messes up elsewhere (IPv6 and WCHAR for example)!</li> </ul> <p>In <code>Target options</code>:</p> <ul> <li> <p>Set <code>Use specific FPU</code> (<code>ARCH_FPU</code>) = <code>vfpv3</code>.</p> </li> <li> <p>Set <code>Floating point</code> to <code>hardware (FPU)</code> (<code>CT_ARCH_FLOAT_HW</code>).</p> </li> </ul> <p>In <code>Toolchain options</code>:</p> <ul> <li> <p>Set <code>Tuple's vendor string</code> (<code>TARGET_VENDOR</code>) = <code>training</code>.</p> </li> <li> <p>Set <code>Tuple's alias</code> (<code>TARGET_ALIAS</code>) = <code>arm-linux</code>.   This way, we will be able to use the compiler as <code>arm-linux-gcc</code> instead of  <code>arm-training-linux-uclibcgnueabihf-gcc</code>, which is much longer to type.</p> </li> </ul> <p>In <code>Operating System</code>:</p> <ul> <li>Set <code>Version of linux</code> = <code>5.15.x</code> version that is proposed.   We choose this version because this matches the version of the kernel we will run on the board.   At least, the version of the kernel headers are not more recent (which might be incompatible).</li> </ul> <p>In <code>C-library</code>:</p> <ul> <li> <p>Set <code>C library</code> (<code>LIBC_UCLIBC_NG</code>) = <code>uClibc-ng</code>.</p> </li> <li> <p>Keep the default version that is proposed.</p> </li> <li> <p>Enable <code>Add support for IPv6</code> (<code>LIBC_UCLIBC_IPV6</code>), required by Buildroot.</p> </li> <li> <p>Enable <code>Add support for WCHAR</code> (<code>LIBC_UCLIBC_WCHAR</code>), required by Buildroot.</p> </li> <li> <p>Enable <code>Support stack smashing protection (SSP)</code> (<code>LIBC_UCLIBC_HAS_SSP</code>), required by Buildroot.</p> </li> </ul> <p>In <code>C compiler</code>:</p> <ul> <li> <p>Set <code>Version of gcc</code> = <code>11.3.0</code>.   We need to stick to GCC 11.x, because Buildroot 2022.02 (which we are going to use later) doesn't support GCC 12.x toolchains yet (released after).</p> </li> <li> <p>Enable <code>C++</code> (<code>CC_LANG_CXX</code>).</p> </li> </ul> <p>Do cross-check everything now! It can happen that, when changing feature states, some overlooked dependency chains mess up with the configuration! For example:</p> <p>defconfig <code>arm-cortex_a8-linux-gnueabi</code> \u21d2 <code>DEBUG_GDB=y</code> \u21d2 <code>LIBC_UCLIBC_IPV6=y</code></p> <p>So, it looked like IPv6 support was ok. But, after removing <code>gdb</code> (<code>DEBUG_GDB=n</code>) from the <code>Debug facilities</code>:</p> <p><code>DEBUG_GDB=n</code> \u21d2 <code>LIBC_UCLIBC_IPV6=n</code></p> <p>We could have forced <code>LIBC_UCLIBC_IPV6=y</code> by pressing Y even if it looked automatically enabled (marked with <code>-*-</code>), but I've found no easy visual feedback to ensure that. So, cross-checking before leaving is strongly encouraged! I've lost a lot of time re-building the toolchain because of overlooking these naiveities, just because Buildroot slammed errors in my face so late!</p> <p>You can now <code>&lt;Save&gt;</code> this configuration to the default <code>.config</code> file.</p> <p>It's best to save a back-up copy as well:</p> <pre><code>$ cp .config ../crosstool-ng.config\n</code></pre> <p>You'd better also create the <code>~/src/</code> folder, where crosstool-NG stores the downloaded tarballs by default. It's handy to store them in case of any errors or cleanup, to avoid repeated downloads.</p> <pre><code>$ mkdir -p ~/src/\n</code></pre>"},{"location":"bbb/toolchain/#build","title":"Build","text":"<p>Run the <code>build</code> command:</p> <pre><code>$ ./ct-ng build\n</code></pre> <p>The build takes quite a long time to perform \u2014 a clean build took around 50 minutes on an Intel i7 7700 laptop with 4 cores, of course within the Lubuntu VM. It requires a stable internet connection.</p> <p>In case of any errors, the interactive error shell can help to resume compilation from the failed step. Possible errors might occur because of an unstable connection, or because the VM was provided a small amount of RAM (suggested \u2265 4 GB).</p> <p>The toolchain is installed by default under <code>~/x-tools/</code>. In our example: <code>~/x-tools/arm-training-linux-uclibcgnueabihf/</code>. That's something you could have changed in the configuration of crosstool-NG.</p>"},{"location":"bbb/toolchain/#backup-and-restore","title":"Backup and restore","text":"<p>It's best to save an archive of the generated toolchain, because building times can be very long. Let's archive it into the folder of the current lab.</p> <p>We're going to use <code>cpio</code> instead of the common <code>tar</code> to preserve symlinks as they are within the filesystem.</p> <p>FYI: https://linuxconfig.org/how-to-create-and-extract-cpio-archives-on-linux-examples</p> <pre><code>$ pushd .\n$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ cd $TC_BASE/..\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/${TC_NAME}.cpio.xz\"\n$ popd\n</code></pre> <p><code>pushd</code>/<code>popd</code> allow to push/pop the current directory (<code>pwd</code>) against the directory stack (<code>dirs</code>).</p> <p>To restore it under <code>~/x-tools/</code>, just unpack the backup archive there:</p> <pre><code>$ cd $LAB_PATH\n$ sudo rm -rf $TC_BASE\n$ mkdir -p \"$HOME/x-tools/\"\n$ xzcat \"${TC_NAME}.cpio.xz\" | cpio -iduv -D \"$HOME/x-tools/\"\n</code></pre>"},{"location":"bbb/toolchain/#quick-test","title":"Quick test","text":"<p>The toolchain can be called by adding the generated <code>bin</code> folder to your <code>PATH</code> environment variable.</p> <pre><code>$ export PATH=\"$TC_BASE/bin:$PATH\"\n</code></pre> <p>You can now compile the simple <code>hello.c</code> with our new shiny <code>arm-linux-gcc</code> shorthand:</p> <pre><code>$ cd $LAB_PATH\n$ arm-linux-gcc -o hello hello.c\n</code></pre> <p>You can use the <code>file</code> command on your binary to make sure it has correctly been compiled for the ARM architecture.</p> <pre><code>$ file hello\nhello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, not stripped\n</code></pre> <p>Did you know that you can still execute this binary from your x86 host? To do this, install the QEMU user emulator, which just emulates target instruction sets, not an entire system with devices.</p> <pre><code>$ sudo apt install qemu-user\n</code></pre> <p>Try to run QEMU with the <code>hello</code> executable generated with our toolchain:</p> <pre><code>$ qemu-arm hello\nqemu-arm: Could not open '/lib/ld-uClibc.so.0': No such file or directory\n</code></pre> <p>What's happening is that <code>qemu-arm</code> is missing the shared C library (compiled for ARM) that this binary uses. Let's find it in our newly compiled toolchain:</p> <pre><code>$ find ~/x-tools/ -name ld-uClibc.so.0\n/home/me/x-tools/arm-training-linux-uclibcgnueabihf/arm-training-linux-uclibcgnueabihf/sysroot/lib/ld-uClibc.so.0\n</code></pre> <p>We can now use the <code>-L</code> option of <code>qemu-arm</code> to let it know where shared libraries are:</p> <pre><code>$ qemu-arm -L \"$TC_BASE/$TC_NAME/sysroot/\" hello\nHello world!\n</code></pre>"},{"location":"bbb/toolchain/#cleaning-up","title":"Cleaning up","text":"<p>To save about 11 GB of storage space, run the <code>clean</code> command in the crosstool-NG source directory.</p> <pre><code>$ ./ct-ng clean\n</code></pre> <p>This removes the source code of the toolchain components, as well as all the generated files that are now useless, since the toolchain has been installed in <code>~/x-tools</code>, and we made a back-up archive.</p> <p>Do this only if you have limited storage space. In case you made a mistake in the toolchain configuration, you may need to run crosstool-NG again to rebuild everything form scratch \u2014 keeping generated files would save a significant amount of time.</p>"},{"location":"bbb/toolchain/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - BeagleBone Black Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"bbb/virtualbox/","title":"Host VM","text":"<p>TODO: THIS DOCUMENT IS STILL JUST A DRAFT FROM THE QEMU VARIANT!</p> <p>I chose to use a virtual machine as the host machine, so that I won't mess with my physical machines. Moreover, I can bring it around on an USB hard disk!</p> <p>I chose VirtualBox as my VM, simply because it's a freely available VM I've used for a long time. My current version is 7.0.6, but it shouldn't matter much as far as I know. I installed this VirtualBox on several Windows 10 machines successfully; this is the VM host OS.</p> <p>As the VM guest OS I chose Lubuntu 22.04 LTS. I know that many prefer a standard Debian, but I find Ubuntu easier to setup \u2014 I don't want to waste too much time configuring  the host machine.</p> <p>Lubuntu is rather lightweight and quick, with no frills, while still being an officially supported Linux distro.</p> <p>The LTS was chosen because it's in the middle of its planned life, so it's mature enough to get stable results for enough time.</p> <p>Furthermore, 22.04 LTS is officially supported by several tools and frameworks, including Yocto.</p>"},{"location":"bbb/virtualbox/#required-tools","title":"Required Tools","text":"<ul> <li> <p>VirtualBox 7.0.6   or later</p> </li> <li> <p>Lubuntu 22.04 LTS (Jammy Jellyfish)   or another Ubuntu 22.04 LTS</p> </li> <li> <p>Training lab data</p> </li> </ul>"},{"location":"bbb/virtualbox/#vm-guest-os-installation","title":"VM guest OS installation","text":"<p>First, install VirtualBox, which should be very straightforward.</p> <p>Then, create a new virtual machine.</p> <p>Important VM specs:</p> <ul> <li> <p>Hard Disk \u2265 32 GB</p> <ul> <li>Dynamically allocated is fine</li> <li>Enable <code>Use Host I/O cache</code> to avoid hiccups</li> </ul> </li> <li> <p>CD drive with the Lubuntu ISO file as a <code>Live CD/DVD</code></p> </li> <li> <p>RAM \u2265 4 GB</p> <ul> <li>With less RAM, some toolchains might get stuck in swap hell</li> </ul> </li> <li> <p>Processors = number of physical CPU cores</p> <ul> <li>VM host OS still usable</li> <li>good performance</li> <li>might not leverage hyperthreading</li> <li>I'm using <code>Enable PAE/NX</code> as an added bonus</li> <li>suggested \u2265 4 physical cores of the host machine</li> </ul> </li> <li> <p>Network via NAT</p> <ul> <li>No need for a proper network as with physical boards</li> </ul> </li> </ul> <p>Launch the VM and wait for it to load the Live OS straight from the emulated DVD drive.</p> <p>When available, let's run the installer from the desktop. No particular options have to be set, so leave the defauit ones if in doubt.</p> <p>When prompted for formatting options, just let the installer format the whole partition with swap on file.</p> <p>When asked for names and passwords, I'd opt for covnenience:</p> <ul> <li>Machine name: <code>vm</code></li> <li>User name: <code>me</code></li> <li>Password: none</li> <li>Automatic login: enabled</li> </ul> <p>After a few minutes the installer should have terminated, and the VM can be restarted to enter the installed VM guest OS.</p>"},{"location":"bbb/virtualbox/#vm-guest-os-configuration","title":"VM guest OS configuration","text":"<p>Once the installed VM guest OS is run, it should install any updates from the internet.</p> <p>For shell commands I typically use the default terminal application provided by the OS. In the case of Lubuntu, it's QTerminal, which can be accessed either via the start menu, or by pressing Ctrl+Alt+T.</p> <p>So, let's update the system, with the canonical commands for Debian-based Linux distros:</p> <pre><code>$ sudo apt update\n$ sudo apt dist-upgrade\n</code></pre> <p>It most probably installed some Linux kernel updates, so let's reboot to make changes effective:</p> <pre><code>$ sudo reboot\n</code></pre> <p>This time it's best to add VirtualBox Guest Additions for the best VM experience.</p> <p>From the <code>Devices</code> menu, select <code>Insert Guest Additions CD Image...</code>. Ignore any automatic actions; we're going to install them from the shell:</p> <pre><code>$ cd /media/me/VBox_GAs_7.0.6/\n$ sudo ./VBoxLinuxAdditions.run\n</code></pre> <p>You can usually type <code>cd /media</code> and press the Tab key repeatedly for automatic completion; the same for the run script.</p> <p>If you double-press Tab, the shell prints some suggestions. It's often handy to click the desired suggestion with the central mouse button to automatically append it to the command line.</p> <p>After the installation has finished, it's best to reboot again.</p> <p>You're now free to resize the window, or enter seamless mode. I usually select the latter, so that I can open a PDF in the host OS, and superimpose Lubuntu shell windows seamlessly.</p>"},{"location":"bbb/virtualbox/#networking","title":"Networking","text":"<p>The Bootlin course relies on the virtual Ethernet provided by the BBB. This allows the course support both the standard BeagleBone Black, as well as the BeagleBone Black Wireless.</p> <p>Instead, this personal variant of the course adopts just the standard BBB, so I'm allowed to use the dedicated RJ45 Ethernet connection, which is more akin to an actual connected product. This requires some more setup on the host side, because the BBB is going to be an actual member of our local network, as well as the VM guest OS.</p> <p>The conventions for this tutorial are the following:</p> <ul> <li>Network mask: <code>255.255.255.0</code> = <code>/24</code>, the 24 most significant bits.</li> <li>Host machine IP: <code>192.168.0.15</code>, the VM guest OS.</li> <li>Target machine IP: <code>192.168.0.69</code>, the BeagleBone Black board.</li> </ul> <p>Of course, you're free to change them accordingly to your preferences and network availability \u2014 just avoid DHCP for our host and target machines!</p> <p>To help being more consistent across the course, I use some environment variables, so that you don't need to change too many command lines and scripts within the course itself.</p> <pre><code>$ NET_MASK=\"255.255.255.0\"\n$ NET_IP=\"192.168.0.0\"\n$ HOST_IP=\"192.168.0.15\"\n$ TARGET_IP=\"192.168.0.69\"\n</code></pre> <p>An important point is that you should change the VirtualBox guest network interface to be bridged, so that the VM guest OS acts as an actual node of your LAN.</p> <p>For Lubuntu VM, you can edit the network settings with the graphical Network Manager.</p> <p>Make sure your VM guest OS can reach the internet in a fast and reliable way.</p>"},{"location":"bbb/virtualbox/#training-lab-data","title":"Training lab data","text":"<p>You should retrieve the training lab data from its Bootlin page:</p> <pre><code>$ cd ~\n$ wget https://bootlin.com/doc/training/embedded-linux-bbb/embedded-linux-bbb-labs.tar.xz\n$ tar xfv embedded-linux-bbb-labs.tar.xz\n</code></pre> <p>You can give a quick look to the folder structure with the <code>tree</code> command:</p> <pre><code>$ tree ~/embedded-linux-bbb-labs/\n/home/me/embedded-linux-bbb-labs/\n\u251c\u2500\u2500 appdev\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 nunchuk-mpd-client.c\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 prep-debug.sh\n\u251c\u2500\u2500 bootloader\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 MLO\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 MLO-2022.07\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 u-boot-2022.07.img\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 u-boot.img\n\u251c\u2500\u2500 buildroot\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 mpd.conf\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 music\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 1-sample.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 2-arpent.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 3-chronos.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 4-land-of-pirates.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 5-ukulele-song.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 6-le-baguette.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 7-fireworks.ogg\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 README.txt\n\u251c\u2500\u2500 hardware\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 nunchuk\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 Makefile\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 nunchuk.c\n\u251c\u2500\u2500 tinysystem\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 busybox-1.35.config\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 hello.c\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 www\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cgi-bin\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 cpuinfo\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 list\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 reboot\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 upload\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 upload.c\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 upload.cfg\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2514\u2500\u2500 uptime\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 gohome.png\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 index.html\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 kshutdown.png\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 upload\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 BadPage.html\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 files\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 adult-small.png\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 brick.png\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 linux-blackfin.jpg\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 linux-kernel-dev-book.jpg\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u2514\u2500\u2500 lkn-small.jpg\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 OkPage.html\n\u2514\u2500\u2500 toolchain\n    \u2514\u2500\u2500 hello.c\n16 directories, 37 files\n</code></pre>"},{"location":"kb/git-hash/","title":"git commit hash expansion","text":"<p>Within the crosstool-NG tutorial we encountered a git commit <code>7622b490</code>. That code is a shorthand for the full commit hash number: <code>7622b490a359f6cc6b212859b99d32020a8542e7</code>.</p> <p>While the creation of a shorthand simply keeps the first letters (retaining hash unicity), the expansion requires some look-up to be performed.</p>"},{"location":"kb/git-hash/#local-repository","title":"Local repository","text":"<p>In case you have a local git repository, you can use the <code>rev-parse</code> command within it:</p> <pre><code>$ cd \"$HOME/embedded-linux-qemu-labs/toolchain/crosstool-ng/\"\n$ git rev-parse 7622b490\n7622b490a359f6cc6b212859b99d32020a8542e7\n</code></pre>"},{"location":"kb/git-hash/#github","title":"GitHub","text":"<p>In case the repository is hosted by GitHub, you can retrieve the full hash from the web pages.</p> <p>Open the main page of the specific commit:</p> <ul> <li>https://github.com/crosstool-ng/crosstool-ng/commits/7622b490</li> </ul> <p>By clicking on the shorthand of that entry, its URL gets expanded to the full hash code:</p> <ul> <li>https://github.com/crosstool-ng/crosstool-ng/commit/7622b490a359f6cc6b212859b99d32020a8542e7</li> </ul>"},{"location":"kb/menuconfig/","title":"<code>menuconfig</code>","text":"<p>The <code>menuconfig</code> is a common tool to assist the creation and editing of configuration files, usually named <code>.config</code>.</p> <p>It can:</p> <ul> <li>change options dynamically, depending on predicate evaluation;</li> <li>search for specific options via a handy search tool;</li> <li>check for option dependencies;</li> <li>import and export configuration files.</li> </ul> <p>It's typically accessed by entering the root folder of the source code, where a <code>Makefile</code> is capable of this tool (usually via <code>Kconfig</code>):</p> <pre><code>$ cd \"/source/code/path\"\n$ make menuconfig\n</code></pre>"},{"location":"kb/menuconfig/#keyboard","title":"Keyboard","text":"<p>Left and Right move the cursor within the lower horizontal action list. Enter applies the highlighted action entry.</p> <p>Up and Down move the cursor within the vertical main list. Space changes the highlighted main entry.</p> <p>Backspace acts as backspace within input text fields. If the key alone doesn't work, try with Ctrl+Backspace.</p> <p>Esc-Esc exits the current dialog.</p> <p>/ opens the search tool.</p> <p>Y/N/M changes the highlighted option to: enabled (<code>y</code>), disabled (<code>n</code>), module (<code>m</code>).</p> <p>Press the highlighted letter of menu entries to select them, or to activate the highlighed action.</p>"},{"location":"kb/menuconfig/#actions","title":"Actions","text":"<p><code>&lt;Select&gt;</code> selects the highlighted main entry.</p> <p><code>&lt;Exit&gt;</code> exits the current dialog.</p> <p><code>&lt;Help&gt;</code> shows information of the highlighted main entry: If on a configuration option, it shows its symbol and value (very useful!)</p> <p><code>&lt;Save&gt;</code> and <code>&lt;Load&gt;</code> are used to export/import a configuration file.</p>"},{"location":"kb/menuconfig/#search-tool","title":"Search tool","text":"<p>The search tool is called by typing / anywhere in the interface.</p> <p>This brings up a dialog where you can type the text to be searched, like a configuration symbol (e.g. <code>TARGET_ALIAS</code>).</p> <p>You can go to a listed match directly by typing its entry number (e.g. 1 for <code>(1)</code>), pushing a new dialog.</p> <p>After any changes, <code>Exit</code> to return to the search match list, where you can confrm that the value assigned is the expected one.</p> <p><code>Exit</code> again to return to the page before the search happened.</p>"},{"location":"kb/processors/","title":"Processors","text":"<p>It's useful to take advantage of a multi-core machine. The OS does it automatically, but most toolchains don't.</p> <p>An agnostic way to know the number of cores is via the <code>nproc</code> command from the <code>coreutils</code> Ubuntu package:</p> <pre><code>$ sudo apt install coreutils\n$ nproc\n</code></pre> <p>To let the GNU <code>make</code> command leverage the speedup opportunity, provide it via the <code>-j &lt;JOBS&gt;</code> command-line option (the space is optional), like in the following generic example:</p> <pre><code>$ make -j$(nproc)\n</code></pre> <p>Otherwise, declare the special environment variable named <code>MAKEFLAGS</code>, containing that option, to avoid typing it at every call to <code>make</code>:</p> <pre><code>$ export MAKEFLAGS=-j$(nproc)\n$ make\n</code></pre>"},{"location":"qemu/appdev/","title":"App - Development","text":""},{"location":"qemu/appdev/#objectives","title":"Objectives","text":"<ul> <li>Compile and run your own ncurses application on the target.</li> </ul>"},{"location":"qemu/appdev/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages: those from the previous labs.</p> </li> </ul>"},{"location":"qemu/appdev/#setup","title":"Setup","text":"<p>Go to the <code>$HOME/embedded-linux-qemu-labs/appdev</code> directory.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/appdev\"\n</code></pre>"},{"location":"qemu/appdev/#compile-your-own-application","title":"Compile your own application","text":"<p>In the lab directory, the file <code>app.c</code> contains a very simple ncurses application. It is a simple game where you need to reach a target using the arrow keys of your keyboard. We will compile and integrate this simple application to our Linux system.</p> <p>We will re-use the system built during the Buildroot lab and add to it our own application. Buildroot has generated toolchain wrappers in <code>output/host/bin</code>, which make it easier to use the toolchain, since these wrappers pass some mandatory flags (especially the <code>--sysroot</code> GCC flag, which tells GCC where to look for the headers and libraries).</p> <p>Let\u2019s add this directory to our <code>PATH</code>. NOTE: the Buildroot GCC wrappers MUST take priority over our toolchain, otherwise these wrappers won't be called!</p> <pre><code>$ export PATH=\"$HOME/embedded-linux-qemu-labs/buildroot/buildroot/output/host/bin:$PATH\"\n$ which arm-linux-gcc\n/home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/host/bin/arm-linux-gcc\n</code></pre> <p>Let\u2019s try to compile the application. It should complain about undefined references to some symbols. This is normal, since we didn\u2019t tell the compiler to link with the necessary libraries.</p> <pre><code>$ cd $LAB_PATH\n$ arm-linux-gcc -o app app.c\n    ...\napp.c:(.text+0x30): undefined reference to `initscr'\n    ...\ncollect2: error: ld returned 1 exit status\n</code></pre> <p>So, let\u2019s use <code>pkg-config</code> to query the pkgconfig database about the location of the header files and the list of libraries needed to build an application against <code>ncurses</code>. There's indeed a special <code>pkg-config</code> under <code>output/host/bin/</code> that automatically knows where to look, so it already knows the right paths to find <code>.pc</code> files and their sysroot.</p> <pre><code>$ which pkg-config\n/home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/host/bin/pkg-config\n$ pkg-config --libs --cflags ncurses\n-D_GNU_SOURCE -lncurses\n$ arm-linux-gcc -o app app.c $(pkg-config --libs --cflags ncurses)\n</code></pre> <p>Our application is now compiled! Copy the generated binary to the NFS root filesystem (in the <code>root/</code> directory for example), start your system, and run your application!</p> <pre><code>$ cp app \"$LAB_PATH/../buildroot/nfsroot/root/\"\n</code></pre> QEMU - Buildroot<pre><code># /root/app\n                                 Hello World!\n                                 X\n                                       O\nMove to the target (X), 'q' to quit\n</code></pre>"},{"location":"qemu/appdev/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ cd $LAB_PATH\n$ tar cfJv app.tar.xz app\n$ cd \"$LAB_PATH/../buildroot/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-appdev.cpio.xz\"\n</code></pre>"},{"location":"qemu/appdev/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/blockfs/","title":"Block Filesystems","text":""},{"location":"qemu/blockfs/#objectives","title":"Objectives","text":"<ul> <li> <p>Produce filesystem images.</p> </li> <li> <p>Configure the kernel to use these filesystems.</p> </li> <li> <p>Use the <code>tmpfs</code> filesystem to store temporary files.</p> </li> <li> <p>Load the kernel and DTB from a FAT partition.</p> </li> </ul> <p>After doing the BusyBox lab, we are going to copy the filesystem contents to the emulated SD card. The storage will be split into several partitions, and your QEMU emulated board will be booted from this SD card, without using NFS anymore.</p>"},{"location":"qemu/blockfs/#setup","title":"Setup","text":"<p>Throughout this lab, we will continue to use the root filesystem we have created in the <code>$HOME/embedded-linux-qemu-labs/tinysystem/nfsroot</code> directory, which we will progressively adapt to use block filesystems.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/tinysystem\"\n</code></pre>"},{"location":"qemu/blockfs/#filesystem-support-in-the-kernel","title":"Filesystem support in the kernel","text":"<p>Make sure that your kernel supports SquashFS (<code>SQUASHFS</code>) and ext4 (<code>EXT4_FS</code>). Basic configuration options for these filesystems will be sufficient; no need for things like extended attributes.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux\"\n$ grep -r \"\\bCONFIG_SQUASHFS\\b\" .config\nCONFIG_SQUASHFS=y\n$ grep -r \"\\bCONFIG_EXT4_FS\\b\" .config\nCONFIG_EXT4_FS=y\n</code></pre> <p>If necessary, recompile and update your kernel image on the TFTP server. We will only later copy the kernel to our FAT partition.</p> <p>Boot your board on the NFS filesystem you used in this previous lab. Now, check the contents of <code>/proc/filesystems</code>. You should see that ext4 and SquashFS are supported.</p> QEMU - BusyBox<pre><code># cat /proc/filesystems\nnodev   sysfs\nnodev   tmpfs\nnodev   bdev\nnodev   proc\nnodev   cgroup\nnodev   cgroup2\nnodev   cpuset\nnodev   devtmpfs\nnodev   tracefs\nnodev   sockfs\nnodev   pipefs\nnodev   ramfs\nnodev   rpc_pipefs\nnodev   devpts\n        ext3\n        ext4\n        ext2\n        cramfs\n        squashfs\n        vfat\nnodev   nfs\nnodev   jffs2\nnodev   9p\nnodev   ubifs\n</code></pre>"},{"location":"qemu/blockfs/#format-the-third-partition","title":"Format the third partition","text":"<p>We are going to format the third partition of the SD card image with the EXT4 filesystem, so that it can contain uploaded images.</p> <p>Setup the loop device again and format the third partition:</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ LOOP_DEV=$(sudo losetup -f --show --partscan sd.img)\n$ sudo mkfs.ext4 -L data \"${LOOP_DEV}p3\"\n    ...\n</code></pre> <p>Mount this partition on a directory on your host (you could create the <code>/mnt/www_upload_files</code> directory, for example) and move the contents of the <code>/www/upload/files</code> directory (in your target root filesystem) into it. The goal is to use the third partition of the SD card as the storage for the uploaded images. Finally, unmount the partition and free the allocated loop device.</p> <pre><code>$ mnt_path=\"/mnt/www_upload_files\"\n$ sudo mkdir -p $mnt_path\n$ sudo mount -t ext4 \"${LOOP_DEV}p3\" $mnt_path\n$ cd \"$LAB_PATH/nfsroot/www/upload/files/\"\n$ sudo cp -rv $(ls) $mnt_path\n'adult-small.png' -&gt; '/mnt/www_upload_files/adult-small.png'\n'brick.png' -&gt; '/mnt/www_upload_files/brick.png'\n'linux-blackfin.jpg' -&gt; '/mnt/www_upload_files/linux-blackfin.jpg'\n'linux-kernel-dev-book.jpg' -&gt; '/mnt/www_upload_files/linux-kernel-dev-book.jpg'\n'lkn-small.jpg' -&gt; '/mnt/www_upload_files/lkn-small.jpg'\n$ sudo umount $mnt_path\n$ sudo rmdir $mnt_path\n$ sudo losetup -d $LOOP_DEV\n</code></pre> <p>Now, restart QEMU and from the Linux command line mount this third partition on <code>/www/upload/files</code>.</p> QEMU - BusyBox<pre><code># ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\nlinux-blackfin.jpg\n# rm -rf /www/upload/files/*\n# mount -t ext4 /dev/mmcblk0p3 /www/upload/files/\nEXT4-fs (mmcblk0p3): mounted filesystem with ordered data mode. Opts: (null). Quota mode: disabled.\n# ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\nlinux-blackfin.jpg         lost+found\n</code></pre> <p>Once this works, modify the startup scripts in your root filesystem to do it automatically at boot time.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t ext4 /dev/mmcblk0p3 /www/upload/files/\n/usr/sbin/httpd -h /www/\nEOF\n</code></pre> <p>Reboot your target system again. With the <code>mount</code> command, check that <code>/www/upload/files</code> is now a mount point for the third SD card partition.</p> <p>Also make sure that you can still upload new images, and that these images are listed in the web interface. For example, upload the file <code>$LAB_PATH/nfsroot/www/gohome.png</code>.</p> QEMU - BusyBox<pre><code># reboot\n    ...\n# mount\n10.0.2.15:/srv/nfs on / type nfs (rw,relatime,vers=3,rsize=4096,wsize=4096,namlen=255,hard,nolock,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=10.0.2.15,mountvers=3,mountproto=tcp,local_lock=all,addr=10.0.2.15)\ndevtmpfs on /dev type devtmpfs (rw,relatime,size=50532k,nr_inodes=12633,mode=755)\nproc on /proc type proc (rw,relatime)\nsys on /sys type sysfs (rw,relatime)\n/dev/mmcblk0p3 on /www/upload/files type ext4 (rw,relatime)\n# echo \"Upload gohome.png from the web interface, please!\"\n    ...\n# ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\ngohome.png                 lost+found\nlinux-blackfin.jpg         upload.log\n</code></pre> <p></p> <p></p>"},{"location":"qemu/blockfs/#adding-a-tmpfs-partition-for-log-files","title":"Adding a <code>tmpfs</code> partition for log files","text":"<p>Currently, the upload script was storing its log file in <code>/www/upload/files/upload.log</code>. To avoid seeing this log file in the directory containing uploaded files, let\u2019s store it into <code>/var/log</code> instead.</p> <p>Add the <code>/var/log/</code> directory to your root filesystem, and modify the startup script to mount a <code>tmpfs</code> filesystem to this directory. You can test your <code>tmpfs</code> mount command line on the system before adding it to the startup script, in order to be sure that it works properly. Note that for types of <code>tmpfs</code> and <code>sysfs</code> the device name is just ignored, so we can just name them after the type.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ mkdir -p var/log/\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t tmpfs tmpfs /var/log/\nmount -t ext4 /dev/mmcblk0p3 /www/upload/files/\n/usr/sbin/httpd -h /www/\nEOF\n</code></pre> <p>Modify the <code>www/cgi-bin/upload.cfg</code> configuration file to store the log file in <code>/var/log/upload.log</code>. You will lose your log file each time you reboot your system, but that\u2019s OK in our system. That\u2019s what <code>tmpfs</code> is for: temporary data that you don\u2019t need to keep across system reboots.</p> <pre><code>$ nano www/cgi-bin/upload.cfg\n$ cat www/cgi-bin/upload.cfg\nConfig          = Default\n  Root          = /www/upload/files\n  FileMask      = *\n  IgnoreSubdirs = YES\n  Overwrite     = YES\n  LogFile       = /var/log/upload.log\n  OkPage        = /www/upload/OkPage.html\n  BadPage       = /www/upload/BadPage.html\n  Debug         = 0\n</code></pre> <p>Reboot your system and check that it works as expected, by uploading <code>gohome.png</code> again.</p> QEMU - BusyBox<pre><code># reboot\n    ...\n# mount\n10.0.2.15:/srv/nfs on / type nfs (rw,relatime,vers=3,rsize=4096,wsize=4096,namlen=255,hard,nolock,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=10.0.2.15,mountvers=3,mountproto=tcp,local_lock=all,addr=10.0.2.15)\ndevtmpfs on /dev type devtmpfs (rw,relatime,size=50532k,nr_inodes=12633,mode=755)\nproc on /proc type proc (rw,relatime)\nsysfs on /sys type sysfs (rw,relatime)\ntmpfs on /var/log type tmpfs (rw,relatime)\n/dev/mmcblk0p3 on /www/upload/files type ext4 (rw,relatime)\n# rm -v /www/upload/files/gohome.png\nremoved '/www/upload/files/gohome.png'\n# echo \"Upload gohome.png from the web interface, please!\"\n    ...\n# ls /www/upload/files/\nadult-small.png            linux-kernel-dev-book.jpg\nbrick.png                  lkn-small.jpg\ngohome.png                 lost+found\nlinux-blackfin.jpg         upload.log\n# cat /var/log/upload.log\nSat Apr  8 16:26:56 2023 File uploaded succesfully: gohome.png (888 bytes)\n# reboot\n    ...\n# cat /var/log/upload.log\ncat: can't open '/var/log/upload.log': No such file or directory\n</code></pre> <p>You can now <code>halt</code> and quit QEMU.</p>"},{"location":"qemu/blockfs/#making-a-squashfs-image","title":"Making a SquashFS image","text":"<p>We are going to store the root filesystem in a SquashFS filesystem in the second partition of the SD card. In order to create SquashFS images on your host, you need to install the <code>squashfs-tools</code> package.</p> <pre><code>$ sudo apt install squashfs-tools\n</code></pre> <p>Then, create a SquashFS image of your NFS root directory with <code>mksquashfs</code>.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ mksquashfs * ../nfsroot.sqsh\n</code></pre> <p>Setup the loop device again. Using the <code>dd</code> command, copy the filesystem image to the second partition (named <code>image</code>) in the SD card image. Finally, unmount and cleanup.</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ LOOP_DEV=$(sudo losetup -f --show --partscan sd.img)\n$ sudo mkfs.ext4 -L image \"${LOOP_DEV}p2\"\n    ...\n$ sudo dd if=\"$LAB_PATH/nfsroot.sqsh\" of=\"${LOOP_DEV}p2\"\n912+0 records in\n912+0 records out\n466944 bytes (467 kB, 456 KiB) copied, 0.0144154 s, 32.4 MB/s\n$ sudo losetup -d $LOOP_DEV\n</code></pre>"},{"location":"qemu/blockfs/#booting-on-the-squashfs-partition","title":"Booting on the SquashFS partition","text":"<p>In the U-boot shell, configure the kernel command line to use the second partition of the SD card as the root file system. Also add the <code>rootwait</code> boot argument, to wait for the SD card to be properly initialized before trying to mount the root filesystem. Since the SD cards are detected asynchronously by the kernel, the kernel might try to mount the root filesystem too early without <code>rootwait</code>. Check that your system still works. Congratulations if it does!</p> QEMU - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootargs console=ttyAMA0 root=/dev/mmcblk0p2 rootwait ip=${ipaddr}::${serverip}:${netmask}::\n=&gt; saveenv\n=&gt; reset\n    ...\nVFS: Mounted root (squashfs filesystem) readonly on device 179:2.\n    ...\nPlease press Enter to activate this console.\n</code></pre> <p>Now <code>halt</code> and quit QEMU.</p>"},{"location":"qemu/blockfs/#store-the-kernel-image-and-dtb-on-the-sd-card","title":"Store the kernel image and DTB on the SD card","text":"<p>Setup the loop device again, and mount the FAT partition (the first one) in the SD card image, for example on <code>/mnt/sd_boot</code>. It should contain only the latest saved U-Boot environment. Then, copy the kernel image and DTB to it. FInally, unmount the FAT partition and release the loop device.</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ LOOP_DEV=$(sudo losetup -f --show --partscan sd.img)\n$ mnt_path=\"/mnt/sd_boot\"\n$ sudo mkdir -p $mnt_path\n$ sudo mount -t vfat \"${LOOP_DEV}p1\" $mnt_path\n$ ls /mnt/sd_boot/\nuboot.env\n$ sudo cp /srv/tftp/zImage /srv/tftp/vexpress-v2p-ca9.dtb $mnt_path\n$ ls /mnt/sd_boot/\nuboot.env  vexpress-v2p-ca9.dtb  zImage\n$ sudo umount $mnt_path\n$ sudo rmdir $mnt_path\n$ sudo losetup -d $LOOP_DEV\n</code></pre> <p>You now need to adjust the <code>bootcmd</code> of U-Boot so that it loads kernel and from the SD card, instead of loading them from the network via TFTP. In U-boot, you can load a file from a FAT filesystem using the <code>fatload</code> command, which expects: the device, the partition, the load address, and the source filename. Compare the previous and the new <code>bootcmd</code>. Finally, <code>reset</code> to reboot the board and make sure that your system still boots fine.</p> QEMU - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; printenv bootcmd\nbootcmd=tftp 0x61000000 zImage;  tftp 0x62000000 vexpress-v2p-ca9.dtb;  bootz 0x61000000 - 0x62000000\n=&gt; setenv bootcmd \"fatload mmc 0:1 0x61000000 zImage;  fatload mmc 0:1 0x62000000 vexpress-v2p-ca9.dtb;  bootz 0x61000000 - 0x62000000\"\n=&gt; saveenv\n=&gt; reset\n    ...\n5018272 bytes read in 1665 ms (2.9 MiB/s)\n14081 bytes read in 19 ms (723.6 KiB/s)\nKernel image @ 0x61000000 [ 0x000000 - 0x4c92a0 ]\n## Flattened Device Tree blob at 62000000\n   Booting using the fdt blob at 0x62000000\nWorking FDT set to 62000000\n   Loading Device Tree to 66b14000, end 66b1a700 ... OK\nWorking FDT set to 66b14000\n\nStarting kernel ...\n    ...\nPlease press Enter to activate this console.\n</code></pre> <p>You can now <code>halt</code> and quit QEMU.</p>"},{"location":"qemu/blockfs/#backup","title":"Backup","text":"<pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ tar cfJv \"$LAB_PATH/fatload-sd.img.tar.xz\" sd.img\n$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-fatload.cpio.xz\"\n$ cd $LAB_PATH\n$ tar cfJv \"$LAB_PATH/nfsroot.sqsh.tar.xz\" nfsroot.sqsh\n</code></pre>"},{"location":"qemu/blockfs/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/bootloader/","title":"Bootloader - U-Boot","text":""},{"location":"qemu/bootloader/#objectives","title":"Objectives","text":"<p>After this lab you will be able to:</p> <ul> <li> <p>Compile and install the U-Boot bootloader for an emulated ARM Vexpress Cortex A9 board.</p> </li> <li> <p>Use basic U-Boot commands.</p> </li> <li> <p>Set up TFTP communication with the host machine.</p> </li> </ul>"},{"location":"qemu/bootloader/#overview","title":"Overview","text":"<pre><code>@startuml\n\nboundary \"Host\\nLubuntu VM\" as Host\ncontrol \"QEMU\\nvexpress-a9\" as Qemu\ncontrol \"U-Boot\\n10.0.2.69\" as UBoot\nentity \"TFTP Server\\n10.0.2.15\\n/srv/tftp/\" as TftpServer\n\nactivate Host\n\nHost -&gt; TftpServer: start\nactivate TftpServer\n\nHost -&gt; Qemu: start\nactivate Qemu\n\nQemu -&gt; UBoot: kernel \"u-boot\"\nactivate UBoot\n\nUBoot -&gt; UBoot: setenv serverip 10.0.2.15\\nsetenv ipaddr 10.0.2.69\n\nUBoot -&gt; UBoot: tftp 0x61000000 zImage\nactivate UBoot\nUBoot -&gt; TftpServer: get \"zImage\"\nactivate TftpServer\nTftpServer -&gt; UBoot: \"zImage\"\ndeactivate TftpServer\nUBoot -&gt; UBoot: write @ 0x61000000\ndeactivate UBoot\n\nUBoot -&gt; UBoot: tftp 0x62000000 vexpress-v2p-ca9.dtb\nactivate UBoot\nUBoot -&gt; TftpServer: get \"vexpress-v2p-ca9.dtb\"\nactivate TftpServer\nTftpServer -&gt; UBoot: \"zImage\"\ndeactivate TftpServer\nUBoot -&gt; UBoot: write @ 0x62000000\ndeactivate UBoot\n\nUBoot -&gt; UBoot: bootz 0x61000000 - 0x62000000\nactivate UBoot\nUBoot -&gt; UBoot: enter Linux\ndeactivate UBoot\ndestroy UBoot\n\n@enduml\n</code></pre>"},{"location":"qemu/bootloader/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>device-tree-compiler</code> <code>libssl-dev</code> <code>parted</code> <code>python3-dev</code> <code>python3-distutils</code> <code>qemu-system-arm</code> <code>swig</code> <code>tftpd-hpa</code></p> <p>plus those from the previous labs.</p> </li> <li> <p>Das U-Boot, either as:</p> <ul> <li> <p>git repository</p> </li> <li> <p>Source code archive for release <code>v2023.01</code></p> </li> </ul> </li> </ul>"},{"location":"qemu/bootloader/#source-code","title":"Source code","text":"<p>Enter the folder of this lab, that's going to become our main workspace folder:</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/bootloader\"\n$ cd $LAB_PATH\n</code></pre> <p>You can now get U-Boot at the suggested version (git tag <code>v2023.01</code>).</p> <p>We're going to clone the git repository into the home folder, creating a new branch named after the embedded-linux-qemu tutorial just for convenience.</p> <pre><code>$ cd $LAB_PATH\n$ git clone \"https://source.denx.de/u-boot/u-boot\"\n$ cd u-boot/\n$ label=\"v2023.01\"\n$ git checkout -b embedded-linux-qemu $label\n</code></pre> <p>Alternatively, you can directly unpack an archive of the suggested version. This is usually much faster than cloning a big git repository, despite losing all the features of a git repository.</p> <pre><code>$ cd $LAB_PATH\n$ label=\"v2023.01\"\n$ wget \"https://source.denx.de/u-boot/u-boot/-/archive/${label}/u-boot-${label}.tar.bz2\"\n$ tar xfv \"u-boot-${label}.tar.bz2\"\n$ mv u-boot*/ u-boot\n</code></pre>"},{"location":"qemu/bootloader/#configuration","title":"Configuration","text":"<p>Get an understanding of U-Boot\u2019s configuration and compilation steps by reading its <code>README</code> file, and specifically the Building the Software section.</p> <p>U-Boot comes with some sample configuration files for officially supported boards, under the <code>configs</code> folder, named with a <code>_defconfig</code> suffix.</p> <p>Our board is an ARM Vexpress Cortex A9, so let's find it:</p> <pre><code>$ cd $LAB_PATH/u-boot/\n$ ls configs/ | grep vexpress\nvexpress_aemv8a_juno_defconfig\nvexpress_aemv8a_semi_defconfig\nvexpress_aemv8r_defconfig\nvexpress_ca9x4_defconfig\n</code></pre> <p>We choose <code>vexpress_ca9x4_defconfig</code> as our template. Let's call <code>make</code> to make it effective:</p> <pre><code>$ make vexpress_ca9x4_defconfig\n</code></pre>"},{"location":"qemu/bootloader/#build","title":"Build","text":"<p>To build U-Boot, we need to specify the cross-compile toolchain we built by setting a global variable <code>CROSS_COMPILE</code>. The <code>export</code> keyword makes it available also to sub-processes, including <code>make</code> and the tools called by it. We can choose between the full name <code>arm-training-linux-uclibcgnueabihf-</code> or the shortened alias <code>arm-linux-</code> as the prefix. Also, remmeber to parallelize to save time.</p> <pre><code>$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export MAKEFLAGS=-j$(nproc)\n</code></pre> <p>We're going to use the <code>menuconfig</code> to refine the configuration to suit our needs.</p> <pre><code>$ cd $LAB_PATH/u-boot/\n$ make menuconfig\n</code></pre> <p>See: <code>menuconfig</code></p> <p>In <code>Command line interface</code> \u2192 <code>Boot commands</code>:</p> <ul> <li>Add support for <code>bootd</code> (<code>CONFIG_CMD_BOOTD</code>)</li> </ul> <p>In <code>Command line interface</code> \u2192 <code>Environment commands</code>:</p> <ul> <li>Add support for <code>editenv</code> (<code>CONFIG_CMD_EDITENV</code>)</li> </ul> <p>In <code>Environment</code>, we will configure U-Boot so that it stores its environment inside a file called <code>uboot.env</code> in a FAT filesystem on an MMC/SD card (device <code>mmcblk0p1</code>), as our emulated machine won\u2019t have flash storage.</p> <ul> <li> <p>Unset <code>Environment in flash memory</code> (<code>CONFIG_ENV_IS_IN_FLASH</code>)</p> </li> <li> <p>Set <code>Environment is in a FAT filesystem</code> (<code>CONFIG_ENV_IS_IN_FAT</code>)</p> </li> <li> <p>Set <code>Name of the block device for the environment</code> (<code>CONFIG_ENV_FAT_INTERFACE</code>) = <code>mmc</code></p> </li> <li> <p>Set <code>Device and partition for where to store the environment in FAT</code> (<code>CONFIG_ENV_FAT_DEVICE_AND_PART</code>) = <code>0:1</code></p> </li> </ul> <p>You can now <code>&lt;Save&gt;</code> and make a backup copy of this configuration:</p> <pre><code>$ cp .config ../u-boot.config\n</code></pre> <p>Install some packages required for compilation:</p> <pre><code>$ sudo apt install  \\\ndevice-tree-compiler libssl-dev parted  \\\npython3-dev python3-distutils swig\n</code></pre> <p>You can now build the bootloader:</p> <pre><code>$ make\n</code></pre> <p>This generates several binaries, including <code>u-boot</code> and <code>u-boot.bin</code>. You can save the former into a backup archive if you wish so:</p> <pre><code>$ tar cfJv ../u-boot.tar.xz u-boot\n</code></pre>"},{"location":"qemu/bootloader/#quick-test","title":"Quick test","text":"<p>Back to the lab folder, test that U-Boot works. We're going to use QEMU system, which emulates a whole target machine (instead of QEMU user that only emulates executables).</p> <pre><code>$ cd $LAB_PATH\n$ qemu-system-arm  -nographic  \\\n-M vexpress-a9  \\\n-m 128M  \\\n-kernel u-boot/u-boot\n</code></pre> <ul> <li><code>-M</code>: emulated machine</li> <li><code>-m</code>: amount of memory in the emulated machine</li> <li><code>-kernel</code>: allows to load the binary directly into the emulated machine, and run the machine with it.   This way, you don\u2019t need a first stage bootloader. Of course, you don\u2019t have this with real hardware.</li> </ul> <p>Press a key before the end of the timeout, to access the U-Boot prompt: You can then type the <code>help</code> command, and explore the few commands available.</p> QEMU - U-Boot<pre><code>Hit any key to stop autoboot:  0\n=&gt; help\n?         - alias for 'help'\n  ...\nversion   - print monitor, compiler and linker version\n</code></pre> <p>To exit QEMU, type Ctrl+A then H to see the available commands.</p> QEMU - help<pre><code>C-a h    print this help\nC-a x    exit emulator\nC-a s    save disk data back to file (if -snapshot)\nC-a t    toggle console timestamps\nC-a b    send break (magic sysrq)\nC-a c    switch between console and monitor\nC-a C-a  sends C-a\n</code></pre> <p>One of them is Ctrl+A then X, which allows to quit the emulator.</p>"},{"location":"qemu/bootloader/#sd-card-setup","title":"SD card setup","text":"<p>We now need to add an SD card image to the QEMU virtual machine, in particular to get a way to store the U-Boot environment. In later labs, we will also use such storage for other purposes (e.g. to store the kernel and device tree, root filesystem and other filesystems). The commands that we are going to use will be further explained during the Block filesystems lectures.</p> <p>First, using the <code>dd</code> command, create a 1 GB file filled with zeros, called <code>sd.img</code>, to be used by QEMU as an SD card disk image.</p> <pre><code>$ cd $LAB_PATH\n$ dd if=/dev/zero of=sd.img bs=1M count=1024\n</code></pre> <p>Now, let\u2019s call the <code>cfdisk</code> command to create the partitions that we are going to use:</p> <pre><code>$ cfdisk sd.img\n</code></pre> <p>If <code>cfdisk</code> asks you to <code>Select a label type</code>, choose <code>dos</code>, as we don\u2019t really need a <code>gpt</code> partition table for our labs.</p> <p>In the <code>cfdisk</code> interface, create three primary partitions, starting from the beginning, with the following properties:</p> <ul> <li> <p>One partition, 64 MB big, with the <code>FAT16</code> partition type.   Mark this partition as bootable.</p> </li> <li> <p>One partition, 32 MB big, that will be used for the root filesystem.   Due to the geometry of the device, the partition might be larger, but it does not matter.   Keep the <code>Linux</code> partition type.</p> </li> <li> <p>One partition filling the remaining space of the SD card image, to be used for the data filesystem.   Keep the <code>Linux</code> partition type.</p> </li> </ul> <p>Select <code>Write</code> when you are done.</p> <p>You could've done something similar with a single <code>parted</code> issue:</p> <pre><code>$ parted -s sd.img --  \\\nmklabel msdos  \\\nmkpart primary boot fat16 1m 64m  \\\nmkpart primary root ext4 64m 96m  \\\nmkpart primary data ext4 96m -1s  \\\nset 1 boot on\n</code></pre> <p>We're allocating a loop driver to emulate block devices from this image and its partitions, by calling <code>losetup</code> (returned <code>loop13</code> in the example):</p> <pre><code>$ LOOP_DEV=$(sudo losetup -f --show --partscan sd.img)\n$ echo $LOOP_DEV\n/dev/loop13\n</code></pre> <ul> <li><code>-f</code>: finds a free loop device</li> <li><code>--show</code>: shows the loop device that it used</li> <li> <p><code>--partscan</code>: scans the loop device for partitions, and creates additional <code>/dev/loopXpY</code> block devices, where:</p> <ul> <li>X: device index</li> <li>Y: partition index</li> </ul> </li> </ul> <p>Also run <code>sudo dmesg</code> to confirm that 3 partitions were detected for the loop device selected by <code>losetup</code>:</p> <pre><code>$ sudo dmesg | grep loop\n  ...\n[19698.310073] loop13: detected capacity change from 0 to 2097152\n[19698.310264]  loop13: p1 p2 p3\n</code></pre> <p>Last but not least, format partition <code>1</code> as <code>FAT16</code> with <code>boot</code> as label. The other partitions will be formated later.</p> <pre><code>$ sudo mkfs.vfat -F 16 -n boot \"${LOOP_DEV}p1\"\nmkfs.fat 4.2 (2021-01-31)\nmkfs.fat: Warning: lowercase labels might not work properly on some systems\n</code></pre> <p>You could've formatted this partition directly within the <code>parted</code> example above, with a <code>parted</code> command like: <code>mkfs 1 fat16</code>.</p> <p>Now, you can release the loop device. If you want, you can create a backup archive.</p> <pre><code>$ sudo losetup -d $LOOP_DEV\n$ tar cfJv sd.img_p1-only.tar.xz sd.img\n</code></pre>"},{"location":"qemu/bootloader/#test-environment","title":"Test environment","text":"<p>Start QEMU again, but this time with the emulated SD card:</p> <pre><code>$ qemu-system-arm  -nographic \\\n-M vexpress-a9  \\\n-m 128M  \\\n-kernel u-boot/u-boot  \\\n-sd sd.img\n</code></pre> <p>Now, in the U-Boot prompt, make sure that you can set and store an environment variable:</p> QEMU - U-Boot<pre><code>=&gt; setenv foo bar\n=&gt; saveenv\nSaving Environment to FAT... OK\n</code></pre> <p>Run <code>reset</code> to reboot the virtual board, and then check that the <code>foo</code> variable is still set:</p> QEMU - U-Boot<pre><code>=&gt; reset\n    ...\nHit any key to stop autoboot:  0\n=&gt; printenv foo\nfoo=bar\n</code></pre> <p>You can now quit from QEMU (Ctrl+A then X).</p>"},{"location":"qemu/bootloader/#networking","title":"Networking","text":"<p>To load a kernel in the next lab, we have to setup networking between the host machine and the QEMU emulated target machine.</p> <p>See Host VM - Networking for information about the IP addresses for this lab.</p> <p>To do so, create a <code>qemu-myifup</code> shell script that brings up the network interface between QEMU and the host. It's going to be called by QEMU upon spawning of the emulated target machine, with script argument <code>$1</code> holding the created network interface. Here's the content of the shell script file:</p> $LAB_PATH/qemu-myifup<pre><code>#!/bin/sh\nHOST_IP=\"10.0.2.15\"\nNET_MASK=\"255.255.255.0\"\n/sbin/ip a add \"$HOST_IP/$NET_MASK\" dev \"$1\"\n/sbin/ip link set \"$1\" up\n</code></pre> <p>You can dump the content directly to the file with a single command line trick that concatenates (<code>cat</code>) a delimited multi-line block of text (between <code>&lt;&lt;'EOF'</code> and a standalone <code>EOF</code>; quoted to prevent parameter expansion). Remember to make the script executable.</p> <pre><code>$ cd $LAB_PATH\n$ cat &gt; qemu-myifup &lt;&lt;'EOF'\n#!/bin/sh\nHOST_IP=\"10.0.2.15\"\nNET_MASK=\"255.255.255.0\"\n/sbin/ip a add \"$HOST_IP/$NET_MASK\" dev \"$1\"\n/sbin/ip link set \"$1\" up\nEOF\n$ chmod +x qemu-myifup\n</code></pre> <p>You need root privileges to run QEMU this time, because of the need to bring up the network interface. You could put the command into another shell script named <code>qemu</code>, for convenience:</p> <pre><code>$ cat &gt; qemu &lt;&lt;'EOF'\n#!/bin/sh\nsudo qemu-system-arm  -nographic  \\\n  -M vexpress-a9  \\\n  -m 128M  \\\n  -kernel u-boot/u-boot  \\\n  -sd sd.img  \\\n  -net tap,script=./qemu-myifup  \\\n  -net nic\nEOF\n$ chmod +x qemu\n$ ./qemu\n</code></pre> <p>Note the new net options:</p> <ul> <li><code>-net tap</code>: creates a software network interface on the host side.</li> <li><code>-net nic</code>: adds a network device to the emulated machine.</li> </ul> <p>Meanwhile on the host machine, using the <code>ip a</code> command, check that there is now a <code>tapN</code> network interface with the expected host IP address.</p> <pre><code>$ ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 08:00:27:c2:2c:2e brd ff:ff:ff:ff:ff:ff\n    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3\n       valid_lft 86241sec preferred_lft 86241sec\n    inet6 fe80::ed74:587e:b871:454d/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever\n3: tap0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 1000\n    link/ether b2:5d:a5:d1:4d:ce brd ff:ff:ff:ff:ff:ff\n    inet 10.0.2.15/24 scope global tap0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::b05d:a5ff:fed1:4dce/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>On the U-Boot command line, you have to configure the environment variables for networking: <code>serverip</code> for the host (server) machine, and <code>ipaddr</code> for the target machine. To make these settings permanent, save the environment.</p> QEMU - U-Boot<pre><code>=&gt; setenv serverip 10.0.2.15\n=&gt; setenv ipaddr 10.0.2.69\n=&gt; saveenv\n</code></pre> <p>You can now test the connection to the host, with the <code>ping</code> command of U-Boot. Note that while U-Boot can ping other machines, it cannot be pinged back, because U-Boot doesn't use a complete network stack.</p> QEMU - U-Boot<pre><code>=&gt; ping $serverip\n    ...\nhost 10.0.2.15 is alive\n</code></pre> <p>You can leave the QEMU instance running for the next paragraph.</p>"},{"location":"qemu/bootloader/#tftp-server","title":"TFTP server","text":"<p>Let\u2019s install a TFTP server on your host machine*, by the <code>tftpd-hda</code> package.</p> <pre><code>$ sudo apt install tftpd-hpa\n$ sudo systemctl restart tftpd-hpa\n</code></pre> <p>By default, files are stored under the <code>/srv/tftp/</code> folder, which should be accessible by the by <code>tftp</code> group. So, let's add our user to it.</p> <pre><code>$ sudo mkdir -p /srv/tftp\n$ sudo chown -R tftp:tftp /srv/tftp\n$ sudo chmod g+rw /srv/tftp/\n$ sudo adduser $USER tftp\n$ newgrp tftp\n</code></pre> <p>The <code>newgrp tftp</code> command makes this group available to the current shell without restarting the host login session. Until the next login session, you have to type this command again for any new shells of the current login session.</p> <p>To test the TFTP connection, put a small text file in the directory exported through TFTP on your host machine, then try to read it back as a TFTP client to check that the server is working properly.</p> <pre><code>$ echo \"Hello, World!\" &gt; /srv/tftp/textfile.txt\n$ cd $LAB_PATH\n$ tftp localhost -v -c get textfile.txt\nConnected to localhost (::1), port 69\ngetting from localhost:textfile.txt to textfile.txt [netascii]\nReceived 15 bytes in 0.0 seconds [6306 bit/s]\n$ cat textfile.txt\nHello, World!\n</code></pre> <p>Back in U-Boot run <code>bdinfo</code>, which allows finding out that the RAM starts at <code>0x60000000</code>.</p> QEMU - U-Boot<pre><code>=&gt; bdinfo\nboot_params = 0x60002000\nDRAM bank   = 0x00000000\n-&gt; start    = 0x60000000\n-&gt; size     = 0x08000000\nDRAM bank   = 0x00000001\n-&gt; start    = 0x80000000\n-&gt; size     = 0x00000004\nflashstart  = 0x40000000\nflashsize   = 0x04000000\nflashoffset = 0x00000000\nbaudrate    = 38400 bps\nrelocaddr   = 0x67f67000\nreloc off   = 0x07767000\nBuild       = 32-bit\ncurrent eth = ethernet@3,02000000\nethaddr     = 52:54:00:12:34:56\nIP addr     = 10.0.2.69\nfdt_blob    = 0x67fdf590\nnew_fdt     = 0x00000000\nfdt_size    = 0x00000000\nlmb_dump_all:\n memory.cnt  = 0x2\n memory[0]      [0x60000000-0x67ffffff], 0x08000000 bytes flags: 0\n memory[1]      [0x80000000-0x80000003], 0x00000004 bytes flags: 0\n reserved.cnt  = 0x2\n reserved[0]    [0x4c000000-0x4c7fffff], 0x00800000 bytes flags: 4\n reserved[1]    [0x67b22c78-0x67ffffff], 0x004dd388 bytes flags: 0\ndevicetree  = embed\narch_number = 0x000008e0\nTLB addr    = 0x67ff0000\nirq_sp      = 0x67b26eb0\nsp start    = 0x67b26ea0\nEarly malloc usage: 370 / 400\n</code></pre> <p>Therefore, we will use the <code>0x61000000</code> address to test <code>tftp</code>.</p> <p>From the U-Boot prompt, ask the TFTP server that file:</p> QEMU - U-Boot<pre><code>=&gt; setenv ram_app_start 0x61000000\n=&gt; tftp $ram_app_start textfile.txt\nsmc911x: detected LAN9118 controller\nsmc911x: phy initialized\nsmc911x: MAC 52:54:00:12:34:56\nUsing ethernet@3,02000000 device\nTFTP from server 10.0.2.15; our IP address is 10.0.2.69\nFilename 'textfile.txt'.\nLoad address: 0x61000000\nLoading: #\n         2 KiB/s\ndone\nBytes transferred = 14 (e hex)\nsmc911x: MAC 52:54:00:12:34:56\n</code></pre> <p>The <code>tftp</code> command should have downloaded <code>textfile.txt</code> from your development workstation into the board\u2019s memory at location <code>0x61000000</code>. You can verify that the download was successful by dumping the contents of the memory (<code>md</code>, memory dump):</p> QEMU - U-Boot<pre><code>=&gt; md $ram_app_start\n61000000: 6c6c6548 57202c6f 646c726f 00000a21  Hello, World!...\n61000010: 00000000 00000000 00000000 00000000  ................\n61000020: 00000000 00000000 00000000 00000000  ................\n61000030: 00000000 00000000 00000000 00000000  ................\n61000040: 00000000 00000000 00000000 00000000  ................\n61000050: 00000000 00000000 00000000 00000000  ................\n61000060: 00000000 00000000 00000000 00000000  ................\n61000070: 00000000 00000000 00000000 00000000  ................\n61000080: 00000000 00000000 00000000 00000000  ................\n61000090: 00000000 00000000 00000000 00000000  ................\n610000a0: 00000000 00000000 00000000 00000000  ................\n610000b0: 00000000 00000000 00000000 00000000  ................\n610000c0: 00000000 00000000 00000000 00000000  ................\n610000d0: 00000000 00000000 00000000 00000000  ................\n610000e0: 00000000 00000000 00000000 00000000  ................\n610000f0: 00000000 00000000 00000000 00000000  ................\n</code></pre> <p>You can now quit from QEMU (Ctrl+A then X).</p>"},{"location":"qemu/bootloader/#backup-and-restore","title":"Backup and restore","text":"<p>If you have trouble generating binaries that work properly, or later make a mistake that causes you to lose your bootloader binary, you can find a working version under <code>$LAB_PATH/data/</code>, to be copied to <code>$LAB_PATH/u-boot/</code>:</p> <pre><code>$ cd $LAB_PATH\n$ mkdir -p u-boot/\n$ cp data/u-boot u-boot/u-boot\n</code></pre>"},{"location":"qemu/bootloader/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/buildroot/","title":"Buildroot","text":""},{"location":"qemu/buildroot/#objectives","title":"Objectives","text":"<ul> <li>discover how a build system is used and how it works, with the example of the Buildroot build system.</li> </ul> <p>Compared to the previous lab, we are going to build a more elaborate system, still containing <code>alsa-utils</code> (and of course its <code>alsa-lib</code> dependency), but this time using Buildroot, an automated build system.</p> <p>The automated build system will also allow us to add more packages and play real audio on our system, thanks to the Music Player Daemon (<code>mpd</code>) and its <code>mpc</code> client.</p> <p>Important note: because of the current sound playing issues mentioned before, this lab will be less exhaustive compared to our instructions on real hardware. You should be able to run the commands in the QEMU emulated machine though, proving that the tools were built correctly. So, we will build tools like mpd and mpc, but won\u2019t test them because of the absence of sound.</p>"},{"location":"qemu/buildroot/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>evince</code> <code>graphviz</code></p> <p>plus those from the previous labs.</p> </li> <li> <p>Buildroot, either as:</p> <ul> <li> <p>git repository tag <code>v2022.02</code></p> </li> <li> <p>Source code archive for release <code>v2022.02</code></p> </li> </ul> </li> </ul>"},{"location":"qemu/buildroot/#source-code","title":"Source code","text":"<p>The official Buildroot website is available at https://buildroot.org/. Let's clone the git repository, branching the <code>2022.02</code> release, which is a LTS (Long Term Support, we're just sticking to the original one), naming after this lab.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/buildroot\"\n$ cd $LAB_PATH\n$ label=\"2022.02\"\n$ git clone https://git.buildroot.net/buildroot/\n$ cd buildroot/\n$ git checkout -b embedded-linux-qemu $label\n</code></pre> <p>Alternatively, you can download an archived version.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/buildroot\"\n$ cd $LAB_PATH\n$ label=\"2022.02\"\n$ wget \"https://git.buildroot.net/buildroot/snapshot/buildroot-${label}.tar.bz2\"\n$ tar xfv \"buildroot-${label}.tar.bz2\"\n$ mv buildroot*/ buildroot\n$ cd buildroot/\n</code></pre> <p>Several subdirectories or files are visible. The most important ones are:</p> <ul> <li> <p><code>boot</code> contains the Makefiles and configuration items related to the compilation of common bootloaders (GRUB, U-Boot, Barebox, etc.)</p> </li> <li> <p><code>board</code> contains board specific configurations and root filesystem overlays.</p> </li> <li> <p><code>configs</code> contains a set of predefined configurations, similar to the concept of defconfig in the kernel.</p> </li> <li> <p><code>docs</code> contains the documentation for Buildroot.</p> </li> <li> <p><code>fs</code> contains the code used to generate the various root filesystem image formats.</p> </li> <li> <p><code>linux</code> contains the Makefile and configuration items related to the compilation of the Linux kernel.</p> </li> <li> <p><code>Makefile</code> is the main Makefile that we will use to use Buildroot: everything works through Makefiles in Buildroot;</p> </li> <li> <p><code>package</code> is a directory that contains all the Makefiles, patches, and configuration items to compile the user space applications and libraries of your embedded Linux system.   Have a look at various subdirectories and see what they contain.</p> </li> <li> <p><code>system</code> contains the root filesystem skeleton and the device tables used for a static <code>/dev</code>.</p> </li> <li> <p><code>toolchain</code> contains the Makefiles, patches and configuration items to generate the cross-compiling toolchain.</p> </li> </ul>"},{"location":"qemu/buildroot/#configuration","title":"Configuration","text":"<p>In our case, we would like to:</p> <ul> <li> <p>Generate an embedded Linux system for ARM.</p> </li> <li> <p>Use an already existing external toolchain instead of having Buildroot generating one for us.</p> </li> <li> <p>Compile the Linux kernel and deploy its modules in the root filesystem.</p> </li> <li> <p>Integrate BusyBox, <code>alsa-utils</code>, <code>mpd</code>, <code>mpc</code> and <code>evtest</code> in our embedded Linux system.</p> </li> <li> <p>Integrate the target filesystem into a tarball.</p> </li> </ul> <p>To run the configuration utility of Buildroot, simply run:</p> <pre><code>$ make menuconfig\n</code></pre> <p>Set the following options. Don\u2019t hesitate to press the <code>Help</code> button whenever you need more details about a given option!</p> <p>In <code>Target options</code>:</p> <ul> <li> <p><code>Target Architecture</code> = <code>ARM (little endian)</code>.</p> </li> <li> <p><code>Target Architecture Variant</code> = <code>cortex-A9</code>.</p> </li> <li> <p>Enable <code>NEON SIMD extension support</code>.</p> </li> <li> <p>Enable <code>VFP extension support</code>.</p> </li> <li> <p><code>Target ABI</code> = <code>EABIhf</code>.</p> </li> <li> <p><code>Floating point strategy</code> = <code>VFPv3-D16</code>.</p> </li> </ul> <p>In <code>Toolchain</code>:</p> <ul> <li> <p><code>Toolchain type</code> = <code>External toolchain</code>.</p> </li> <li> <p><code>Toolchain</code> = <code>Custom toolchain</code>.</p> </li> <li> <p><code>Toolchain path</code> = <code>$(HOME)/x-tools/arm-training-linux-uclibcgnueabihf</code>, which is the one we built.</p> </li> <li> <p><code>External toolchain gcc version</code> = <code>11.x</code>.</p> </li> <li> <p><code>External toolchain kernel headers series</code> = <code>5.15.x</code>.</p> </li> <li> <p><code>External toolchain C library</code> = <code>uClibc/uClibc-ng</code>.</p> </li> <li> <p>Enable <code>Toolchain has WCHAR support?</code>.</p> </li> <li> <p>Enable <code>Toolchain has SSP support?</code>.</p> </li> <li> <p>Enable <code>Toolchain has C++ support?</code>.</p> </li> </ul> <p>In <code>Kernel</code>:</p> <ul> <li> <p>Enable <code>Linux Kernel</code>.</p> </li> <li> <p><code>Kernel version</code> = <code>Latest version (5.15)</code>.</p> </li> <li> <p><code>Defconfig name</code> = <code>vexpress</code>.</p> </li> <li> <p>Enable <code>Build a Device Tree Blob (DTB)</code>.</p> </li> <li> <p><code>In-tree Device Tree Source file names</code> = <code>vexpress-v2p-ca9</code>.</p> </li> </ul> <p>In <code>Target packages</code>:</p> <ul> <li> <p>Keep <code>BusyBox (default version)</code> and keep the BusyBox configuration proposed by Buildroot.</p> </li> <li> <p>Under <code>Audio and video applications</code>:</p> <ul> <li> <p>Enable <code>alsa-utils</code>, and in the submenu:</p> <ul> <li> <p>Enable <code>alsamixer</code>. You will be able to test this application too, and that will also pull the <code>ncurses</code> library, which we will also use in the next lab.</p> </li> <li> <p>Enable <code>speaker-test</code>.</p> </li> </ul> </li> <li> <p>Enable <code>mpd</code>, and in the submenu:</p> <ul> <li>Keep only <code>alsa</code>, <code>vorbis</code> and <code>tcp sockets</code>.</li> </ul> </li> <li> <p>Enable <code>mpd-mpc</code>.</p> </li> </ul> </li> </ul> <p>In <code>Filesystem images</code>:</p> <ul> <li>Enable <code>tar the root filesystem</code>.</li> </ul> <p>Exit the <code>menuconfig</code> interface saving into the usual <code>.config</code> file. Also make a backup copy for reference.</p> <pre><code>$ cp .config ../buildroot.config\n</code></pre>"},{"location":"qemu/buildroot/#build","title":"Build","text":"<p>Just run the canonical <code>make</code>:</p> <pre><code>$ make\n</code></pre> <p>Buildroot will first create a small environment with the external toolchain, then download, extract, configure, compile, and install each component of the embedded system.</p> <p>All the compilation has taken place in the <code>output/</code> subdirectory. Let\u2019s explore its content:</p> <ul> <li> <p><code>build</code> is the directory in which each component built by Buildroot is extracted, and where the build actually takes place.</p> </li> <li> <p><code>host</code> is the directory where Buildroot installs some components for the host.   As Buildroot doesn\u2019t want to depend on too many things installed in the developer machines, it installs some tools needed to compile the packages for the target.   In our case it installed <code>pkg-config</code> (since the version of the host may be ancient) and tools to generate the root filesystem image (<code>genext2fs</code>, <code>makedevs</code>, <code>fakeroot</code>).</p> </li> <li> <p><code>images</code> which contains the final images produced by Buildroot. In our case it contains a tarball of the filesystem, called <code>rootfs.tar</code>, plus the compressed kernel and DTB (Device Tree Binary).   Depending on the configuration, there could also a bootloader binary or a full SD card image.</p> </li> <li> <p><code>staging</code>, which contains the \"build\" space of the target system, all the target libraries, with headers and documentation.   It also contains the system headers and the C library, which in our case have been copied from the cross-compiling toolchain.</p> </li> <li> <p><code>target</code> is the target root filesystem. All the applications and libraries, usually stripped, are installed in this directory.   However, it cannot be used directly as the root filesystem, as all the device files are missing: it is not possible to create them without being root, and Buildroot has a policy of not running anything as root.</p> </li> </ul>"},{"location":"qemu/buildroot/#run-the-generated-system","title":"Run the generated system","text":"<p>Go back to the <code>$HOME/embedded-linux-qemu-labs/buildroot/</code> directory. Create a new <code>nfsroot</code> directory that is going to hold our system, exported over NFS. Go into this directory, and untar the rootfs.</p> <pre><code>$ mkdir -p \"$LAB_PATH/nfsroot/\"\n$ cd \"$LAB_PATH/nfsroot/\"\n$ tar xfv \"../buildroot/output/images/rootfs.tar\"\n</code></pre> <p>Add this new <code>nfsroot</code> directory to the list of directories exported by NFS in <code>/etc/exports</code>. You could just replace the symlink we used for BusyBox, pointing instead to this new <code>nfsroot</code>.</p> <pre><code>$ sudo rm -f /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/nfsroot/\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-qemu-labs/buildroot/nfsroot/'\n$ sudo chown -R tftp:tftp /srv/nfs\n$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre> <p>Also update the kernel and Device Tree Binaries used by your board, from the ones compiled by Buildroot in <code>output/images/</code>.</p> <pre><code>$ cd \"$LAB_PATH/buildroot/output/\"\n$ cp images/zImage /srv/tftp/zImage-buildroot\n$ cp images/zImage /srv/tftp/zImage\n$ cp $(find . -name \"vexpress-v2p-ca9.dtb\") /srv/tftp/\n</code></pre> <p>You should restore U-Boot to work with TFTP and NFS. Run QEMU, press a key to reach the U-Boot prompt, and restore the environment variables. Finally, reset the board. You should now be able to log in (<code>root</code> account, no password) to reach a shell.</p> QEMU - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootcmd \"tftp 0x61000000 zImage;  tftp 0x62000000 vexpress-v2p-ca9.dtb;  bootz 0x61000000 - 0x62000000\"\n=&gt; setenv bootargs console=ttyAMA0 root=/dev/nfs ip=${ipaddr}::${serverip}:${netmask}:: nfsroot=${serverip}:${servernfs},nfsvers=3,tcp rw\n=&gt; saveenv\n=&gt; reset\n    ...\nWelcome to Buildroot\nbuildroot login: root\n#\n</code></pre> <p>You can run <code>speaker-test</code> to check that this application works; note that the sound might stutter within QEMU.</p> QEMU - Buildroot<pre><code># speaker-test -t sine -l 1\nspeaker-test 1.2.6\nPlayback device is default\nStream parameters are 48000Hz, S16_LE, 1 channels\nSine wave rate is 440.0000Hz\nRate set to 48000Hz (requested 48000Hz)\nBuffer size range from 256 to 16384\nPeriod size range from 64 to 1024\nUsing max buffer size 16384\nPeriods = 4\nwas set period_size = 1024\nwas set buffer_size = 16384\n 0 - Front Left\nTime per period = 3.791015\n</code></pre> <p>You can also test the <code>alsamixer</code> command too.</p> QEMU - Buildroot <pre><code># alsamixer\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 AlsaMixer v1.2.6 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Card: ARM AC'97 Interface                            F1:  Help               \u2502\n\u2502 Chip: National Semiconductor LM4549                  F2:  System information \u2502\n\u2502 View: F3:[Playback] F4: Capture  F5: All             F6:  Select sound card  \u2502\n\u2502 Item: Master [dB gain: 0.00, 0.00]                   Esc: Exit               \u2502\n\u2502                                                                              \u2502\n\u2502     \u250c\u2500\u2500\u2510     \u250c\u2500\u2500\u2510     \u250c\u2500\u2500\u2510              \u250c\u2500\u2500\u2510              \u250c\u2500\u2500\u2510     \u250c\u2500\u2500\u2510      \u2502\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      \u2502\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      \u2502\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      &gt;\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      \u2502\n\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502     \u2502\u2592\u2592\u2502              \u2502\u2592\u2592\u2502              \u2502  \u2502     \u2502  \u2502      \u2502\n\u2502     \u251c\u2500\u2500\u2524     \u251c\u2500\u2500\u2524     \u251c\u2500\u2500\u2524     \u250c\u2500\u2500\u2510     \u251c\u2500\u2500\u2524    pre 3D    \u251c\u2500\u2500\u2524     \u251c\u2500\u2500\u2524      \u2502\n\u2502     \u2502MM\u2502     \u2502MM\u2502     \u2502MM\u2502     \u2502MM\u2502     \u2502MM\u2502              \u2502MM\u2502     \u2502MM\u2502      \u2502\n\u2502     \u2514\u2500\u2500\u2518     \u2514\u2500\u2500\u2518     \u2514\u2500\u2500\u2518     \u2514\u2500\u2500\u2518     \u2514\u2500\u2500\u2518              \u2514\u2500\u2500\u2518     \u2514\u2500\u2500\u2518      \u2502\n\u2502   100&lt;&gt;100 100&lt;&gt;100 100&lt;&gt;100          100&lt;&gt;100            0&lt;&gt;0     0&lt;&gt;0      \u2502\n\u2502  &lt; Master &gt;Master M Headphon 3D Contr   PCM    PCM Out    Line      CD       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n<p>By running the <code>ps</code> command, you may also check whether the <code>mpd</code> server was started on your system.</p>\nQEMU - Buildroot<pre><code># ps | grep mpd\n  105 root     /usr/bin/mpd\n  134 root     grep mpd\n</code></pre>"},{"location":"qemu/buildroot/#analyzing-dependencies","title":"Analyzing dependencies","text":"<p>It\u2019s always useful to understand the dependencies drawn by the packages we build. First we need to install Graphviz and a PDF viewer:</p>\n<pre><code>$ sudo apt install evince graphviz\n</code></pre>\n<p>Now, let\u2019s use Buildroot's target to generate a dependency graph. Once generated, it can ve viewed for visual inspection.</p>\n<pre><code>$ cd \"$LAB_PATH/buildroot/\"\n$ make graph-depends\nGetting dependency tree...\ndot  -Tpdf \\\n        -o /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/graphs/graph-depends.pdf \\\n        /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/graphs/graph-depends.dot\n$ evince output/graphs/graph-depends.pdf\n</code></pre>\n<p>In particular, you can see that adding MPD and its client required to compile Meson for the\nhost, and in turn, Python 3 for the host too. This substantially contributed to the build time.</p>\n<p></p>"},{"location":"qemu/buildroot/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ tar cfJv \"$LAB_PATH/buildroot-sd.img.tar.xz\" sd.img\n$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-buildroot.cpio.xz\"\n$ cd \"$LAB_PATH/buildroot/output/images/\"\n$ tar cfJv \"$LAB_PATH/buildroot-rootfs.tar.xz\" rootfs.tar\n$ cd /srv/tftp/\n$ tar cfJv \"$LAB_PATH/buildroot-tftp.tar.xz\" zImage vexpress-v2p-ca9.dtb\n</code></pre>"},{"location":"qemu/buildroot/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant\n \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/debootstrap/","title":"<code>debootstrap</code>","text":"<p>It can be interesting to emulate a Debian ARM target system directly on your host machine. On the other chapters, we tried with: barebone BusyBox, Buildroot, and custom Yocto (TODO). Within this document, we're focusing on the creation of a fake rootfs, to mimic an actual rootfs of our emulated target machine.</p> <p>As explained within the Exploring BeagleBone Black, there can be two common ways: the old-school via chroot, or via a modern systemd-nspawn.</p>"},{"location":"qemu/debootstrap/#required-tools","title":"Required tools","text":"<ul> <li> <p>Ubuntu packages:</p> <p><code>debian-archive-keyring</code> <code>debootstrap</code> <code>qemu-user-static</code> <code>systemd-container</code></p> </li> </ul>"},{"location":"qemu/debootstrap/#debootstrap-chroot","title":"<code>debootstrap</code> + <code>chroot</code>","text":"<p>Let's enter our workspace.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/debootstrap\"\n$ mkdir -p $LAB_PATH\n</code></pre> <p>In order to use <code>debootstrap</code>, first install it, along with <code>qemu-user-static</code> (our emulation engine). On Ubuntu, we also need to install the keyring expected by Debian's debootstrap.</p> <pre><code>$ sudo apt install debian-archive-keyring debootstrap qemu-user-static\n</code></pre> <p>The <code>debootstrap</code> installs a basic Debian-based rootf, with minimal distro and tools. We have to specify the CPU architecture, the Debian release (bullseye is the current one), and the destination folder. Since a rootfs contains sensible data (such as the <code>/dev/</code> and <code>/sys/</code> folders), it must be issued with root access. We're using the default Debian keyring to take pa</p> <p><pre><code>$ cd $LAB_PATH\n$ sudo debootstrap --arch=armhf --verbose --foreign bullseye rootfs\nI: Checking Release signature\n    ...\n$ ls rootfs/\nbin  boot  debootstrap  dev  etc  home  lib  proc  root  run  sbin  sys  tmp  usr  var\n</code></pre> Let's run <code>chroot</code> with root privileges on or newly-created rootfs. Once entered, the shell is confined to the content of this rootfs. To exit from this chroot jail, just launch <code>exit</code> command.</p> <pre><code>$ sudo chroot rootfs/\nI have no name!@vm:/# uname -a\nLinux vm 5.19.0-38-generic #39~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Mar 17 21:16:15 UTC 2 armv7l GNU/Linux\nI have no name!@vm:/# whoami\nwhoami: cannot find name for user ID 0: No such file or directory\n</code></pre> <p>As you can see, our target machine is actually an emulated ARM architecture, but we aren't finished yet! Indeed, our user isn't even registered yet, strangely named <code>I have no name!</code>. This is because we need to conclude a second stage installation phase for <code>debootstrap</code>, with the <code>--second-stage</code> argument within the target itself. The second stage resumes the package installation, and finalizes it to make the target system ready for proper use the next time it's run. We'd better set the root password then (let's just set it to <code>pass</code>).</p> <pre><code>I have no name!@vm:/# /debootstrap/debootstrap --second-stage\nI: Installing core packages...\n    ...\nI: Base system installed successfully.\nI have no name!@vm:/# exit\nexit\n$ sudo chroot rootfs/\nroot@vm:/# whoami\nroot\nroot@vm:/# passwd -d root\nroot@vm:/# passwd\nNew password: pass\nRetype new password: pass\npasswd: password updated successfully\nI have no name!@vm:/# exit\nexit\n</code></pre> <p>Congratulations! Your fake minimal Debian for ARM is ready!</p>"},{"location":"qemu/debootstrap/#systemd-container","title":"<code>systemd</code> container","text":"<p>To work with the <code>systemd</code> container, you need to install its package first. It's recommended to enable unpriviledged user namespaces on the host. You can restart the <code>systemd</code> service then.</p> <pre><code>$ sudo apt install systemd-container\n$ sudo sh -c 'echo \"kernel.unprivileged_userns_clone=1\" &gt; /etc/sysctl.d/nspawn.conf'\n$ sudo systemctl restart systemd-sysctl.service\n</code></pre> <p>It's now time to setup the rootfs we already created for usage with <code>systemd</code>. We're going to re-use the rootfs made with <code>chroot</code> previously into the <code>rootfs</code> folder, calling the machine container <code>fake</code>. To be able to log in, we need to make sure the <code>dbus</code> package is installed on the target. After installation, let's <code>exit</code> from the container.</p> <pre><code>$ MACHINE_NAME=\"fake\"\n$ sudo systemd-nspawn -D rootfs -U -M $MACHINE_NAME\nSpawning container fake on /home/me/embedded-linux-qemu-labs/debootstrap/rootfs.\nPress ^] three times within 1s to kill container.\nSelected user namespace base 1736310784 and range 65536.\nFailed to correct timezone of container, ignoring: Value too large for defined data type\nroot@fake:~# apt install dbus\n    ...\nroot@fake:~# exit\nlogout\nContainer fake exited successfully.\n</code></pre> <p>Ok, our <code>chroot</code> replacement is working! But, we can do even more with this <code>systemd</code> service: we can launch containers! The <code>systemd</code> containers must be running on machine images, usually from the <code>/usr/lib/machines/</code> folder. We already have a machine, we just need to put it into place, or rather, bind a mount point to our <code>rootfs</code> folder (symlinks don't seem to work properly for this service).</p> <pre><code>$ sudo mkdir -p \"/var/lib/machines/$MACHINE_NAME\"\n$ sudo mount --bind \"$LAB_PATH/rootfs\" \"/var/lib/machines/$MACHINE_NAME\"\n</code></pre> <p>To test that the container works, we can now spawn a new contaier against the machine we've just created, check its status, log in, shutdown, and stop the container.</p> <pre><code>$ sudo machinectl start $MACHINE_NAME\n$ machinectl list\nMACHINE CLASS     SERVICE        OS     VERSION ADDRESSES\nfake    container systemd-nspawn debian 11      -\n1 machines listed.\n$ sudo systemctl status systemd-nspawn@$MACHINE_NAME\n\u25cf systemd-nspawn@fake.service - Container fake\n     Loaded: loaded (/lib/systemd/system/systemd-nspawn@.service; disabled; vendor preset: enabled)\n     Active: active (running) since Tue 2023-04-11 18:41:18 CEST; 33s ago\n       Docs: man:systemd-nspawn(1)\n   Main PID: 16568 (systemd-nspawn)\n     Status: \"Container running: Startup finished in 2.569s.\"\n      Tasks: 18 (limit: 16384)\n     Memory: 69.0M\n        CPU: 5.384s\n     CGroup: /machine.slice/systemd-nspawn@fake.service\n    ...\n$ sudo machinectl login $MACHINE_NAME\nConnected to machine fake. Press ^] three times within 1s to exit session.\nDebian GNU/Linux 11 vm pts/1\nvm login: root\nPassword: pass\nLinux vm 5.15.0-67-generic #74-Ubuntu SMP Wed Feb 22 14:14:39 UTC 2023 armv7l\nThe programs included with the Debian GNU/Linux system are free software;\nthe exact distribution terms for each program are described in the\nindividual files in /usr/share/doc/*/copyright.\nDebian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent\npermitted by applicable law.\nroot@vm:~# shutdown -h now\n\nMachine fake terminated.\n$ sudo machinectl stop $MACHINE_NAME\n</code></pre> <p>Finally, we can unmount out machine mounting point.</p> <pre><code>$ sudo umount \"/var/lib/machines/$MACHINE_NAME\"\n</code></pre>"},{"location":"qemu/debootstrap/#references","title":"References","text":"<ul> <li> <p>https://help.ubuntu.com/community/DebootstrapChroot/</p> </li> <li> <p>https://wiki.ubuntu.com/ARM/RootfsFromScratch/QemuDebootstrap/</p> </li> <li> <p>https://wiki.debian.org/nspawn/</p> </li> <li> <p>https://www.baeldung.com/linux/bind-mounts/</p> </li> <li> <p>https://blog.entek.org.uk/technology/2020/06/06/building-debian-vms-with-debootstrap.html</p> </li> <li> <p>http://exploringbeaglebone.com/</p> </li> </ul>"},{"location":"qemu/debugging/","title":"App - Remote debug","text":""},{"location":"qemu/debugging/#objectives","title":"Objectives","text":"<ul> <li> <p>Use <code>strace</code> and <code>ltrace</code> to diagnose program issues.</p> </li> <li> <p>Use <code>gdbserver</code> and a cross-debugger to remotely debug an embedded application.</p> </li> </ul>"},{"location":"qemu/debugging/#setup","title":"Setup","text":"<p>Go to the <code>$HOME/embedded-linux-qemu-labs/debugging/</code> directory. Create an <code>nfsroot</code> directory there.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/debugging\"\n$ cd $LAB_PATH\n$ mkdir nfsroot\n</code></pre>"},{"location":"qemu/debugging/#debugging-setup","title":"Debugging setup","text":"<p>Because of issues in <code>gdb</code> and <code>ltrace</code> in the uClibc version that we are using in our toolchain, we'r going to use a different toolchain in this lab, based on <code>glibc</code>.</p> <p>As <code>glibc</code> has more complete features than lighter libraries, it looks like a good idea to perform your application debugging work with a <code>glibc</code> toolchain first, and switch to lighter libraries once your application and software stack are production ready.</p> <p>As done in the Buildroot lab, clone once again the Buildroot git repository, and checkout the tag corresponding to the <code>2022.02</code> release (Long Term Support), which we have tested for this lab. You could re-use the installation already performed previously.</p> <p>Then, in the <code>menuconfig</code> interface, configure the target architecture as done previously, but configure the toolchain and target packages differently.</p> <p>In <code>Toolchain</code>:</p> <ul> <li> <p><code>Toolchain type</code> = <code>External toolchain</code>.</p> </li> <li> <p><code>Toolchain</code> = <code>Bootlin toolchains</code>.</p> </li> <li> <p><code>Toolchain origin</code> = <code>Toolchain to be downloaded and installed</code>.</p> </li> <li> <p><code>Bootlin toolchain variant</code> = <code>armv7-eabihf glibc stable 2021.11-1</code>.</p> </li> <li> <p>Enable <code>Copy gdb server to the Target</code>.</p> </li> </ul> <p>In <code>Target packages</code> \u2192 <code>Debugging, profiling and benchmark</code>:</p> <ul> <li> <p>Enable <code>ltrace</code>.</p> </li> <li> <p>Enable <code>strace</code>.</p> </li> </ul> <p>Now, <code>&lt;Save&gt;</code> the <code>.config</code>, backup it, and build your root filesystem.</p> <pre><code>$ cd \"$LAB_PATH/../buildroot/buildroot/\"\n$ make menuconfig\n$ cp .config \"$LAB_PATH/buildroot-debugging.config\"\n$ export MAKEFLAGS=-j$(nproc)\n$ make clean\n$ make\n</code></pre> <p>Go back to the lab directory and extract the <code>buildroot/output/images/rootfs.tar</code> archive into the <code>nfsroot</code> directory. Add this directory to the <code>/etc/exports</code> file and run <code>sudo exportfs -r</code>. You can of course remap the symlink as done previously. Boot your ARM board over NFS on this new filesystem, using the same kernel as before.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ tar xfv \"$LAB_PATH/../buildroot/buildroot/output/images/rootfs.tar\"\n$ sudo rm -f /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/nfsroot/\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-qemu-labs/debugging/nfsroot/'\n$ sudo chown -R tftp:tftp /srv/nfs\n$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre>"},{"location":"qemu/debugging/#using-strace","title":"Using <code>strace</code>","text":"<p>The <code>strace</code> allows to trace all the system calls made by a process: opening, reading and writing files, starting other processes, accessing time, etc. When something goes wrong in your application, <code>strace</code> is an invaluable tool to see what it actually does, even when you don\u2019t have the source code.</p> <p>Update the <code>PATH</code>. With your cross-compiling toolchain compile the <code>data/vista-emulator.c</code> program, copy the resulting binary to the <code>/root</code> directory of the root filesystem and then strip it.</p> <pre><code>$ export PATH=\"$HOME/embedded-linux-qemu-labs/buildroot/buildroot/output/host/bin:$PATH\"\n$ cd \"$LAB_PATH/data/\"\n$ arm-linux-gcc -o vista-emulator vista-emulator.c\n$ cp vista-emulator \"$LAB_PATH/nfsroot/root/\"\n</code></pre> <p>Back to target system, try to run the <code>/root/vista-emulator</code> program. It should hang indefinitely! Interrupt this program by hitting Ctrl+C.</p> <p>Now, running this program again through the <code>strace</code> command and understand why it hangs. You can guess it without reading the source code!</p> QEMU - Buildroot<pre><code># strace /root/vista-emulator\nexecve(\"/root/vista-emulator\", [\"/root/vista-emulator\"], 0x7ed7ce60 /* 10 vars */) = 0\n    ...\nopenat(AT_FDCWD, \"/etc/vista.key\", O_RDONLY) = -1 ENOENT (No such file or directory)\nclock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7e926c70) = 0\nopenat(AT_FDCWD, \"/etc/vista.key\", O_RDONLY) = -1 ENOENT (No such file or directory)\nclock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7e926c70) = 0\nopenat(AT_FDCWD, \"/etc/vista.key\", O_RDONLY) = -1 ENOENT (No such file or directory)\nclock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7e926c70) = 0\n    ...\n</code></pre> <p>Interrupt again by hitting Ctrl+C.</p> <p>Now add what the program was waiting for, and see your program proceed to another bug, failing with a mighty segmentation fault.</p> QEMU - Buildroot<pre><code># touch /etc/vista.key\n# strace /root/vista-emulator\nexecve(\"/root/vista-emulator\", [\"/root/vista-emulator\"], 0x7efe8e60 /* 10 vars */) = 0\n    ...\nopenat(AT_FDCWD, \"/etc/vista.key\", O_RDONLY) = 3\nclose(3)                                = 0\nmmap2(NULL, 659456, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x1b100000\nmmap2(NULL, 659456, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x1b05f000\nmmap2(NULL, 659456, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x1afbe000\n    ...\nmmap2(NULL, 659456, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7eed9000\nmmap2(NULL, 659456, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = -1 ENOMEM (Cannot allocate memory)\nbrk(0x4e3000)                           = 0x443000\nmmap2(NULL, 1048576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = -1 ENOMEM (Cannot allocate memory)\n--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=NULL} ---\n+++ killed by SIGSEGV +++\nSegmentation fault\n</code></pre>"},{"location":"qemu/debugging/#using-ltrace","title":"Using <code>ltrace</code>","text":"<p>Now run the program through <code>ltrace</code>. You should see what the program does: it tries to consume as much system memory as it can! You can also notice that <code>ltrace</code> makes the execution much slower than with <code>strace</code>.</p> QEMU - Buildroot<pre><code># ltrace /root/vista-emulator\n__libc_start_main([ \"/root/vista-emulator\" ] &lt;unfinished ...&gt;\nfopen(\"/etc/vista.key\", \"r\")                     = 0x432190\nfclose(0x432190)                                 = 0\nmalloc(655360)                                   = 0x76d3e008\nstrstr(\"\", \"Mickey Mouse\")                       = nil\nmalloc(655360)                                   = 0x76c9d008\nstrstr(\"\", \"Mickey Mouse\")                       = nil\nmalloc(655360)                                   = 0x76bfc008\n    ...\nmalloc(655360)                                   = 0x7ef56008\nstrstr(\"\", \"Mickey Mouse\")                       = nil\nmalloc(655360)                                   = nil\nstrstr(nil, \"Mickey Mouse\" &lt;no return ...&gt;\n--- SIGSEGV (Segmentation fault) ---\n+++ killed by SIGSEGV +++\n</code></pre> <p>Also run the program through <code>ltrace -c</code>, to see what function call statistics this utility can provide.</p> QEMU - Buildroot<pre><code># ltrace -c /root/vista-emulator\n% time     seconds  usecs/call     calls      function\n------ ----------- ----------- --------- --------------------\n 55.92   39.256634    39256634         1 __libc_start_main\n 25.19   17.688146        5484      3225 malloc\n 18.86   13.242600        4106      3225 strstr\n  0.02    0.013549       13549         1 fopen\n  0.01    0.006764        6764         1 fclose\n------ ----------- ----------- --------- --------------------\n100.00   70.207693                  6453 total\n</code></pre> <p>It\u2019s also interesting to run the program again with <code>strace</code> (or, refer to the previous paragraph). You can see that memory allocations translate into <code>mmap()</code> system calls. That\u2019s how you can recognize them when you\u2019re using <code>strace</code>.</p>"},{"location":"qemu/debugging/#using-gdbserver","title":"Using <code>gdbserver</code>","text":"<p>We are now going to use gdbserver to understand why the program segfaults.</p> <p>Compile <code>vista-emulator.c</code> again with the <code>-g</code> option to include debugging symbols. This time, just keep it on your workstation, as you already have the version without debugging symbols on your target.</p> <pre><code>$ cd \"$LAB_PATH/data/\"\n$ arm-linux-gcc -g -o vista-emulator vista-emulator.c\n</code></pre> <p>Then, on the target side, run <code>vista-emulator</code> under <code>gdbserver</code>, which will listen on a TCP port for a connection from <code>gdb</code>, and will control the execution of <code>vista-emulator</code> according to the <code>gdb</code> commands.</p> QEMU - Buildroot<pre><code># gdbserver localhost:2345 /root/vista-emulator\nProcess /root/vista-emulator created; pid = 160\nListening on port 2345\n</code></pre> <p>On the host side, run <code>arm-linux-gdb</code> (also found in your toolchain). This way, <code>gdb</code> starts and loads the debugging information from the <code>vista-emulator</code> binary that was compiled with <code>-g</code>. We need to tell where to find our libraries, since they are not present in the default <code>/lib/</code> and <code>/usr/lib/</code> directories on your workstation. This is done by setting the <code>sysroot</code> variable of <code>gdb</code>. We do this directly by the command line (<code>-ex</code> argument) for convenience.</p> <pre><code>$ cd \"$LAB_PATH/data/\"\n$ BUILDROOT_STAGING=\"$LAB_PATH/../buildroot/buildroot/output/staging\"\n$ arm-linux-gdb  -ex \"set sysroot $BUILDROOT_STAGING\"  vista-emulator\n    ...\nReading symbols from ./vista-emulator...\n</code></pre> <p>Tell <code>gdb</code> to connect to the remote target system, and it will break at the <code>_start()</code> library function.</p> <pre><code>(gdb) target remote 10.0.2.69:2345\nRemote debugging using 10.0.2.69:2345\nReading symbols from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/ld-linux-armhf.so.3...\n0x76fc88c0 in _start ()\n   from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/ld-linux-armhf.so.3\n</code></pre> <p>Then, you can use <code>gdb</code> as usual to set breakpoints, look at the source code, run the application step by step, etc. Graphical versions of <code>gdb</code> (such as <code>ddd</code>) can also be used in the same way. In our case, we\u2019ll just start the program and wait for it to hit the segmentation fault.</p> <pre><code>(gdb) continue\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x76edbbd0 in strchr () from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/libc.so.6\n</code></pre> <p>You could then ask for a backtrace to see where this happened.</p> <pre><code>(gdb) backtrace\n#0  0x76edbbd0 in strchr ()\n   from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/libc.so.6\n#1  0x76edd11c in strstr ()\n   from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/libc.so.6\n#2  0x00400784 in log_activity (buffer=0x0) at vista-emulator.c:39\n#3  0x00400808 in init_resources () at vista-emulator.c:52\n#4  0x0040085c in main () at vista-emulator.c:72\n</code></pre> <p>This will tell you that the segmentation fault occurred in a function of the C library, called by our program. This should help you in finding the bug in our application.</p> <p>Finally, <code>quit</code> GDB to close the debugging session.</p> <pre><code>(gdb) set confirm off\n(gdb) quit\n</code></pre>"},{"location":"qemu/debugging/#post-mortem-analysis","title":"Post mortem analysis","text":"<p>Configure your shell on the target to get a core file dumped when you run <code>vista-emulator</code> again.</p> QEMU - Buildroot<pre><code># ulimit -c unlimited\n# echo \"vista-emulator.core\" &gt; /proc/sys/kernel/core_pattern\n# /root/vista-emulator\nSegmentation fault (core dumped)\n# du -h vista-emulator.core\n12.7M   vista-emulator.core\n# chmod a+r vista-emulator.core\n</code></pre> <p>Once you have such a file, inspect it with <code>arm-linux-gdb</code> on the host, set the <code>sysroot</code> setting, and then generate a backtrace to see where the program crashed. This way, you can have information about the crash without running the program through the debugger.</p> <p>Because the executable on the target does not contain debug information (it was compiled without the <code>-g</code> option), and because the core dump holds the absolute paths of the target, we have to emulate the state of the target sysroot somehow. One way works by copying the debug executable and the core dump to the corresponding places within the <code>staging</code> folder by Buildroot. With <code>set sysroot</code>, <code>gdb</code> sees the debug files as if they were there on the fake target.</p> Folder structure excerpts to analyze our core dump<pre><code>[TARGET]\n/                            &lt;&lt;&lt;  host NFS: $LAB_PATH/nfsroot/\n\u251c\u2500\u2500 lib/\n|   \u2514\u2500\u2500 libc.so.6\n\u2514\u2500\u2500 root/\n \u00a0\u00a0 \u251c\u2500\u2500 vista-emulator       &lt;&lt;&lt;  without debug symbols\n    \u2514\u2500\u2500 vista-emulator.core\n\n[HOST]\nbuildroot/output/staging/    &lt;&lt;&lt;  gdb: sysroot\n\u251c\u2500\u2500 lib/\n|   \u2514\u2500\u2500 libc.so.6\n\u2514\u2500\u2500 root/\n \u00a0\u00a0 \u251c\u2500\u2500 vista-emulator       &lt;&lt;&lt;  with debug symbols, copied from: $LAB_PATH/data/\n    \u2514\u2500\u2500 vista-emulator.core  &lt;&lt;&lt;  copied from: $LAB_PATH/nsfroot/root/\n</code></pre> <p>Here's the sequence of operations, switching between the shell and <code>gdb</code>:</p> <pre><code>$ cd $BUILDROOT_STAGING\n$ cp \"$LAB_PATH/data/vista-emulator\" root/\n$ cp \"$LAB_PATH/nfsroot/root/vista-emulator.core\" root/\n$ arm-linux-gdb  -ex \"set sysroot $BUILDROOT_STAGING\"\n    ...\n</code></pre> <pre><code>(gdb) file vista-emulator\nReading symbols from vista-emulator...\n(gdb) core-file vista-emulator.core\n[New LWP 122]\nCore was generated by `/root/vista-emulator'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x76e93bd0 in strchr ()\n   from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/libc.so.6\n(gdb) backtrace\n#0  0x76e93bd0 in strchr ()\n   from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/libc.so.6\n#1  0x76e9511c in strstr ()\n   from /home/me/embedded-linux-qemu-labs/buildroot/buildroot/output/staging/lib/libc.so.6\n#2  0x00490784 in log_activity (buffer=0x0) at vista-emulator.c:39\n#3  0x00490808 in init_resources () at vista-emulator.c:52\n#4  0x0049085c in main () at vista-emulator.c:72\n(gdb) set confirm off\n(gdb) quit\n</code></pre> <pre><code>$ rm root/vista-emulator\n$ rm root/vista-emulator.core\n</code></pre>"},{"location":"qemu/debugging/#what-to-remember","title":"What to remember","text":"<p>During this lab, we learned that...</p> <ul> <li> <p>It\u2019s easy to study the behavior of programs and diagnose issues without even having the source code, thanks to <code>strace</code> and <code>ltrace</code>.</p> </li> <li> <p>You can leave a small <code>gdbserver</code> program (about 300 KB) on your target that allows to debug target applications, using a standard <code>gdb</code> debugger on the development host.</p> </li> <li> <p>It is fine to strip applications and binaries on the target machine, as long as the programs and libraries with debugging symbols are available on the development host.</p> </li> <li> <p>Thanks to core dumps, you can know where a program crashed, without having to reproduce the issue by running the program through the debugger.</p> </li> </ul>"},{"location":"qemu/debugging/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/hardware/","title":"Accessing Hardware Devices","text":"<p>Important: The manipulations in this lab are limited because we\u2019re working with an emulated platform, not with real hardware. It would be best to get your hands on the hardware platforms we support. Our instructions for such platforms really cover practising with internal and external hardware devices.</p>"},{"location":"qemu/hardware/#objectives","title":"Objectives","text":"<ul> <li>Learn how to access hardware devices.</li> </ul>"},{"location":"qemu/hardware/#setup","title":"Setup","text":"<p>Go to the <code>$HOME/embedded-linux-qemu-labs/hardware</code> directory, which provides useful files for this lab. However, we will go on booting the system through NFS, using the root filesystem built by the previous lab.</p>"},{"location":"qemu/hardware/#exploring-dev","title":"Exploring <code>/dev</code>","text":"<p>Start by exploring <code>/dev/</code> on your target system (with QEMU).</p> QEMU - BusyBox<pre><code># ls /dev/\nconsole          ptypc            tty35            ttyAMA2\ncpu_dma_latency  ptypd            tty36            ttyAMA3\ndri              ptype            tty37            ttyp0\nfb0              ptypf            tty38            ttyp1\nfull             random           tty39            ttyp2\ngpiochip0        rtc0             tty4             ttyp3\ngpiochip1        snd              tty40            ttyp4\ngpiochip2        tty              tty41            ttyp5\ngpiochip3        tty0             tty42            ttyp6\nhwrng            tty1             tty43            ttyp7\ninput            tty10            tty44            ttyp8\nkmsg             tty11            tty45            ttyp9\nmem              tty12            tty46            ttypa\nmmcblk0          tty13            tty47            ttypb\nmmcblk0p1        tty14            tty48            ttypc\nmmcblk0p2        tty15            tty49            ttypd\nmmcblk0p3        tty16            tty5             ttype\nmtd0             tty17            tty50            ttypf\nmtd0ro           tty18            tty51            ubi_ctrl\nmtd1             tty19            tty52            urandom\nmtd1ro           tty2             tty53            usbmon0\nmtdblock0        tty20            tty54            vcs\nmtdblock1        tty21            tty55            vcs1\nnull             tty22            tty56            vcs2\nptmx             tty23            tty57            vcs3\nptyp0            tty24            tty58            vcs4\nptyp1            tty25            tty59            vcsa\nptyp2            tty26            tty6             vcsa1\nptyp3            tty27            tty60            vcsa2\nptyp4            tty28            tty61            vcsa3\nptyp5            tty29            tty62            vcsa4\nptyp6            tty3             tty63            vcsu\nptyp7            tty30            tty7             vcsu1\nptyp8            tty31            tty8             vcsu2\nptyp9            tty32            tty9             vcsu3\nptypa            tty33            ttyAMA0          vcsu4\nptypb            tty34            ttyAMA1          zero\n</code></pre> <p>Here are a few noteworthy device files that you will see:</p> <ul> <li> <p>Terminal devices: devices starting with <code>tty</code>.   Terminals are user interfaces taking text as input and producing text as output, and are typically used by interactive shells.   In particular, you will find console which matches the device specified through <code>console=</code> in the kernel command line (U-Boot's <code>bootargs</code>).   You will also find the <code>ttyAMA0</code> device file we used for the emulated debug serial port.</p> </li> <li> <p>Pseudo-terminal devices: devices starting with <code>pty</code>, used when you connect through SSH for example.   Those are virtual devices, but there are so many in <code>/dev/</code> that we wanted to give a description here.</p> </li> <li> <p>MMC devices and partitions: devices starting with <code>mmcblk</code>.   You should here recognize the MMC devices on your system, and the associated partitions.</p> </li> </ul> <p>Don\u2019t hesitate to explore <code>/dev/</code> on your workstation too!</p> <pre><code>$ ls /dev/\nautofs           loop1         rtc0      tty2   tty47      ttyS15   vboxguest\nblock            loop10        sda       tty20  tty48      ttyS16   vboxuser\nbsg              loop11        sda1      tty21  tty49      ttyS17   vcs\nbtrfs-control    loop12        sdb       tty22  tty5       ttyS18   vcs1\nbus              loop13        sdb1      tty23  tty50      ttyS19   vcs2\ncdrom            loop14        sdc       tty24  tty51      ttyS2    vcs3\nchar             loop2         sg0       tty25  tty52      ttyS20   vcs4\nconsole          loop3         sg1       tty26  tty53      ttyS21   vcs5\ncore             loop4         sg2       tty27  tty54      ttyS22   vcs6\ncpu              loop5         sg3       tty28  tty55      ttyS23   vcsa\ncpu_dma_latency  loop6         shm       tty29  tty56      ttyS24   vcsa1\ncuse             loop7         snapshot  tty3   tty57      ttyS25   vcsa2\ndisk             loop8         snd       tty30  tty58      ttyS26   vcsa3\ndma_heap         loop9         sr0       tty31  tty59      ttyS27   vcsa4\ndri              loop-control  stderr    tty32  tty6       ttyS28   vcsa5\necryptfs         mapper        stdin     tty33  tty60      ttyS29   vcsa6\nfb0              mcelog        stdout    tty34  tty61      ttyS3    vcsu\nfd               mem           tty       tty35  tty62      ttyS30   vcsu1\nfull             mqueue        tty0      tty36  tty63      ttyS31   vcsu2\nfuse             net           tty1      tty37  tty7       ttyS4    vcsu3\nhidraw0          null          tty10     tty38  tty8       ttyS5    vcsu4\nhpet             nvram         tty11     tty39  tty9       ttyS6    vcsu5\nhugepages        port          tty12     tty4   ttyprintk  ttyS7    vcsu6\nhwrng            ppp           tty13     tty40  ttyS0      ttyS8    vfio\ni2c-0            psaux         tty14     tty41  ttyS1      ttyS9    vga_arbiter\ninitctl          ptmx          tty15     tty42  ttyS10     udmabuf  vhci\ninput            pts           tty16     tty43  ttyS11     uhid     vhost-net\nkmsg             random        tty17     tty44  ttyS12     uinput   vhost-vsock\nlog              rfkill        tty18     tty45  ttyS13     urandom  zero\nloop0            rtc           tty19     tty46  ttyS14     userio   zfs\n</code></pre>"},{"location":"qemu/hardware/#exploring-sys","title":"Exploring <code>/sys</code>","text":"<p>The next thing you can explore is the sysfs filesystem.</p> <p>A good place to start is <code>/sys/class/</code>, which exposes devices classified by the kernel frameworks which manage them.</p> QEMU - BusyBox<pre><code># ls /sys/class/\nata_device    drm           mem           ptp           tty\nata_link      graphics      misc          regulator     ubi\nata_port      hwmon         mmc_host      rtc           usbmon\nbacklight     i2c-adapter   mtd           scsi_device   vc\nbdi           input         net           scsi_disk     virtio-ports\nblock         leds          power_supply  scsi_host     vtconsole\ndevlink       mdio_bus      pps           sound         wakeup\n</code></pre> <p>For example, go to <code>/sys/class/net/</code>, and you will see all the networking interfaces on your system, whether they are internal, external or virtual ones.</p> QEMU - BusyBox<pre><code># ls /sys/class/net/\neth0  lo\n</code></pre> <p>Find which subdirectory corresponds to the network connection to your host system, and then check device properties such as:</p> <ul> <li> <p><code>speed</code>: will show you whether this is a gigabit or hundred megabit interface.</p> </li> <li> <p><code>address</code>: will show the device MAC address. No need to get it from a complex command!</p> </li> <li> <p><code>statistics/rx_bytes</code> will show you how many bytes were received on this interface.</p> </li> </ul> <p>Don\u2019t hesitate to look for further interesting properties by yourself!</p> QEMU - BusyBox<pre><code># ls /sys/class/net/eth0/\naddr_assign_type      flags                 phys_port_name\naddr_len              gro_flush_timeout     phys_switch_id\naddress               ifalias               power\nbroadcast             ifindex               proto_down\ncarrier               iflink                queues\ncarrier_changes       link_mode             speed\ncarrier_down_count    mtu                   statistics\ncarrier_up_count      name_assign_type      subsystem\ndev_id                napi_defer_hard_irqs  testing\ndev_port              netdev_group          threaded\ndevice                operstate             tx_queue_len\ndormant               phydev                type\nduplex                phys_port_id          uevent\n# cat /sys/class/net/eth0/speed\n100\n# cat /sys/class/net/eth0/address\n52:54:00:12:34:56\n# cat /sys/class/net/eth0/statistics/rx_bytes\n963618\n</code></pre> <p>You can also check whether <code>/sys/class/thermal/</code> exists and is not empty on your system. That\u2019s the thermal framework, and it allows to access temperature measures from the thermal sensors on your system.</p> QEMU - BusyBox<pre><code># ls /sys/class/thermal/\nls: /sys/class/thermal: No such file or directory\n</code></pre> <p>Next, you can now explore all the buses (virtual or physical) available on your system, by checking the contents of <code>/sys/bus/</code>. In particular, go to <code>/sys/bus/mmc/devices/</code> to see all the MMC devices on your system. Go inside the directory for the first device and check several files (for example):</p> <ul> <li> <p><code>serial</code>: the serial number for your device.</p> </li> <li> <p><code>preferred_erase_size</code>: the preferred erase block for your device. It\u2019s recommended that partitions start at multiples of this size.</p> </li> <li> <p><code>name</code>: the product name for your device. You could display it in a user interface or log file, for example.</p> </li> </ul> QEMU - BusyBox<pre><code># ls /sys/bus/\nac97          cpu           i2c           platform      usb\namba          dp-aux        mdio_bus      scsi          virtio\nclockevents   event_source  mmc           sdio          workqueue\nclocksource   gpio          mmc_rpmb      serio\ncontainer     hid           nvmem         soc\n# ls /sys/bus/mmc/devices/\nmmc0:4567\n# ls /sys/bus/mmc/devices/mmc0:4567/\nblock                 hwrev                 scr\ncid                   manfid                serial\ncsd                   name                  ssr\ndate                  ocr                   subsystem\ndriver                oemid                 type\ndsr                   power                 uevent\nerase_size            preferred_erase_size\nfwrev                 rca\n# cat /sys/bus/mmc/devices/mmc0:4567/serial\n0xdeadbeef\n# cat /sys/bus/mmc/devices/mmc0:4567/preferred_erase_size\n4194304\n# cat /sys/bus/mmc/devices/mmc0:4567/name\nQEMU!\n</code></pre> <p>Don\u2019t hesitate to spend more time exploring <code>/sys/</code> on your system!</p>"},{"location":"qemu/hardware/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/kernel/","title":"Linux Kernel","text":""},{"location":"qemu/kernel/#objectives","title":"Objectives","text":"<ul> <li> <p>Get the kernel sources from git, using the official Linux source tree.</p> </li> <li> <p>Fetch the sources for the stable Linux releases, by declaring a remote tree and getting stable branches from it.</p> </li> <li> <p>Set up a cross-compiling environment.</p> </li> <li> <p>Cross compile the kernel for the QEMU ARM Versatile Express for Cortex-A9.</p> </li> <li> <p>Use U-Boot to download the kernel to the target board.</p> </li> <li> <p>Check that the custom kernel starts the system.</p> </li> </ul>"},{"location":"qemu/kernel/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages: those from the previous labs.</p> </li> <li> <p>Linux kernel, either as:</p> <ul> <li> <p>Linus Torvalds' git repository tag <code>5.15</code></p> </li> <li> <p>Source code archive for bleeding-edge release <code>5.15</code></p> </li> <li> <p>Stable git repository tag <code>5.15.104</code></p> </li> <li> <p>Source code archive for stable release <code>5.15.104</code></p> </li> </ul> </li> </ul>"},{"location":"qemu/kernel/#main-repository","title":"Main repository","text":"<p>Let's first create the <code>kernel</code> folder under or lab folder:</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/kernel\"\n$ mkdir -p $LAB_PATH\n$ cd $LAB_PATH\n</code></pre> <p>To begin working with the Linux kernel sources, we need to clone its reference git tree, the one managed by Linus Torvalds himself.</p> <p>This requires downloading some gigabytes of data. If you have a very fast access to the Internet, you can do it directly by connecting to the official git repository (our main remote repository):</p> <pre><code>$ git clone \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux/\"\n$ cd linux\n</code></pre> <p>If your internet access is not fast enough, you can download a git snapshot of a specific version; for example, release <code>5.15</code>. You just have to extract this archive in the current <code>kernel</code> directory, just like we did for the previous labs:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"5.15\"\n$ wget \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-${label}.tar.gz\"\n$ tar xfv \"linux-${label}.tar.gz\"\n$ mv linux*/ linux\n$ cd linux\n</code></pre>"},{"location":"qemu/kernel/#stable-releases","title":"Stable releases","text":"<p>The Linux kernel repository from Linus Torvalds contains all the main releases of Linux, but not the stable releases: they are maintained by a separate team, and hosted in a separate repository.</p> <p>After having downloaded the main repository, we have to add this separate <code>stable</code> repository as additional remote to be able to use the stable releases.</p> <pre><code>$ cd $LAB_PATH/linux\n$ git remote add stable \"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux/\"\n$ git fetch stable\n$ git branch -a\n</code></pre> <p>We're going to checkout the stable branch for version <code>5.15.y</code>, aliased as a branch named after our labs; alternatively, we can choose the specific version <code>5.15.104</code>:</p> <pre><code>$ label=\"linux-5.15.y\"  # for the ongoing branch\n$ label=\"v5.15.104\"     # for our specific version\n$ git checkout -b embedded-linux-qemu \"stable/${label}\"\n</code></pre> <p>Again, if you internet speed is slow, or you want to save space, you can download a specific release archive directly. You can find the list by browsing the repository webpage; we tested this lab with version <code>5.15.104</code>, an LTS branch. Of course, this is an alternative to the main releases, so make sure that one wasn't extracted into our <code>linux</code> subfolder.</p> <pre><code>$ cd $LAB_PATH\n$ rm -rf linux/\n$ label=\"5.15.104\"\n$ wget \"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-${label}.tar.gz\"\n$ tar xfv \"linux-${label}.tar.gz\"\n$ mv linux*/ linux\n$ cd linux\n</code></pre>"},{"location":"qemu/kernel/#version-check","title":"Version check","text":"<p>First, execute the following command to check which version you currently have:</p> <pre><code>$ make kernelversion\n5.15.104\n</code></pre> <p>You can also open the <code>Makefile</code> and look at the first lines to find this information:</p> <pre><code>$ head -n6 Makefile | tail -n+2\nVERSION = 5\nPATCHLEVEL = 15\nSUBLEVEL = 104\nEXTRAVERSION =\nNAME = Trick or Treat\n</code></pre>"},{"location":"qemu/kernel/#configuration","title":"Configuration","text":"<p>To cross-compile Linux, you need to have a cross-compiling toolchain. We will use the cross-compiling toolchain that we previously produced, so we just need to add it to the <code>PATH</code>. We also need the <code>CROSS_COMPILE</code> prefix, and the <code>ARCH</code> label of the CPU architecture. You'd better parallelize with the <code>-j</code> option to save time. Quick reminder:</p> <pre><code>$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export ARCH=arm\n$ export MAKEFLAGS=-j$(nproc)\n</code></pre> <p>By running <code>make help</code>, look for the proper <code>Makefile</code> target to configure the kernel for your processor (within <code>less</code>, press the <code>[Q]</code> key to quit). In our case, use the configuration for the ARM Vexpress boards, <code>vexpress_defconfig</code>. So, apply this configuration, and then run <code>make menuconfig</code>.</p> <pre><code>$ make help | less\n$ make vexpress_defconfig\n$ make menuconfig\n</code></pre> <p>See: <code>menuconfig</code></p> <ul> <li> <p>Disable <code>CONFIG_GCC_PLUGINS</code>, which skips building special GCC plugins we don't need, requiring extra dependencies for the build.</p> </li> <li> <p>Add <code>CONFIG_DEVTMPFS_MOUNT</code> to your configuration.</p> </li> <li> <p>Add static support (instead of module) for the hardware random generator.   Without it, you would get annoying messages and lower performance.</p> <ul> <li>Set <code>CONFIG_HW_RANDOM=y</code>.</li> </ul> </li> </ul> <p>Now you can <code>&lt;Save&gt;</code> and backup:</p> <pre><code>$ cp .config ../kernel.config\n</code></pre>"},{"location":"qemu/kernel/#cross-compiling","title":"Cross compiling","text":"<p>You\u2019re now ready to cross-compile your kernel. Simply run <code>make</code> and wait for the kernel to be compiled. The build takes some time to perform \u2014 a clean build took around 10 minutes on an Intel i7 7700 laptop with 4 cores, of course within the Lubuntu VM.</p> <pre><code>$ make\n    ...\n  Kernel: arch/arm/boot/zImage is ready\n</code></pre> <p>Look at the end of the kernel build output to see which file contains the kernel image. You can also see the Device Tree <code>.dtb</code> files which got compiled. Find which <code>.dtb</code> file corresponds to your board.</p> <pre><code>$ find . -name \"vexpress*.dtb\"\n./arch/arm/boot/dts/vexpress-v2p-ca5s.dtb\n./arch/arm/boot/dts/vexpress-v2p-ca9.dtb\n./arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb\n./arch/arm/boot/dts/vexpress-v2p-ca15_a7.dtb\n</code></pre>"},{"location":"qemu/kernel/#bootloader","title":"Bootloader","text":"<p>As we are going to boot the Linux kernel from our U-Boot installation, we need to set the <code>bootargs</code> environment variable according to the Linux kernel command line.</p> <p>Let's run our U-Boot on the emulated board.</p> <p>A separate shell is suggested for QEMU instances from now on.</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ ./qemu\n</code></pre> <p>Enter the prompt (press a key before the timeout) and set the <code>bootargs</code> environment variable:</p> QEMU - U-Boot<pre><code>=&gt; setenv bootargs console=ttyAMA0\n=&gt; saveenv\n</code></pre> <p>We use TFTP to load the kernel image on the board:</p> <p>On your workstation, copy the <code>zImage</code> and DTB (<code>vexpress-v2p-ca9.dtb</code>) to the directory exposed by the TFTP server (<code>/srv/tftp/</code>).</p> <pre><code>$ cd \"$LAB_PATH/linux/\"\n$ cp \"arch/$ARCH/boot/zImage\" /srv/tftp/\n$ cp \"arch/$ARCH/boot/dts/vexpress-v2p-ca9.dtb\" /srv/tftp/\n</code></pre> <p>On the target (within the U-Boot prompt, accessed by pressing a key before the initial timeout), load <code>zImage</code> from TFTP into RAM, as well as the DTB, and let the kerbel boot rom RAM with its device tree. You should see Linux boot and finally panicking. This is expected: we haven\u2019t provided a working root filesystem for our device yet!</p> QEMU - U-Boot<pre><code>=&gt; tftp 0x61000000 zImage\n    ...\n=&gt; tftp 0x62000000 vexpress-v2p-ca9.dtb\n    ...\n=&gt; bootz 0x61000000 - 0x62000000\n    ...\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\n</code></pre> <p>You can now automate all of this every time the board is booted or reset. Quit QEMU (Ctrl+A then X), run it again, enter U-Boot prompt, and set the <code>bootcmd</code> environment variable, chaining the previous commands in sequence in a long line.</p> QEMU - U-Boot<pre><code>=&gt; setenv bootcmd \"tftp 0x61000000 zImage;  tftp 0x62000000 vexpress-v2p-ca9.dtb;  bootz 0x61000000 - 0x62000000\"\n=&gt; saveenv\n</code></pre> <p>Restart the board again to make sure that booting the kernel is now automated.</p> QEMU - U-Boot<pre><code>=&gt; reset\n    ...\n---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\n</code></pre> <p>You can now quit QEMU (Ctrl+A then X) and move to the next lab.</p>"},{"location":"qemu/kernel/#backup-and-restore","title":"Backup and restore","text":"<p>This isn't really required now, because we're going to recompile the kernel and adapt the U-Boot configuration again. Anyway, in case you need them, you can backup a snapshot of the images up to this point.</p> <pre><code>$ cd /srv/tftp/\n$ tar cfJv \"$LAB_PATH/kernel-tftp.tar.xz\" zImage vexpress-v2p-ca9.dtb\n$ cd \"$LAB_PATH/../bootloader/\"\n$ tar cfJv \"$LAB_PATH/kernel-sd.img.tar.xz\" sd.img\n</code></pre> <p>To restore the content:</p> <pre><code>$ sudo mkdir -p /srv/tftp/\n$ sudo chown tftp:tftp /srv/tftp\n$ cd /srv/tftp/\n$ tar xfv \"$LAB_PATH/kernel-tftp.tar.xz\"\n</code></pre> <p>If you need to restore the <code>sd.img</code> file, including all tne U-Boot environment changes up to this point:</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ tar xfv \"$LAB_PATH/kernel-sd.img.tar.xz\"\n</code></pre>"},{"location":"qemu/kernel/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/thirdparty/","title":"Third-party libraries and apps","text":""},{"location":"qemu/thirdparty/#objectives","title":"Objectives","text":"<ul> <li>Learn how to leverage existing libraries and applications: how to configure, compile and install them.</li> </ul> <p>To illustrate how to use existing libraries and applications, we will extend the small root filesystem built in the BusyBox lab to add the ALSA libraries and tools to run basic sound support tests. ALSA stands for Advanced Linux Sound Architecture, and it's the Linux audio subsystem.</p> <p>We'll see that manually re-using existing libraries is quite tedious, so that more automated procedures are necessary to make it easier. However, learning how to perform these operations manually will significantly help you when you face issues with more automated tools.</p>"},{"location":"qemu/thirdparty/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>meson</code></p> </li> <li> <p>alsa-lib</p> <ul> <li>Archived source code release <code>1.2.7.1</code></li> </ul> </li> <li> <p>alsa-utils</p> <ul> <li>Archived source code release <code>1.2.6</code></li> </ul> </li> <li> <p>ipcalc</p> <ul> <li>Archived source code release <code>1.0.1</code></li> </ul> </li> </ul>"},{"location":"qemu/thirdparty/#figuring-out-library-dependencies","title":"Figuring out library dependencies","text":"<p>We're going to integrate the <code>alsa-utils</code> and <code>ipcalc</code> executables. In our case, the dependency chain for <code>alsa-utils</code> is quite simple: it only depends on the <code>alsa-lib</code> library. Instead, <code>ipcalc</code> is standalone and thus doesn't have any dependencies.</p> <p>Of course, all these libraries rely on the C library, which is not mentioned here, because it is already part of the root filesystem built in the BusyBox lab. You might wonder how to figure out this dependency tree by yourself. Basically, there are several ways, that can be combined:</p> <ul> <li>Read the library documentation, which often mentions the dependencies.</li> <li>Read the help message of the configure script (by running <code>./configure --help</code>).</li> <li>By running the configure script, compiling and looking at the errors.</li> </ul> <p>To configure, compile and install all the components of our system, we're going to start from the bottom of the tree with <code>alsa-lib</code>, then continue with <code>alsa-utils</code>. Then, we will also build <code>ipcalc</code>.</p>"},{"location":"qemu/thirdparty/#preparation","title":"Preparation","text":"<p>For our cross-compilation work, we will need two separate spaces:</p> <ul> <li> <p>A staging space in which we will directly install all the packages: non-stripped versions of the libraries, headers, documentation and other files needed for the compilation. This staging space can be quite big, but will not be used on our target, only for compiling libraries or applications;</p> </li> <li> <p>A target space, in which we will only copy the required files from the staging space: binaries and libraries, after stripping, configuration files needed at runtime, etc. This target space will take a lot less space than the staging space, and it will contain only the files that are really needed to make the system work on the target.</p> </li> </ul> <p>To sum up, the staging space will contain everything that's needed for compilation, while the target space will contain only what's needed for execution.</p> <p>Create the <code>$HOME/embedded-linux-qemu-labs/thirdparty/</code> directory, and inside create two directories: <code>staging</code> and <code>target</code>.</p> <p>For the target, we need a basic system with BusyBox and initialization scripts. We're going to re-use the system built in the BusyBox lab, so copy this system in the <code>target</code> directory.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/thirdparty\"\n$ mkdir -p \"$LAB_PATH/target/\"\n$ mkdir -p \"$LAB_PATH/staging/\"\n$ cd $LAB_PATH\n$ cp -arv ../tinysystem/nfsroot/* target/\n    ...\n</code></pre>"},{"location":"qemu/thirdparty/#testing","title":"Testing","text":"<p>Make sure the <code>target/</code> directory is exported by your NFS server to your board by modifying <code>/etc/exports</code> and restarting your NFS server. You can of course change our previous <code>/srv/nfs/</code> symlink to point to this directory. Make your board boot from this new directory through NFS.</p> <pre><code>$ sudo rm -f /srv/nfs\n$ sudo ln -snv \"$LAB_PATH/target/\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-qemu-labs/thirdparty/target/'\n$ sudo chown -R tftp:tftp /srv/nfs\n$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre> <p>Revert U-Boot to use TFTP and NFS:</p> QEMU - U-Boot<pre><code>    ...\nHit any key to stop autoboot:  0\n=&gt; setenv bootcmd \"tftp 0x61000000 zImage;  tftp 0x62000000 vexpress-v2p-ca9.dtb;  bootz 0x61000000 - 0x62000000\"\n=&gt; setenv bootargs console=ttyAMA0 root=/dev/nfs ip=${ipaddr}::${serverip}:${netmask}:: nfsroot=${serverip}:${servernfs},nfsvers=3,tcp rw\n=&gt; saveenv\n=&gt; reset\n    ...\n</code></pre>"},{"location":"qemu/thirdparty/#alsa-lib","title":"<code>alsa-lib</code>","text":"<p><code>alsa-lib</code> is a library supposed to handle the interaction with the ALSA subsystem. It is available at https://alsa-project.org/.</p>"},{"location":"qemu/thirdparty/#source-code","title":"Source code","text":"<p>Download version <code>1.2.7.1</code>, and extract it in <code>$HOME/embeddedlinux-qemu-labs/thirdparty/</code>.</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.2.7.1\"\n$ wget \"https://www.alsa-project.org/files/pub/lib/alsa-lib-${label}.tar.bz2\"\n$ tar xfv \"alsa-lib-${label}.tar.bz2\"\n$ mv alsa-lib*/ alsa-lib\n$ cd alsa-lib/\n</code></pre> <p>Tip: if the website for any of the source packages that we need to download in the next sections is down, a great mirror that you can use is http://sources.buildroot.net/.</p>"},{"location":"qemu/thirdparty/#configuration","title":"Configuration","text":"<p>Back to <code>alsa-lib</code> sources, look at the <code>configure</code> script and see that it has been generated by <code>autoconf</code> (the header contains a sentence like Generated by GNU Autoconf 2.69). Most of the time, <code>autoconf</code> comes with <code>automake</code>, that generates Makefiles from <code>Makefile.am</code> files. So <code>alsa-lib</code> uses a rather common build system. Let's try to configure and build it:</p> <pre><code>$ export MAKEFLAGS=-j$(nproc)\n$ head -n3 configure\n#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.69 for alsa-lib 1.2.7.1.\n$ ./configure\n$ make\n</code></pre> <p>If you look at the generated binaries, you'll see that they are x86 ones because we compiled the sources with <code>gcc</code>, the default compiler. This is obviously not what we want, so let's clean up the generated objects and tell the configure script to use the ARM cross-compiler.</p> <pre><code>$ file aserver/aserver.o\naserver/aserver.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped\n$ make clean\n$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ CC=arm-linux-gcc ./configure\n    ...\nchecking whether we are cross compiling... configure: error: in `/home/me/embedded-linux-qemu-labs/thirdparty/alsa-lib':\nconfigure: error: cannot run C compiled programs.\nIf you meant to cross compile, use `--host'.\nSee `config.log' for more details\n</code></pre> <p>Of course, the <code>arm-linux-gcc</code> cross-compiler must be in your <code>PATH</code> prior to running the configure script. The <code>CC</code> environment variable is the classical name for specifying the compiler to use. Quickly, you should get an error, as highlighted above.</p> <p>If you look at the <code>config.log</code> file, you can see that the <code>configure</code> script compiles a binary with the cross-compiler and then tries to run it on the development workstation. This is a rather usual thing to do for a <code>configure</code> script, and that's why it tests so early that it's actually doable, and bails out if not.</p> config.log<pre><code>    ...\nconfigure:3719: arm-linux-gcc -o conftest    conftest.c  &gt;&amp;5\nconfigure:3723: $? = 0\nconfigure:3730: ./conftest\narm-binfmt-P: Could not open '/lib/ld-uClibc.so.0': No such file or directory\nconfigure:3734: $? = 255\nconfigure:3741: error: in `/home/me/embedded-linux-qemu-labs/thirdparty/alsa-lib':\nconfigure:3743: error: cannot run C compiled programs.\nIf you meant to cross compile, use `--host'.\nSee `config.log' for more details\n    ...\n</code></pre> <p>Obviously, it cannot work in our case, and the scripts exits. The job of the <code>configure</code> script is to test the configuration of the system. To do so, it tries to compile and run a few sample applications to test if this library is available, if this compiler option is supported, etc. But in our case, running the test examples is definitely not possible.</p> <p>We need to tell the <code>configure</code> script that we are cross-compiling, and this can be done using the <code>--build</code> and <code>--host</code> options, as described in the <code>help</code> of the <code>configure</code> script.</p> ./configure --help<pre><code>    ...\nSystem types:\n  --build=BUILD     configure for building on BUILD [guessed]\n  --host=HOST       cross-compile to build programs to run on HOST [BUILD]\n    ...\n</code></pre> <p>The <code>--build</code> option allows to specify on which system the package is built, while the <code>--host</code> option allows to specify on which system the package will run. By default, the value of the <code>--build</code> option is guessed, and the value of <code>--host</code> is the same as the value of the <code>--build</code> option. The value is guessed using the <code>./config.guess</code> script, which on your system should return <code>x86_64-pc-linux-gnu</code>. See the <code>autoconf</code> manual for more details on these options.</p> <p>So, let's override the value of the <code>--host</code> option:</p> <pre><code>$ ./configure --host=arm-linux\n</code></pre> <p>Note that <code>CC</code> is not required anymore. It is implied by <code>--host</code>.</p> <p>The <code>configure</code> script should end properly now, and create a <code>Makefile</code>. However, there is one subtle last issue to handle: because the C library used in our toolchain (uClibc-ng) does not support symbol versioning, we need to tell <code>alsa-lib</code> about this by passing <code>--without-versioned</code>. Without this option, <code>alsa-lib</code> will build fine, but it will not work properly at runtime.</p>"},{"location":"qemu/thirdparty/#build","title":"Build","text":"<p>So, you should configure <code>alsa-lib</code> and <code>run</code> the make command, which should run just fine.</p> <pre><code>$ make clean\n$ ./configure --host=arm-linux --without-versioned\n$ make\n</code></pre> <p>Look at the result of compiling in <code>src/.libs/</code>: a set of object files and a set of <code>libasound.so*</code> files.</p> <pre><code>$ ls -l src/.libs/\ntotal 4316\n-rw-rw-r-- 1 me me   36148 Apr 10 22:32 async.o\n-rw-rw-r-- 1 me me   15832 Apr 10 22:32 confeval.o\n-rw-rw-r-- 1 me me   70572 Apr 10 22:32 confmisc.o\n-rw-rw-r-- 1 me me  237316 Apr 10 22:32 conf.o\n-rw-rw-r-- 1 me me   19052 Apr 10 22:32 dlmisc.o\n-rw-rw-r-- 1 me me   11824 Apr 10 22:32 error.o\n-rw-rw-r-- 1 me me   18944 Apr 10 22:32 input.o\nlrwxrwxrwx 1 me me      15 Apr 10 22:32 libasound.la -&gt; ../libasound.la\n-rw-rw-r-- 1 me me     937 Apr 10 22:32 libasound.lai\nlrwxrwxrwx 1 me me      18 Apr 10 22:32 libasound.so -&gt; libasound.so.2.0.0\nlrwxrwxrwx 1 me me      18 Apr 10 22:32 libasound.so.2 -&gt; libasound.so.2.0.0\n-rwxrwxr-x 1 me me 3986260 Apr 10 22:32 libasound.so.2.0.0\n-rw-rw-r-- 1 me me    3532 Apr 10 22:32 names.o\n-rw-rw-r-- 1 me me   20552 Apr 10 22:32 output.o\n-rw-rw-r-- 1 me me    6472 Apr 10 22:32 shmarea.o\n-rw-rw-r-- 1 me me    7340 Apr 10 22:32 socket.o\n-rw-rw-r-- 1 me me    7536 Apr 10 22:32 userfile.o\n</code></pre> <p>The <code>libasound.so*</code> files are a dynamic version of the library. The shared library itself is <code>libasound.so.2.0.0</code>, which was generated by the following command line:</p> Compilation of libasound.so.2.0.0 by make<pre><code>$ arm-linux-gcc -shared conf.o confmisc.o input.o output.o async.o  \\\nerror.o dlmisc.o socket.o shmarea.o userfile.o names.o  \\\n-lm -ldl -lpthread -lrt -Wl,-soname -Wl,libasound.so.2  \\\n-o libasound.so.2.0.0\n</code></pre> <p>It creates the symbolic links <code>libasound.so</code> and <code>libasound.so.2</code>.</p> Symbolic linking of libasound.so.2.0.0 by make<pre><code>$ ln -s libasound.so.2.0.0 libasound.so.2\n$ ln -s libasound.so.2.0.0 libasound.so\n</code></pre> <p>These symlinks are needed for two different reasons:</p> <ul> <li> <p><code>libasound.so</code> is used at compile time when you want to compile an application that is dynamically linked against the library. To do so, you pass the <code>-l&lt;LIBNAME&gt;</code> option to the compiler, which will look for a file named <code>lib&lt;LIBNAME&gt;.so</code>. In our case, the compilation option is <code>-lasound</code> and the name of the library file is <code>libasound.so</code>. So, the <code>libasound.so</code> symlink is needed at compile time.</p> </li> <li> <p><code>libasound.so.2</code> is needed because it is the SONAME of the library. SONAME stands for Shared Object Name. It is the name of the library as it will be stored in applications linked against this library. It means that at runtime, the dynamic loader will look for exactly this name when looking for the shared library. So, this symbolic link is needed at runtime.</p> </li> </ul> <p>To know what's the SONAME of a library, you can use:</p> <pre><code>$ arm-linux-readelf -d src/.libs/libasound.so.2.0.0\n\nDynamic section at offset 0xdff20 contains 24 entries:\n  Tag        Type                         Name/Value\n 0x00000001 (NEEDED)                     Shared library: [libc.so.0]\n 0x00000001 (NEEDED)                     Shared library: [ld-uClibc.so.1]\n 0x0000000e (SONAME)                     Library soname: [libasound.so.2]\n 0x0000000c (INIT)                       0x23b1c\n 0x0000000d (FINI)                       0xbc6b4\n 0x00000019 (INIT_ARRAY)                 0xed2fc\n 0x0000001b (INIT_ARRAYSZ)               4 (bytes)\n 0x0000001a (FINI_ARRAY)                 0xed300\n 0x0000001c (FINI_ARRAYSZ)               8 (bytes)\n 0x00000004 (HASH)                       0x114\n 0x6ffffef5 (GNU_HASH)                   0x4318\n 0x00000005 (STRTAB)                     0x1021c\n 0x00000006 (SYMTAB)                     0x7a7c\n 0x0000000a (STRSZ)                      52374 (bytes)\n 0x0000000b (SYMENT)                     16 (bytes)\n 0x00000003 (PLTGOT)                     0xf0000\n 0x00000002 (PLTRELSZ)                   7776 (bytes)\n 0x00000014 (PLTREL)                     REL\n 0x00000017 (JMPREL)                     0x21cbc\n 0x00000011 (REL)                        0x1ceb4\n 0x00000012 (RELSZ)                      19976 (bytes)\n 0x00000013 (RELENT)                     8 (bytes)\n 0x6ffffffa (RELCOUNT)                   2084\n 0x00000000 (NULL)                       0x0\n</code></pre> <p>and look at the <code>(SONAME)</code> line. You'll also see that this library needs the C library, because of the <code>(NEEDED)</code> line on <code>libc.so.0</code>. The mechanism of SONAME allows to change the library without recompiling the applications linked with this library.</p> <p>Let's imagine that a security problem is found in the <code>alsa-lib</code> release that provides <code>libasound.so.2.0.0</code>, and fixed in the next <code>alsa-lib</code> release, which will now provide <code>libasound.so.2.0.1</code>. You can just recompile the library, install it on your target system, change the <code>libasound.so.2</code> link so that it points to <code>libasound.so.2.0.1</code> and restart your applications. It will work, because your applications don't look specifically for <code>libasound.so.2.0.0</code> but for the SONAME <code>libasound.so.2</code>. However, it also means that as a library developer, if you break the ABI of the library, you must change the SONAME: change from <code>libasound.so.2</code> to <code>libasound.so.3</code>.</p>"},{"location":"qemu/thirdparty/#installation","title":"Installation","text":"<p>Finally, the last step is to tell the <code>configure</code> script where the library is going to be installed. Most <code>configure</code> scripts consider that the installation prefix is <code>/usr/local/</code> (so that the library is installed in <code>/usr/local/lib/</code>, the headers in <code>/usr/local/include/</code>, etc.). Instead, in our system we simply want the libraries to be installed in the <code>/usr/</code> prefix, so let's tell the <code>configure</code> script about this:</p> <pre><code>$ make clean\n$ ./configure --host=arm-linux --without-versioned --prefix=/usr/\n$ make\n</code></pre> <p>For this library, this option may not change anything to the resulting binaries. But, for safety it is always recommended to make sure that the prefix matches where your library will be running on the target system.</p> <p>Do not confuse the prefix (where the application or library will be running on the target system) with the location where the application or library will be installed on your host while building the root filesystem.</p> <p>For example, <code>libasound</code> is installed in <code>$HOME/embedded-linux-qemu-labs/thirdparty/target/usr/lib/</code> because this is the directory where we are building the root filesystem. But, once our target system is running, it looks for <code>libasound</code> in <code>/usr/lib/</code>.</p> <p>The prefix corresponds to the path in the target system and never on the host. So, one should never pass a prefix like <code>$HOME/embedded-linux-qemu-labs/thirdparty/target/usr/</code>, otherwise at runtime the application or library may look for files inside this directory on the target system, which obviously doesn't exist! By default, most build systems install the application or library in the given prefix (<code>/usr/</code> or <code>/usr/local/</code>), but with most build systems (including <code>autotools</code>), the installation prefix can be overridden,  different from the configuration prefix.</p> <p>We now only have the installation process left to do. First, let's make the installation in the staging space:</p> <pre><code>$ make DESTDIR=\"$LAB_PATH/staging\" install\n$ cd \"$LAB_PATH/staging/\"\n</code></pre> <p>Now look at what has been installed by <code>alsa-lib</code>:</p> <ul> <li> <p>Some configuration files in <code>/usr/share/alsa/</code>:</p> <pre><code>$ ls -p usr/share/alsa/\nalsa.conf  cards/  ctl/  pcm/\n</code></pre> </li> <li> <p>The headers in <code>/usr/include/</code>:</p> <pre><code>$ ls -p usr/include/\nalsa/  asoundlib.h  sys/\n</code></pre> </li> <li> <p>The shared library and its <code>libtool</code> (<code>.la</code>) file in <code>/usr/lib/</code>:</p> <pre><code>$ ls -p usr/lib/\nlibasound.la  libasound.so.2      libatopology.la  libatopology.so.2      pkgconfig/\nlibasound.so  libasound.so.2.0.0  libatopology.so  libatopology.so.2.0.0\n</code></pre> </li> <li> <p>A pkgconfig file in <code>/usr/lib/pkgconfig/</code> \u2014 we'll come back to these later:</p> <pre><code>$ ls -p usr/lib/pkgconfig/\nalsa.pc  alsa-topology.pc\n</code></pre> </li> </ul> <p>Finally, let's install the library in the <code>target</code> space:</p> <ol> <li> <p>Create the <code>target/usr/lib</code> directory, it will contain the stripped version of the library.</p> </li> <li> <p>Copy the dynamic version of the library. Only <code>libasound.so.2</code> and <code>libasound.so.2.0.0</code> are needed, since <code>libasound.so.2</code> is the SONAME of the library and <code>libasound.so.2.0.0</code> is the real binary.</p> </li> <li> <p>Measure the size of the <code>target/usr/lib/libasound.so.2.0.0</code> library before stripping.</p> </li> <li> <p>Strip the library.</p> </li> <li> <p>Measure the size of the <code>target/usr/lib/libasound.so.2.0.0</code> library again after stripping. How many unnecessary bytes were saved?</p> </li> </ol> <pre><code>$ cd $LAB_PATH\n$ cp -av staging/usr/lib/libasound.so.2* target/usr/lib/\n'staging/usr/lib/libasound.so.2' -&gt; 'target/usr/lib/libasound.so.2'\n'staging/usr/lib/libasound.so.2.0.0' -&gt; 'target/usr/lib/libasound.so.2.0.0'\n$ du -h target/usr/lib/libasound.so.2.0.0\n3.8M    target/usr/lib/libasound.so.2.0.0\n$ arm-linux-strip target/usr/lib/libasound.so.2.0.0\n$ du -h target/usr/lib/libasound.so.2.0.0\n904K    target/usr/lib/libasound.so.2.0.0\n</code></pre> <p>Then, we need to install the <code>alsa-lib</code> configuration files:</p> <pre><code>$ mkdir -p target/usr/share\n$ cp -arv staging/usr/share/alsa/ target/usr/share/\n    ...\n</code></pre> <p>Now, we need to adjust one small detail in one of the configuration files. Indeed, <code>/usr/share/alsa/alsa.conf</code> assumes a UNIX group called <code>audio</code> exists, which is not the case on our very small system; let's set to root instead (group id <code>0</code>). Edit this file and replace <code>defaults.pcm.ipc_gid audio</code> with <code>defaults.pcm.ipc_gid 0</code> instead.</p> <pre><code>$ sed -i \"s/defaults.pcm.ipc_gid audio/defaults.pcm.ipc_gid 0/g\"  \\\ntarget/usr/share/alsa/alsa.conf\n</code></pre> <p>And we're done with <code>alsa-lib</code>!</p>"},{"location":"qemu/thirdparty/#alsa-utils","title":"<code>alsa-utils</code>","text":""},{"location":"qemu/thirdparty/#source-code_1","title":"Source code","text":"<p>Download <code>alsa-utils</code> from the ALSA offical webpage. We tested the lab with version <code>1.2.6</code>. Once uncompressed, we quickly discover that the <code>alsa-utils</code> build system is based on the autotools, so we will work once again with a regular <code>configure</code> script.</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.2.6\"\n$ wget \"https://www.alsa-project.org/files/pub/utils/alsa-utils-${label}.tar.bz2\"\n$ tar xfv \"alsa-utils-${label}.tar.bz2\"\n$ mv alsa-utils*/ alsa-utils\n$ cd alsa-utils/\n</code></pre>"},{"location":"qemu/thirdparty/#configuration_1","title":"Configuration","text":"<p>As we've seen previously, we have to provide the prefix, host options, and the <code>CC</code> variable. We should quiclky get an error in the execution of the configure script.</p> <pre><code>$ ./configure --host=arm-linux --prefix=/usr\n    ...\nchecking for libasound headers version &gt;= 1.2.5 (1.2.5)... not present.\nconfigure: error: Sufficiently new version of libasound not found.\n</code></pre> <p>Again, we can check in <code>config.log</code> what the configure script is trying to do.</p> File: config.log<pre><code>    ...\nconfigure:8080: checking for libasound headers version &gt;= 1.2.5 (1.2.5)\nconfigure:8127: arm-linux-gcc -c -g -O2  conftest.c &gt;&amp;5\nconftest.c:12:10: fatal error: alsa/asoundlib.h: No such file or directory\n   12 | #include &lt;alsa/asoundlib.h&gt;\n      |          ^~~~~~~~~~~~~~~~~~\ncompilation terminated.\n    ...\n</code></pre> <p>Of course, since <code>alsa-utils</code> uses <code>alsa-lib</code>, it includes its header file! So, we need to tell the C compiler where the headers can be found. They aren't in the default directory <code>/usr/include/</code>, but in the equivalent directory of our staging space. The <code>help</code> text of the <code>configure</code> script says:</p> File: configure<pre><code>    ...\nSome influential environment variables:\n    ...\n  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I&lt;include dir&gt; if\n              you have headers in a nonstandard directory &lt;include dir&gt;\n    ...\n</code></pre> <p>Let's use it! Now, it should stop a bit later, this time with another error.</p> <pre><code>$ CPPFLAGS=-I\"$LAB_PATH/staging/usr/include\"  \\\n./configure --host=arm-linux --prefix=/usr\n    ...\nchecking for libasound headers version &gt;= 1.2.5 (1.2.5)... found.\n    ...\nchecking for snd_ctl_open in -lasound... no\nconfigure: error: No linkable libasound was found.\n</code></pre> <p>The configure script tries to compile an application against <code>libasound</code> (see the <code>-lasound</code> option): <code>alsa-utils</code> uses <code>alsa-lib</code>, so the <code>configure</code> script wants to make sure this library is already installed. Unfortunately, the <code>ld</code> linker doesn't find it. So, let's tell the linker where to look for libraries using the <code>-L</code> option followed by the directory where our libraries are (in <code>staging/usr/lib</code>). This <code>-L</code> option can be passed to the linker by using the <code>LDFLAGS</code> at <code>configure</code> time, as told by the help text of the configure script:</p> File: configure<pre><code>    ...\nSome influential environment variables:\n    ...\n  LDFLAGS     linker flags, e.g. -L&lt;lib dir&gt; if you have libraries in a\n              nonstandard directory &lt;lib dir&gt;\n    ...\n</code></pre> <p>Let's use this LDFLAGS variable:</p> <pre><code>$ LDFLAGS=-L\"$LAB_PATH/staging/usr/lib\"  \\\nCPPFLAGS=-I\"$LAB_PATH/staging/usr/include\"  \\\n./configure --host=arm-linux --prefix=/usr\n    ...\nchecking panel.h usability... no\nchecking panel.h presence... no\nchecking for panel.h... no\nconfigure: error: required curses helper header not found\n</code></pre> <p>Once again, it should fail a bit further down the tests, this time complaining about a missing curses helper header. <code>curses</code> (or <code>ncurses</code>, new curses) is a graphical framework to design text UIs within the terminal.</p> <p>This is only used by <code>alsamixer</code>, one of the tools provided by <code>alsa-utils</code>, that we are not going to use. Hence, we can just disable the build of <code>alsamixer</code>. Of course, if we wanted it, we would have had to build <code>ncurses</code> first, just like we built <code>alsa-lib</code>.</p>"},{"location":"qemu/thirdparty/#build_1","title":"Build","text":"<p>Then, run the compilation with <code>make</code>. Hopefully, it works!</p> <pre><code>$ LDFLAGS=-L\"$LAB_PATH/staging/usr/lib\"  \\\nCPPFLAGS=-I\"$LAB_PATH/staging/usr/include\"  \\\n./configure --host=arm-linux --prefix=/usr --disable-alsamixer\n$ make\n</code></pre>"},{"location":"qemu/thirdparty/#installation_1","title":"Installation","text":"<p>Let's now begin the installation process. Before really installing in the <code>staging</code> directory, let's install in a dummy directory, to see what's going to be installed \u2014 this dummy directory will not be used afterwards, it is only to verify what will be installed before polluting the staging space.</p> <pre><code>$ make DESTDIR=/tmp/alsa-utils install\n</code></pre> <p>The <code>DESTDIR</code> variable can be used with all Makefiles based on <code>automake</code>. It allows to override the installation directory: instead of being installed in the configuration <code>prefix</code> directory, the files will be installed in <code>$DESTDIR/configuration-prefix</code>. Now, let's see what has been installed in <code>/tmp/alsa-utils/</code>;</p> <pre><code>$ tree /tmp/alsa-utils/\n/tmp/alsa-utils/\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 systemd\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 system\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 alsa-restore.service\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 alsa-state.service\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 sound.target.wants\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 alsa-restore.service -&gt; ../alsa-restore.service\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 alsa-state.service -&gt; ../alsa-state.service\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 udev\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 rules.d\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 90-alsa-restore.rules\n\u251c\u2500\u2500 usr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aconnect\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsabat\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaloop\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsatplg\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaucm\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amidi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amixer\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplay\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplaymidi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecord -&gt; aplay\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecordmidi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqdump\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqnet\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 iecset\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 speaker-test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sbin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsabat-test.sh\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaconf\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsactl\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 alsa-info.sh\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 share\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 alsa\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 init\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 00main\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ca0106\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 default\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 hda\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 help\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 info\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 speaker-test\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 sample_map.csv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 man\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fr\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 man8\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 alsaconf.8\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 man1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aconnect.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsabat.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsactl.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsa-info.sh.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alsaloop.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amidi.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 amixer.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplay.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aplaymidi.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecord.1 -&gt; aplay.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 arecordmidi.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqdump.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aseqnet.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer-list.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 axfer-transfer.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 iecset.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 speaker-test.1\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 man7\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 man8\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 alsaconf.8\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 sounds\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 alsa\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Front_Center.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Front_Left.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Front_Right.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Noise.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Rear_Center.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Rear_Left.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Rear_Right.wav\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 Side_Left.wav\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 Side_Right.wav\n\u2514\u2500\u2500 var\n    \u2514\u2500\u2500 lib\n        \u2514\u2500\u2500 alsa\n24 directories, 62 files\n</code></pre> <p>So, we have</p> <ul> <li>The <code>systemd</code> service definitions in <code>lib/systemd/</code>.</li> <li>The <code>udev</code> rules in <code>lib/udev/</code>.</li> <li>The <code>alsa-utils</code> binaries in <code>/usr/bin/</code> and <code>/usr/sbin/</code>.</li> <li>Some sound samples in <code>/usr/share/sounds/</code>.</li> <li>The various translations in <code>/usr/share/locale/</code>.</li> <li>The manual pages in <code>/usr/share/man/</code>, explaining how to use the various tools.</li> <li>Some configuration samples in <code>/usr/share/alsa/</code>.</li> </ul> <p>Now, let's make the installation in the <code>staging</code> space: Then, let's manually install only the necessary files in the <code>target</code> space. We are only interested in <code>speaker-test</code>:</p> <pre><code>$ make DESTDIR=\"$LAB_PATH/staging\" install\n$ cd $LAB_PATH\n$ cp -a staging/usr/bin/speaker-test target/usr/bin/\n$ arm-linux-strip target/usr/bin/speaker-test\n</code></pre> <p>You may need to add the missing libraries from the toolchain install directory.</p> <p>We're finally done with <code>alsa-utils</code>!</p>"},{"location":"qemu/thirdparty/#quick-test","title":"Quick test","text":"<p>Now test that all is working fine by running the <code>speaker-test</code> utility on your board.</p> <p>Now you can launch your QEMU machine as usual, with rootfs on NFS, and test <code>speaker-test</code> in a shell:</p> QEMU - BusyBox<pre><code># speaker-test -t sine -l 1\nspeaker-test 1.2.6\nPlayback device is default\nStream parameters are 48000Hz, S16_LE, 1 channels\nSine wave rate is 440.0000Hz\nRate set to 48000Hz (requested 48000Hz)\nBuffer size range from 256 to 16384\nPeriod size range from 64 to 1024\nUsing max buffer size 16384\nPeriods = 4\nwas set period_size = 1024\nwas set buffer_size = 16384\n 0 - Front Left\nTime per period = 2.577584\n</code></pre> <p>There you are: you built and ran your first program depending on a library different from the C library!</p>"},{"location":"qemu/thirdparty/#ipcalc","title":"<code>ipcalc</code>","text":"<p>After practicing with autotools based packages, let's build <code>ipcalc</code>, which is using Meson as build system. We won't really need this utility in our system, but at least it has no dependencies and therefore offers an easy way to build our first Meson based package.</p> <p>So, first install the <code>meson</code> package:</p> <pre><code>$ sudo apt install meson\n</code></pre>"},{"location":"qemu/thirdparty/#source-code_2","title":"Source code","text":"<p>In the main lab directory, then let's check out the sources through git:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.0.1\"\n$ git clone https://gitlab.com/ipcalc/ipcalc.git\n$ cd ipcalc/\n$ git checkout -b embedded-linux-qemu $label\n</code></pre> <p>Alternatively, you can retrieve an archived release:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1.0.1\"\n$ wget \"https://gitlab.com/ipcalc/ipcalc/-/archive/${label}/ipcalc-${label}.tar.bz2\"\n$ tar xfv \"ipcalc-${label}.tar.bz2\"\n$ mv ipcalc*/ ipcalc\n$ cd ipcalc/\n</code></pre>"},{"location":"qemu/thirdparty/#configuration_2","title":"Configuration","text":"<p>To cross-compile with Meson, we need to create a cross file. Let's create the <code>$LAB_PATH/cross-file.txt</code> file with the following content:</p> File: $LAB_PATH/cross-file.txt<pre><code>[binaries]\nc = 'arm-linux-gcc'\n[host_machine]\nsystem = 'linux'\ncpu_family = 'arm'\ncpu = 'cortex-a9'\nendian = 'little'\n</code></pre> <p>Command-line shortcut:</p> <pre><code>$ cd \"$LAB_PATH/ipcalc/\"\n$ cat &gt; ../cross-file.txt &lt;&lt;'EOF'\n[binaries]\nc = 'arm-linux-gcc'\n[host_machine]\nsystem = 'linux'\ncpu_family = 'arm'\ncpu = 'cortex-a9'\nendian = 'little'\nEOF\n</code></pre> <p>We also need to create a special directory for building:</p> <pre><code>$ mkdir cross-build\n$ cd cross-build/\n</code></pre>"},{"location":"qemu/thirdparty/#build_2","title":"Build","text":"<p>We can now have Meson create the Ninja build files for us:</p> <pre><code>$ meson --cross-file ../../cross-file.txt --prefix /usr ..\nThe Meson build system\n    ...\nC compiler for the host machine: arm-linux-gcc (gcc 11.3.0 \"arm-linux-gcc (crosstool-NG 1.25.0.95_7622b49) 11.3.0\")\nC linker for the host machine: arm-linux-gcc ld.bfd 1.25.0.95\nC compiler for the build machine: cc (gcc 11.3.0 \"cc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0\")\nC linker for the build machine: cc ld.bfd 2.38\nBuild machine cpu family: x86_64\nBuild machine cpu: x86_64\nHost machine cpu family: arm\nHost machine cpu: cortex-a9\nTarget machine cpu family: arm\nTarget machine cpu: cortex-a9\n    ...\nBuild targets in project: 1\nipcalc 1.0.1\n  User defined options\n    Cross files: ../../cross-file.txt\n    prefix     : /usr\nFound ninja-1.10.1 at /usr/bin/ninja\nWARNING: Cross file does not specify strip binary, result will not be stripped.\n</code></pre> <p>We're finally ready to build <code>ipcalc</code>:</p> <pre><code>$ ninja\n[7/7] Linking target ipcalc\n</code></pre>"},{"location":"qemu/thirdparty/#installation_2","title":"Installation","text":"<p>And now install <code>ipcalc</code> into the <code>staging</code> space. Check that the <code>staging/usr/bin/ipcalc</code> file is indeed an ARM executable!</p> <pre><code>$ DESTDIR=\"$LAB_PATH/staging\" ninja install\n[0/1] Installing files.\nInstalling ipcalc to /home/me/embedded-linux-qemu-labs/thirdparty/staging/usr/bin\n$ file \"$LAB_PATH/staging/usr/bin/ipcalc\"\n/home/me/embedded-linux-qemu-labs/thirdparty/staging/usr/bin/ipcalc: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, with debug_info, not stripped\n</code></pre> <p>The last thing to do is to copy it to the target space and strip it.</p> <pre><code>$ cd $LAB_PATH\n$ cp staging/usr/bin/ipcalc target/usr/bin/\n$ arm-linux-strip target/usr/bin/ipcalc\n</code></pre> <p>Note that we could have asked <code>ninja install</code> to strip the executable for us when installing it into the <code>staging</code> directory. To do, this, we would have added a <code>strip</code> entry in the cross file, and passed <code>--strip</code> to Meson. However, it's better to keep files unstripped in the <code>staging</code> space, in case we need to debug them!</p>"},{"location":"qemu/thirdparty/#quick-test_1","title":"Quick test","text":"<p>You can now test that <code>ipcalc</code> works on the target:</p> QEMU - BusyBox<pre><code># ipcalc 10.0.2.15\nAddress:        10.0.2.15\nAddress space:  Private Use\n</code></pre> <p>You can now <code>halt</code> and quit QEMU.</p>"},{"location":"qemu/thirdparty/#final-touch","title":"Final touch","text":"<p>To finish this lab completely, and to be consistent with what we've done before, let's strip the C library and its loader too. Let's compare the size of the binaries to confirm.</p> <pre><code>$ ls -l target/lib/\ntotal 1248\n-r-xr-xr-x 1 me me  69584 Apr  8 15:14 ld-uClibc.so.0\n-r-xr-xr-x 1 me me  69584 Apr  8 15:14 ld-uClibc.so.1\n-r-xr-xr-x 1 me me 635188 Apr  8 15:14 libc.so.0\n-r-xr-xr-x 1 me me 635188 Apr  8 15:14 libc.so.1\n$ chmod +w target/lib/*.so.*\n$ arm-linux-strip target/lib/*.so.*\n$ ls -l target/lib/\ntotal 1040\n-rwxrwxr-x 1 me me  66460 Apr 12 20:35 ld-uClibc.so.0\n-rwxrwxr-x 1 me me  66460 Apr 12 20:35 ld-uClibc.so.1\n-rwxrwxr-x 1 me me 460764 Apr 12 20:35 libc.so.0\n-rwxrwxr-x 1 me me 460764 Apr 12 20:35 libc.so.1\n</code></pre>"},{"location":"qemu/thirdparty/#backup-and-restore","title":"Backup and restore","text":"<pre><code>$ tar cfJv thirdparty-staging.tar.xz staging/\n$ tar cfJv thirdparty-target.tar.xz target/\n$ cd target/\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; ../thirdparty-target.cpio.xz\n</code></pre>"},{"location":"qemu/thirdparty/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/tinysystem/","title":"Tiny embedded system with BusyBox","text":""},{"location":"qemu/tinysystem/#objectives","title":"Objectives","text":"<ul> <li> <p>Make a tiny yet full-featured embedded system.</p> </li> <li> <p>Be able to configure and build a Linux kernel that boots on a directory on your workstation, shared through the network by NFS.</p> </li> <li> <p>Be able to create and configure a minimalistic root filesystem from scratch (ex nihilo, out of nothing, entirely hand made...) for your target board.</p> </li> <li> <p>Understand how small and simple an embedded Linux system can be.</p> </li> <li> <p>Be able to install BusyBox on this filesystem.</p> </li> <li> <p>Be able to create a simple startup script based on <code>/sbin/init</code>.</p> </li> <li> <p>Be able to set up a simple web interface for the target.</p> </li> </ul>"},{"location":"qemu/tinysystem/#required-tools","title":"Required tools","text":"<ul> <li> <p>Our cross-compile toolchain</p> </li> <li> <p>Ubuntu packages:</p> <p><code>nfs-kernel-server</code></p> <p>plus those from the previous labs.</p> </li> <li> <p>BusyBox, either as:</p> <ul> <li> <p>git repository tag <code>1_35_0</code></p> </li> <li> <p>Source code archive for release <code>1_35_0</code></p> </li> </ul> </li> </ul>"},{"location":"qemu/tinysystem/#overview","title":"Overview","text":"<p>While developing a root filesystem for a device, a developer needs to make frequent changes to the filesystem contents, like modifying scripts or adding newly compiled programs.</p> <p>It isn\u2019t practical at all to reflash the root filesystem on the target every time a change is made. Fortunately, it is possible to set up networking between the development workstation and the target. Then, workstation files can be accessed by the target through the network, using NFS.</p> <p>Unless you test a boot sequence, you no longer need to reboot the target to test the impact of script or application updates.</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/tinysystem\"\n</code></pre>"},{"location":"qemu/tinysystem/#kernel-configuration","title":"Kernel configuration","text":"<p>We'll re-use the kernel sources from the kernel lab.</p> <p>In the kernel configuration (see: <code>menuconfig</code>) verify that you have all the options needed for booting the system using a root filesystem mounted over NFS. Also enable the automatic mount of <code>devtmpfs</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux\"\n$ cp ../kernel.config .config\n$ make menuconfig\n</code></pre> <p>In <code>File systems</code>:</p> <ul> <li> <p>Enable <code>Network File Systems</code> (<code>NETWORK_FILESYSTEMS</code>), which should enable also the client for v2 and v3.   Inside this menu entry:</p> <ul> <li>Enable <code>Root file system on NFS</code> (<code>ROOT_NFS</code>).</li> </ul> </li> </ul> <p>In <code>Device Drivers</code> \u2192 <code>Generic Driver Options</code>:</p> <ul> <li>Enable <code>Maintain a devtmpfs filesystem to mount at /dev</code> (<code>CONFIG_DEVTMPFS_MOUNT</code>).</li> </ul> <p>Everything should already be as expected. If necessary, backup the new configuration and rebuild the kernel:</p> <pre><code>$ cp .config \"$LAB_PATH/kernel-busybox.config\"\n$ make\n</code></pre>"},{"location":"qemu/tinysystem/#nfs-server","title":"NFS server","text":"<p>A NFS server is provided by the <code>nfs-kernel-server</code> package:</p> <pre><code>$ sudo apt install nfs-kernel-server\n</code></pre> <p>Create a <code>nfsroot</code> directory in the current lab directory. We're going to use this folder as our NFS root folder. If we were to add it directly, we would need to specify the whole path when requesting files from it, which might become verbose, and exposes our private paths to the public. Instead, we can create a symbolic link at <code>/srv/nfs/</code>, and we can assign it the same <code>tftp</code> group of the previous labs:</p> <pre><code>$ mkdir -p \"$LAB_PATH/nfsroot\"\n$ sudo ln -snv \"$LAB_PATH/nfsroot\" /srv/nfs\n'/srv/nfs' -&gt; '/home/me/embedded-linux-qemu-labs/tinysystem/nfsroot'\n$ sudo chown -R tftp:tftp /srv/nfs\n</code></pre> <p>Once installed, edit the <code>/etc/exports</code> file (as root) to export our <code>nfsroot</code> to the whole <code>10.0.2.x</code> subnet, with some specific options:</p> File: /etc/exports - line to append<pre><code>/srv/nfs 10.0.2.0/255.255.255.0(rw,no_root_squash,no_subtree_check)\n</code></pre> <p>A quick way is by appending that line to the file via a shell command. In our example we use <code>tee</code> (we cannot <code>sudo echo \"text\" &gt;&gt; file</code>!):</p> <pre><code>$ NET_IP=\"10.0.2.0\"\n$ NET_MASK=\"255.255.255.0\"\n$ line=\"$NFS_ROOT $NET_IP/$NET_MASK(rw,no_root_squash,no_subtree_check)\"\n$ echo $line | sudo tee -a /etc/exports\n/srv/nfs 10.0.2.0/255.255.255.0(rw,no_root_squash,no_subtree_check)\n</code></pre> <p>Make sure that the path and the options are on the same line. Also make sure that there is no space between the IP address and the NFS options, otherwise default options will be used for this IP address, causing your root filesystem to be read-only.</p> <p>Then, restart the NFS server with the new configuration:</p> <pre><code>$ sudo exportfs -ar\n$ sudo systemctl restart nfs-kernel-server\n</code></pre>"},{"location":"qemu/tinysystem/#booting-the-system","title":"Booting the system","text":"<p>First, boot the board to the U-Boot prompt (press a key before the timeout).</p> <pre><code>$ cd \"$LAB_PATH/../bootloader\"\n$ ./qemu\n</code></pre> <p>Before booting the kernel, we need to tell it that the root filesystem should be mounted over NFS, by setting some kernel parameters. So, add the required settings to the <code>bootargs</code> environment variable (on a single long line!), and save it permanently:</p> QEMU - U-Boot<pre><code>=&gt; setenv netmask 255.255.255.0\n=&gt; setenv servernfs /srv/nfs\n=&gt; setenv bootargs console=ttyAMA0 root=/dev/nfs ip=${ipaddr}::${serverip}:${netmask}:: nfsroot=${serverip}:${servernfs},nfsvers=3,tcp rw\n=&gt; printenv bootargs\nbootargs=console=ttyAMA0 root=/dev/nfs ip=10.0.2.69::10.0.2.15:255.255.255.0:: nfsroot=10.0.2.15:/srv/nfs,nfsvers=3,tcp rw\n=&gt; saveenv\n</code></pre> <ul> <li> <p><code>console</code>: the debug console.</p> </li> <li> <p><code>root</code>: mounting to the standard virtual device for NFS.</p> </li> <li> <p><code>ip</code>: a detailed string with all the network parameters, for the maximum portability.</p> </li> <li> <p><code>nfsroot</code>: the path to the NFS folder on the server, as seen form the net, with the specified protocol.</p> </li> <li> <p><code>rw</code>: read and write permissions.</p> </li> </ul> <p>Now, reboot your system. The kernel should be able to mount the root filesystem over NFS (it might take some time to get there).</p> QEMU - U-Boot &amp; Kernel<pre><code>=&gt; reset\n    ...\nVFS: Mounted root (nfs filesystem) on device 0:14.\n    ...\n</code></pre> <p>If the kernel fails to mount the NFS filesystem, look carefully at the error messages in the console. If this doesn\u2019t give any clue, you can also have a look at the NFS server logs in <code>/var/log/syslog</code>.</p> <p>However, at this stage, the kernel should stop because of the following issue:</p> QEMU - Kernel<pre><code>    ...\nVFS: Mounted root (nfs filesystem) on device 0:14.\ndevtmpfs: error mounting -2\n    ...\n---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---\n</code></pre> <p>This happens because the kernel is trying to mount the devtmpfs filesystem in <code>/dev/</code> in the root filesystem. This virtual filesystem contains device files for all the devices known to the kernel, and with <code>CONFIG_DEVTMPFS_MOUNT</code>, our kernel tries to automatically mount <code>devtmpfs</code> on <code>/dev</code>.</p> <p>To address this, just create a <code>dev</code> directory under <code>nfsroot</code>:</p> <pre><code>$ mkdir -p \"$LAB_PATH/nfsroot/dev/\"\n</code></pre> <p>Now restart QEMU. The kernel should complain for the last time, saying that it can\u2019t find an <code>init</code> application:</p> QEMU - Kernel<pre><code>    ...\nVFS: Mounted root (nfs filesystem) on device 0:14.\ndevtmpfs: mounted\n    ...\n---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---\n</code></pre> <p>Obviously, our root filesystem being mostly empty, there isn\u2019t such an application yet. In the next paragraph, you will add BusyBox to your root filesystem, and finally make it usable.</p> <p>You might want to create a spare backup copy of your virtual SD image now:</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ tar cfJv \"$LAB_PATH/nfs-boot-sd.img.tar.xz\" sd.img\n</code></pre>"},{"location":"qemu/tinysystem/#root-filesystem-with-busybox","title":"Root filesystem with BusyBox","text":"<p>Download the sources of BusyBox release <code>1.35.0</code>:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1_35_0\"\n$ git clone https://git.busybox.net/busybox\n$ cd busybox/\n$ git checkout -b embedded-linux-qemu $label\n</code></pre> <p>Alternatively, you can get a source code archive:</p> <pre><code>$ cd $LAB_PATH\n$ label=\"1_35_0\"\n$ wget \"https://git.busybox.net/busybox/snapshot/busybox-${label}.tar.bz2\"\n$ tar xfv \"busybox-${label}.tar.bz2\"\n$ mv busybox*/ busybox\n$ cd busybox/\n</code></pre> <p>Now, configure BusyBox with the configuration file provided in the <code>data/</code> directory. Then, you can run <code>make menuconfig</code> to further customize the configuration. At least, keep the setting that builds a static BusyBox. Compiling it statically in the first place makes it easy to set up the system, because there are no dependencies. Later on, we will set up shared libraries and recompile BusyBox.</p> <pre><code>$ cp \"$LAB_PATH/data/busybox-1.35.config\" .config\n$ make menuconfig\n</code></pre> <p>Build BusyBox using the toolchain that you used to build the kernel.</p> <pre><code>$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ export PATH=\"$TC_BASE/bin:$PATH\"\n$ export CROSS_COMPILE=arm-linux-\n$ export MAKEFLAGS=-j$(nproc)\n$ make\n</code></pre> <p>Going back to the BusyBox configuration interface, check the installation directory. Set it to the path to your <code>nfsroot</code> directory if necessary.</p> <pre><code>$ make menuconfig\n</code></pre> <p><code>Settings</code> \u2192 <code>Install Options</code> \u2192 <code>Destination path for 'make install'</code> (<code>PREFIX</code>) = <code>../nfsroot</code></p> <p>Now run <code>make install</code> to install BusyBox in this directory.</p> <pre><code>$ cp .config ../busybox-static.config\n$ make install\n</code></pre> <p>Try to boot your new system on the board. You should now reach a command line prompt, allowing you to execute the commands of your choice.</p> <pre><code>$ cd \"$LAB_PATH/../bootloader/\"\n$ ./qemu\n</code></pre> QEMU - BusyBox<pre><code>    ...\ncan't run '/etc/init.d/rcS': No such file or directory\n\nPlease press Enter to activate this console.\n</code></pre> <p>You can press Enter to enter a root login shell. Ignore any warning messages for now.</p>"},{"location":"qemu/tinysystem/#virtual-filesystems","title":"Virtual filesystems","text":"<p>Within the target shell, run the <code>ps</code> command. You can see that it complains that the <code>/proc</code> directory does not exist. The <code>ps</code> command and other process-related commands use the <code>proc</code> virtual filesystem to get their information from the kernel.</p> QEMU - BusyBox<pre><code># ps\n  PID USER       VSZ STAT COMMAND\nps: can't open '/proc': No such file or directory\n</code></pre> <p>From the command line of the target, create the <code>proc</code>, <code>sys</code> and <code>etc</code> directories in your root filesystem:</p> QEMU - BusyBox<pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ mkdir proc sys etc\n</code></pre> <p>Now mount the <code>proc</code> virtual filesystem. Now that <code>/proc</code> is available, test again the <code>ps</code> command.</p> QEMU - BusyBox<pre><code># mount -t proc proc /proc\n# ps\n  PID USER       VSZ STAT COMMAND\n    1 0          512 S    /sbin/init\n    2 0            0 SW   [kthreadd]\n    3 0            0 IW&lt;  [rcu_gp]\n    4 0            0 IW&lt;  [rcu_par_gp]\n    5 0            0 IW&lt;  [slub_flushwq]\n    ...\n</code></pre> <p>Note that you can also now halt your target with the <code>halt</code> command, thanks to <code>proc</code> being mounted. The <code>halt</code> command can find the list of mounted filesystems in <code>/proc/mounts</code>, and unmount them in a clean way before shutting down.</p> QEMU - BusyBox<pre><code># halt\nstarting pid 78, tty '': 'umount -a -r'\numount: devtmpfs busy - remounted read-only\nstarting pid 79, tty '': 'swapoff -a'\nswapoff: can't open '/etc/fstab': No such file or directory\nThe system is going down NOW!\nSent SIGTERM to all processes\nSent SIGKILL to all processes\nRequesting system halt\nFlash device refused suspend due to active operation (state 20)\nFlash device refused suspend due to active operation (state 20)\nreboot: System halted\n</code></pre> <p>You can now quit QEMU as usual (Ctrl+A then X), this time more safely.</p>"},{"location":"qemu/tinysystem/#system-configuration-and-startup","title":"System configuration and startup","text":"<p>The first user space program that gets executed by the kernel is <code>/sbin/init</code>, whose configuration file is <code>/etc/inittab</code>.</p> <p>In the BusyBox sources, read details about <code>/etc/inittab</code> in the <code>examples/inittab</code> file (press Q to quit from <code>less</code>). Let's create it from the example template; we'll tweak it soon.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ less ../busybox/examples/inittab\n$ cp ../busybox/examples/inittab etc/inittab\n$ nano etc/inittab\n</code></pre> <p>Comment out any getty respawn from <code>etc/inittab</code>, otherwise those shells would keep respawning in our emulated board. Save (Ctrl+O) and exit (Ctrl+X).</p> File: $LAB_PATH/nfsroot/etc/inittab - respawning getty commented out<pre><code>    ...\n# /sbin/getty invocations for selected ttys\n#tty4::respawn:/sbin/getty 38400 tty5\n#tty5::respawn:/sbin/getty 38400 tty6\n...\n</code></pre> <p>If you enter the login shell after startup, you should get an annoying message:</p> QEMU - BusyBox<pre><code>Please press Enter to activate this console.\nstarting pid 59, tty '': '-/bin/sh'\nBusyBox v1.35.0 (2023-04-08 14:55:52 CEST) built-in shell (ash)\nEnter 'help' for a list of built-in commands.\n-/bin/sh: can't access tty; job control turned off\n#\n</code></pre> <p>Without job control, we cannot manage jobs, like termination via Ctrl+C. A quick way is to force <code>ttyAMA0</code> (the emulated board debug serial port) as the default login shell:</p> File: $LAB_PATH/nfsroot/etc/inittab - forced login shell device<pre><code>    ...\n# Start an \"askfirst\" shell on the console (whatever that may be)\nttyAMA0::askfirst:-/bin/sh\n    ...\n</code></pre> <p>TODO: Use some command line tools to comment out the above lines.</p> <p>Create the standard <code>/etc/init.d/rcS</code> startup script, to mount the <code>/proc</code> and <code>/sys</code> filesystems.</p> File: $LAB_PATH/nfsroot/etc/init.d/rcS<pre><code>#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\n</code></pre> <p>Quick typing from the shell:</p> <pre><code>$ mkdir -p etc/init.d/\n$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nEOF\n$ chmod +x etc/init.d/rcS\n</code></pre> <p>Try again with QEMU, and you can notice that those warning messages are now gone.</p> QEMU - BusyBox<pre><code>VFS: Mounted root (nfs filesystem) on device 0:14.\ndevtmpfs: mounted\nFreeing unused kernel image (initmem) memory: 1024K\nRun /sbin/init as init process\nstarting pid 60, tty '': '/etc/init.d/rcS'\nPlease press Enter to activate this console.\nstarting pid 63, tty '/dev/ttyAMA0': '-/bin/sh'\nBusyBox v1.35.0 (2023-04-08 14:55:52 CEST) built-in shell (ash)\nEnter 'help' for a list of built-in commands.\n#\n</code></pre> <p>You can keep the current QEMU instance running for the next paragraphs. We're going to change files on-the-fly; those changes can be accessed directly from the QEMU instance via NFS.</p> <p>You might want to backup the current <code>nfsroot</code>. We're going to use <code>cpio</code> to preserve symlinks.</p> <pre><code>$ cd $LAB_PATH/nfsroot/\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-static.cpio.xz\"\n</code></pre>"},{"location":"qemu/tinysystem/#switching-to-shared-libraries","title":"Switching to shared libraries","text":"<p>Take the <code>hello.c</code> program supplied in the lab <code>data</code> directory. Cross-compile it for ARM, dynamically-linked with the libraries (just use our <code>arm-linux</code> toolchain), and run it on the target. You should face a very misleading <code>not found</code> error, which is not because the <code>hello</code> executable is not found, but because something else was not found while trying to execute this executable.</p> <pre><code>$ cd $LAB_PATH/data/\n$ arm-linux-gcc -o hello hello.c\n$ cp hello ../nfsroot/bin/\n</code></pre> QEMU - BusyBox<pre><code># hello\n-/bin/sh: hello: not found\n</code></pre> <p>It\u2019s missing the <code>ld-uClibc.so.0</code> executable, which is the dynamic linker required to execute any program compiled with shared libraries. Using the <code>find</code> command, look for any library files in the toolchain install directory, and copy them to the <code>lib/</code> directories on the target. We're going to use a regex to find all the matches for possible shared object file name extensions. Also copy any binary executables (like <code>ldd</code>) to their respective fodlers.</p> <pre><code>$ cd \"$TC_BASE/$TC_NAME/sysroot/\"\n$ so_regex=\".+\\.so\\(\\.[0-9]+\\)*\"\n$ find . -regex $so_regex | sort\n./lib/ld-uClibc-1.0.39.so\n./lib/ld-uClibc.so.0\n./lib/ld-uClibc.so.1\n./lib/libatomic.so\n./lib/libatomic.so.1\n./lib/libatomic.so.1.2.0\n./lib/libc.so.0\n./lib/libc.so.1\n./lib/libgcc_s.so\n./lib/libgcc_s.so.1\n./lib/libitm.so\n./lib/libitm.so.1\n./lib/libitm.so.1.0.0\n./lib/libstdc++.so\n./lib/libstdc++.so.6\n./lib/libstdc++.so.6.0.29\n./lib/libthread_db-1.0.39.so\n./lib/libthread_db.so.1\n./lib/libuClibc-1.0.39.so\n./usr/lib/libc.so\n./usr/lib/libthread_db.so\n$ mkdir -p \"$LAB_PATH/nfsroot/lib/\"\n$ mkdir -p \"$LAB_PATH/nfsroot/usr/lib/\"\n$ mkdir -p \"$LAB_PATH/nfsroot/sbin/\"\n$ mkdir -p \"$LAB_PATH/nfsroot/usr/sbin/\"\n$ cp lib/libc.so* \"$LAB_PATH/nfsroot/lib/\"\n$ cp lib/ld-uClibc.so* \"$LAB_PATH/nfsroot/lib/\"\n$ cp usr/bin/ldd \"$LAB_PATH/nfsroot/usr/bin/\"\n</code></pre> <p>Now <code>hello</code> works as expected, and you can also execute <code>ldd</code> against it to see the library dependencies:</p> QEMU - BusyBox<pre><code># hello\nHello world!\n# ldd bin/hello\n        libc.so.0 =&gt; /lib/libc.so.0 (0x76e83000)\n        ld-uClibc.so.1 =&gt; /lib/ld-uClibc.so.0 (0x76f0a000)\n# ldd bin/busybox\n        not a dynamic executable\n</code></pre> <p>If you still get the same error message, work, just try again a few seconds later. Such a delay can be needed because the NFS client can take a little time (at most 30-60 seconds) before seeing the changes made on the NFS server.</p> <p>Once the small test program works, we're going to recompile BusyBox without the static compilation option, so that BusyBox takes advantages of the shared libraries that are now present on the target. Before doing that, measure the size of the busybox executable.</p> <pre><code>$ cd $LAB_PATH\n$ du -h nfsroot/bin/busybox\n360K    nfsroot/bin/busybox\n$ cd busybox/\n$ make menuconfig\n</code></pre> <p>In <code>Settings</code>:</p> <ul> <li>Disable <code>Build static binary (no shared libs)</code> (<code>STATIC</code>)</li> </ul> <p>Now <code>halt</code> and quit QEMU, backup the new configuration, and build BusyBox again. As you will see, the executable is now smaller, because it's using shared libraries.</p> <pre><code>$ cp .config ../busybox-dynamic.config\n$ make clean\n$ make install\n$ du -h ../nfsroot/bin/busybox\n216K    ../nfsroot/bin/busybox\n</code></pre> <p>Launch QEMU again, reaching the BusyBox shell successfully. You can confirm that the current <code>busybox</code> executable depends on shared libraries:</p> QEMU - BusyBox<pre><code># ldd bin/busybox\n        libc.so.0 =&gt; /lib/libc.so.0 (0x76f1e000)\n        ld-uClibc.so.1 =&gt; /lib/ld-uClibc.so.0 (0x76fa5000)\n</code></pre>"},{"location":"qemu/tinysystem/#implement-a-web-interface-for-your-device","title":"Implement a web interface for your device","text":"<p>Replicate <code>$LAB_PATH/data/www/</code> to the <code>/www</code> directory in your target root filesystem.</p> <pre><code>$ cd $LAB_PATH\n$ cp -r data/www/ nfsroot/\n</code></pre> <p>Then, run the BusyBox http server from the BusyBox shell; it will automatically background itself.</p> QEMU - BusyBox<pre><code># /usr/sbin/httpd -h /www/\n</code></pre> <p>Now, test that your web interface works well by opening http://10.0.2.69/index.html within the host machine (Lubuntu VM).</p> <p>See how the dynamic pages are implemented. Very simple, isn\u2019t it?</p> <p>If you use a proxy, configure your host browser so that it doesn\u2019t go through the proxy to connect to the target IP address, or simply disable proxy usage.</p> <p>Finish by adding the command that starts the web server to your startup script, so that it is always started on your target.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ echo \"/usr/sbin/httpd -h /www/\" &gt;&gt; etc/init.d/rcS\n</code></pre> <p>You can <code>reboot</code> BusyBox and see that the web server was started automatically (press Ctrl+C to quit <code>top</code>). You can then <code>halt</code> QEMU.</p> QEMU - BusyBox<pre><code># top\nMem: 14136K used, 104336K free, 0K shrd, 0K buff, 868K cached\nCPU:  0.5% usr  1.5% sys  0.0% nic 97.9% idle  0.0% io  0.0% irq  0.0% sirq\nLoad average: 0.00 0.00 0.00 1/59 66\n  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND\n   66    62 0        R     1016  0.8   0  1.7 top\n   31     2 0        IW       0  0.0   0  0.3 [kworker/0:1-eve]\n    1     0 0        S     1016  0.8   0  0.0 /sbin/init\n   63     1 0        S     1016  0.8   0  0.0 /sbin/init\n   64     1 0        S     1016  0.8   0  0.0 /sbin/init\n   65     1 0        S     1016  0.8   0  0.0 /sbin/init\n   62     1 0        S     1012  0.8   0  0.0 -/bin/sh\n   61     1 0        S     1008  0.8   0  0.0 /usr/sbin/httpd -h /www/\n    8     2 0        IW       0  0.0   0  0.0 [kworker/u8:0-nf]\n   10     2 0        SW       0  0.0   0  0.0 [ksoftirqd/0]\n   11     2 0        IW       0  0.0   0  0.0 [rcu_sched]\n   55     2 0        IW&lt;      0  0.0   0  0.0 [kworker/u9:2-xp]\n   41     2 0        IW&lt;      0  0.0   0  0.0 [kworker/u9:0-xp]\n   46     2 0        IW       0  0.0   0  0.0 [kworker/0:2-eve]\n   29     2 0        SW       0  0.0   0  0.0 [kdevtmpfs]\n   35     2 0        SW       0  0.0   0  0.0 [kcompactd0]\n   43     2 0        IW       0  0.0   0  0.0 [kworker/u8:2-ev]\n    2     0 0        SW       0  0.0   0  0.0 [kthreadd]\n   38     2 0        IW       0  0.0   0  0.0 [kworker/u8:1-nf]\n    6     2 0        IW       0  0.0   0  0.0 [kworker/0:0-eve]\n</code></pre>"},{"location":"qemu/tinysystem/#backup-and-restore","title":"Backup and restore","text":"<p>Everything looks fine now, so you're free to make a backup archive of the dynamic <code>nfsroot</code>:</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-dynamic.cpio.xz\"\n</code></pre> <p>In case you wish to restore the snapshot:</p> <pre><code>$ cd $LAB_PATH\n$ rm -rf nfsroot/\n$ mkdir -p nfsroot/\n$ xzcat nfsroot-dynamic.cpio.xz | cpio -iduv -D nfsroot/\n</code></pre>"},{"location":"qemu/tinysystem/#boot-with-initramfs","title":"Boot with initramfs","text":"<p>It's usual to run an initramfs instead of a boot from NFS: the initramfs copies data from the SD card into RAM, and executes a preliminary boot from there.</p> <p>FYI: https://landley.net/writing/rootfs-howto.html</p> <p>Configure your kernel to include the contents of the <code>nfsroot</code> directory as an initramfs image archive file <code>/initrd.cpio.gz</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ export ARCH=arm\n$ make menuconfig\n$ cp .config \"$LAB_PATH/kernel-initramfs.config\"\n</code></pre> <p>In <code>General setup</code>:</p> <ul> <li> <p>Enable <code>Initial RAM filesystem and RAM disk (initramfs/initrd) support</code> (<code>BLK_DEV_INITRD</code>)</p> </li> <li> <p>Set <code>Initramfs source file(s)</code> (<code>INITRAMFS_SOURCE</code>) = <code>../../tinysystem/nfsroot</code>.</p> </li> <li> <p>Enable <code>Support initial ramdisk/ramfs compressed using gzip</code> (<code>RD_GZIP</code>).</p> </li> </ul> <p>Now <code>&lt;Save&gt;</code> the <code>.config</code> and save a backup copy.</p> <p>Before building and running the updated kernel, in the toplevel directory you have to create an <code>/init</code> link pointing to <code>/sbin/init</code>. This is required because the kernel will try to execute the <code>/init</code> executable \u2014 we simply redirect it to the standard one. You can then archive your initrams image archive.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ ln -s sbin/init init\n</code></pre> <p>You should also mount <code>devtmpfs</code> from the <code>/etc/init.d/rcS</code> script, because it cannot be mounted automatically by the kernel when booting from an initramfs.</p> <pre><code>$ cat &gt; etc/init.d/rcS &lt;&lt;'EOF'\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t devtmpfs dev /dev\n/usr/sbin/httpd -h /www/\nEOF\n</code></pre> <p>You can now rebuild the kernel, <code>make</code> will take care of the changes to rebuild. Copy the newly generated kernel image to the TFTP server. You can see the difference in size between the two <code>zImage</code> versions, since initramfs includes our <code>nfsroot</code>.</p> <pre><code>$ cd \"$LAB_PATH/../kernel/linux/\"\n$ make\n    ...\n  Kernel: arch/arm/boot/zImage is ready\n$ mv /srv/tftp/zImage /srv/tftp/zImage-without-initramfs\n$ cp arch/arm/boot/zImage /srv/tftp/zImage-with-initramfs\n$ cp arch/arm/boot/zImage /srv/tftp/zImage\n$ du -h /srv/tftp/zImage*\n5.6M    /srv/tftp/zImage\n5.6M    /srv/tftp/zImage-with-initramfs\n4.8M    /srv/tftp/zImage-without-initramfs\n</code></pre> <p>You can now launch the QEMU machine, which this time is booting the kernel from initramfs instead of NFS. You won\u2019t need to modify your <code>root=/srv/nfs</code> setting in the kernel command line (<code>bootargs</code>), because it will just be ignored for an initramfs.</p> QEMU - BusyBox<pre><code>    ...\nFreeing unused kernel image (initmem) memory: 2048K\nRun /init as init process\nPlease press Enter to activate this console.\n</code></pre> <p>Let's archive the current state for the future.</p> <pre><code>$ cd \"$LAB_PATH/nfsroot/\"\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/nfsroot-initramfs.cpio.xz\"\n$ cd /srv/tftp\n$ tar cfJv \"$LAB_PATH/zImage-initramfs.tar.xz\" zImage\n</code></pre> <p>In case you wish to restore the snapshot:</p> <pre><code>$ cd $LAB_PATH\n$ rm -rf nfsroot/\n$ mkdir -p nfsroot/\n$ xzcat nfsroot-initramfs.cpio.xz | cpio -iduv -D nfsroot/\n$ tar xfv zImage-initramfs.tar.xz\n$ mv zImage /srv/tftp\n</code></pre> <p>Now go back to booting the system through NFS, which is more convenient for these labs: an initiramfs requires to be rebuilt for each change in your root filesystem, while NFS does it automatically.</p> <pre><code>$ cp /srv/tftp/zImage-without-initramfs /srv/tftp/zImage\n</code></pre> <p>At reboot it should complain about <code>/dev</code> being busy, as we're trying to mount it twice with the updated <code>rcS</code> script; just ignore this message.</p>"},{"location":"qemu/tinysystem/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/toolchain/","title":"Building a cross-compile toolchain","text":""},{"location":"qemu/toolchain/#objectives","title":"Objectives","text":"<p>After this lab, you will be able to:</p> <ul> <li> <p>Configure the crosstool-NG tool.</p> </li> <li> <p>Execute crosstool-NG and build up your own cross-compiling toolchain.</p> </li> </ul>"},{"location":"qemu/toolchain/#required-tools","title":"Required tools","text":"<ul> <li> <p>Ubuntu packages:</p> <p><code>autoconf</code> <code>bison</code> <code>build-essential</code> <code>flex</code> <code>gawk</code> <code>git</code> <code>help2man</code> <code>libncurses-dev</code> <code>libtool-bin</code> <code>qemu-user</code> <code>texinfo</code> <code>unzip</code> <code>wget</code> <code>xz-utils</code></p> </li> <li> <p>crosstool-NG, either from:</p> <ul> <li> <p>GitHub repository</p> </li> <li> <p>Source code archive of commit <code>7622b490</code></p> </li> </ul> </li> </ul>"},{"location":"qemu/toolchain/#source-code","title":"Source code","text":"<p>First, install some packages required for compilation:</p> <pre><code>$ sudo apt install \\\nautoconf bison build-essential cpio flex gawk git help2man \\\nlibncurses-dev libtool-bin texinfo unzip wget xz-utils\n</code></pre> <p>Enter the folder of this lab, that's going to become our main workspace folder:</p> <pre><code>$ LAB_PATH=\"$HOME/embedded-linux-qemu-labs/toolchain\"\n$ cd $LAB_PATH\n</code></pre> <p>You can now get crosstool-NG at the suggested version (git commit <code>7622b490</code>).</p> <p>We're going to clone the git repository into the home folder, creating a new branch named after the embedded-linux-qemu tutorial just for convenience.</p> <pre><code>$ git clone \"https://github.com/crosstool-ng/crosstool-ng\"\n$ cd crosstool-ng/\n$ label=\"7622b490\"\n$ git checkout -b embedded-linux-qemu ${label}\n</code></pre> <p>Alternatively, you can directly unpack an archive of the suggested version. This is usually much faster than cloning a big git repository, despite losing all the features of a git repository.</p> <pre><code>$ label=\"7622b490a359f6cc6b212859b99d32020a8542e7\"\n$ wget \"https://github.com/crosstool-ng/crosstool-ng/archive/${label}.zip\"\n$ unzip \"${label}.zip\"\n$ mv crosstool-ng*/ crosstool-ng\n</code></pre> <p>See: git commit hash expansion</p>"},{"location":"qemu/toolchain/#bootstrap","title":"Bootstrap","text":"<p>Now that the source code is available, its content requires some initial setup to become available. The local <code>bootstrap</code> executable takes care of this initial setup.</p> <pre><code>$ cd $LAB_PATH/crosstool-ng/\n$ ./bootstrap\n</code></pre> <p>We're going to compile and install everything locally, so you must configure the code base for that, via the canonical <code>configure</code> executable. To improve compile time from now on, let's provide the number of processors to <code>make</code>.</p> <pre><code>$ export MAKEFLAGS=-j$(nproc)\n$ ./configure --enable-local\n$ make\n</code></pre> <p>From now on, the generated <code>ct-ng</code> executable is our main command for the toolchain generation.</p>"},{"location":"qemu/toolchain/#configuration","title":"Configuration","text":"<p>A single installation of crosstool-NG allows to produce as many toolchains as you want, for different architectures, with different C libraries and different versions of the various components.</p> <p>crosstool-NG comes with a set of ready-made configuration files for various typical setups, called samples. They can be listed by calling the <code>list-samples</code> command.</p> <p>We're going to load the sample for the ARM Cortex A9 processor, so let's filter the results:</p> <pre><code>$ ./ct-ng list-samples | grep a9\n[L..X]   arm-cortexa9_neon-linux-gnueabihf\n[L..X]   x86_64-w64-mingw32,arm-cortexa9_neon-linux-gnueabihf\n</code></pre> <p>Our target sample is <code>arm-cortexa9_neon-linux-gnueabihf</code>, so let's configure for it, generating a <code>.config</code> file:</p> <pre><code>$ ./ct-ng arm-cortexa9_neon-linux-gnueabihf\n    ...\nNow configured for \"arm-cortexa9_neon-linux-gnueabihf\"\n</code></pre> <p>We can refine the configuration via a useful user interface called <code>menuconfig</code>:</p> <pre><code>$ ./ct-ng menuconfig\n</code></pre> <p>See: <code>menuconfig</code></p> <p>In <code>Debug facilities</code>:</p> <ul> <li>Remove all the options here.   Some debugging tools can be provided in the toolchain, but they can also be built by filesystem building tools. Do this before anything else: removing features often messes up elsewhere (IPv6 and WCHAR for example)!</li> </ul> <p>In <code>Path and misc options</code>:</p> <ul> <li> <p>To resume a failed compilation, enable the following options.   Without these, you have to restart the whole compilation from scratch, which usually takes a long time.</p> <ul> <li>Enable <code>Debug crosstool-NG</code> (<code>DEBUG_CT</code>)</li> <li>Enable <code>Save intermediate steps</code> (<code>CT_DEBUG_CT_SAVE_STEPS</code>)</li> <li>Enable <code>gzip saved states</code> (<code>CT_DEBUG_CT_SAVE_STEPS_GZIP</code>)</li> <li>Enable <code>Interactive shell on failed commands</code> (<code>CT_DEBUG_INTERACTIVE</code>)</li> </ul> </li> <li> <p>Set <code>Number of parallel jobs</code> (<code>CT_PARALLEL_JOBS</code>) = number of processors.   This improves the performance of the building pipeline.</p> </li> <li> <p>Set <code>Maximum log level to see:</code> (<code>LOG_DEBUG</code>) = <code>DEBUG</code>.   This way we can have more details on what happened during the build in case something went wrong.   This isn't strictly required, and might produce too many messages. I'm keeping it to <code>EXTRA</code> actually.</p> </li> </ul> <p>In <code>Toolchain options</code>:</p> <ul> <li> <p>Set <code>Tuple's vendor string</code> (<code>TARGET_VENDOR</code>) = <code>training</code>.</p> </li> <li> <p>Set <code>Tuple's alias</code> (<code>TARGET_ALIAS</code>) = <code>arm-linux</code>.   This way, we will be able to use the compiler as <code>arm-linux-gcc</code> instead of  <code>arm-training-linux-uclibcgnueabihf-gcc</code>, which is much longer to type.</p> </li> </ul> <p>In <code>Operating System</code>:</p> <ul> <li>Set <code>Version of linux</code> = <code>5.15.x</code> version that is proposed.   We choose this version because this matches the version of the kernel we will run on the board.   At least, the version of the kernel headers are not more recent (which might be incompatible).</li> </ul> <p>In <code>C-library</code>:</p> <ul> <li> <p>Set <code>C library</code> (<code>LIBC_UCLIBC_NG</code>) = <code>uClibc-ng</code>.</p> </li> <li> <p>Keep the default version that is proposed.</p> </li> <li> <p>Enable <code>Add support for IPv6</code> (<code>LIBC_UCLIBC_IPV6</code>).   That's needed to use the toolchain in Buildroot, which only accepts toolchains with IPv6 support.</p> </li> <li> <p>Enable <code>Add support for WCHAR</code> (<code>LIBC_UCLIBC_WCHAR</code>).</p> </li> <li> <p>Enable <code>Support stack smashing protection (SSP)</code> (<code>LIBC_UCLIBC_HAS_SSP</code>).</p> </li> </ul> <p>In <code>C compiler</code>:</p> <ul> <li> <p>Set <code>Version of gcc</code> = <code>11.3.0</code>.   We need to stick to GCC 11.x, because Buildroot 2022.02 (which we are going to use later) doesn't support GCC 12.x toolchains yet (released after).</p> </li> <li> <p>Enable <code>C++</code> (<code>CC_LANG_CXX</code>).</p> </li> </ul> <p>Do cross-check everything now! It can happen that, when changing feature states, some overlooked dependency chains mess up with the configuration! For example:</p> <p>defconfig <code>arm-cortex_a8-linux-gnueabi</code> \u21d2 <code>DEBUG_GDB=y</code> \u21d2 <code>LIBC_UCLIBC_IPV6=y</code></p> <p>So, it looked like IPv6 support was ok. But, after removing <code>gdb</code> (<code>DEBUG_GDB=n</code>) from the <code>Debug facilities</code>:</p> <p><code>DEBUG_GDB=n</code> \u21d2 <code>LIBC_UCLIBC_IPV6=n</code></p> <p>We could have forced <code>LIBC_UCLIBC_IPV6=y</code> by pressing Y even if it looked automatically enabled (marked with <code>-*-</code>), but I've found no easy visual feedback to ensure that. So, cross-checking before leaving is strongly encouraged! I've lost a lot of time re-building the toolchain because of overlooking these naiveities, just because Buildroot slammed errors in my face so late!</p> <p>You can now <code>&lt;Save&gt;</code> this configuration to the default <code>.config</code> file.</p> <p>It's best to save a back-up copy as well:</p> <pre><code>$ cp .config ../crosstool-ng.config\n</code></pre> <p>You'd better also create the <code>~/src/</code> folder, where crosstool-NG stores the downloaded tarballs by default. It's handy to store them in case of any errors or cleanup, to avoid repeated downloads.</p> <pre><code>$ mkdir -p ~/src/\n</code></pre>"},{"location":"qemu/toolchain/#build","title":"Build","text":"<p>Run the <code>build</code> command:</p> <pre><code>$ ./ct-ng build\n</code></pre> <p>The build takes quite a long time to perform \u2014 a clean build took around 50 minutes on an Intel i7 7700 laptop with 4 cores, of course within the Lubuntu VM. It requires a stable internet connection.</p> <p>In case of any errors, the interactive error shell can help to resume compilation from the failed step. Possible errors might occur because of an unstable connection, or because the VM was provided a small amount of RAM (suggested \u2265 4 GB).</p> <p>The toolchain is installed by default under <code>~/x-tools/</code>. In our example: <code>~/x-tools/arm-training-linux-uclibcgnueabihf/</code>. That's something you could have changed in the configuration of crosstool-NG.</p>"},{"location":"qemu/toolchain/#backup-and-restore","title":"Backup and restore","text":"<p>It's best to save an archive of the generated toolchain, because building times can be very long. Let's archive it into the folder of the current lab.</p> <p>We're going to use <code>cpio</code> instead of the common <code>tar</code> to preserve symlinks as they are within the filesystem.</p> <p>FYI: https://linuxconfig.org/how-to-create-and-extract-cpio-archives-on-linux-examples</p> <pre><code>$ pushd .\n$ TC_NAME=\"arm-training-linux-uclibcgnueabihf\"\n$ TC_BASE=\"$HOME/x-tools/$TC_NAME\"\n$ cd $TC_BASE/..\n$ find . -depth -print0 | cpio -ocv0 | xz &gt; \"$LAB_PATH/${TC_NAME}.cpio.xz\"\n$ popd\n</code></pre> <p><code>pushd</code>/<code>popd</code> allow to push/pop the current directory (<code>pwd</code>) against the directory stack (<code>dirs</code>).</p> <p>To restore it under <code>~/x-tools/</code>, just unpack the backup archive there:</p> <pre><code>$ cd $LAB_PATH\n$ sudo rm -rf $TC_BASE\n$ mkdir -p \"$HOME/x-tools/\"\n$ xzcat \"${TC_NAME}.cpio.xz\" | cpio -iduv -D \"$HOME/x-tools/\"\n</code></pre>"},{"location":"qemu/toolchain/#quick-test","title":"Quick test","text":"<p>The toolchain can be called by adding the generated <code>bin</code> folder to your <code>PATH</code> environment variable.</p> <pre><code>$ export PATH=\"$TC_BASE/bin:$PATH\"\n</code></pre> <p>You can now compile the simple <code>hello.c</code> with our new shiny <code>arm-linux-gcc</code> shorthand:</p> <pre><code>$ cd $LAB_PATH\n$ arm-linux-gcc -o hello hello.c\n</code></pre> <p>You can use the <code>file</code> command on your binary to make sure it has correctly been compiled for the ARM architecture.</p> <pre><code>$ file hello\nhello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, not stripped\n</code></pre> <p>Did you know that you can still execute this binary from your x86 host? To do this, install the QEMU user emulator, which just emulates target instruction sets, not an entire system with devices.</p> <pre><code>$ sudo apt install qemu-user\n</code></pre> <p>Try to run QEMU with the <code>hello</code> executable generated with our toolchain:</p> <pre><code>$ qemu-arm hello\nqemu-arm: Could not open '/lib/ld-uClibc.so.0': No such file or directory\n</code></pre> <p>What's happening is that <code>qemu-arm</code> is missing the shared C library (compiled for ARM) that this binary uses. Let's find it in our newly compiled toolchain:</p> <pre><code>$ find ~/x-tools/ -name ld-uClibc.so.0\n/home/me/x-tools/arm-training-linux-uclibcgnueabihf/arm-training-linux-uclibcgnueabihf/sysroot/lib/ld-uClibc.so.0\n</code></pre> <p>We can now use the <code>-L</code> option of <code>qemu-arm</code> to let it know where shared libraries are:</p> <pre><code>$ qemu-arm -L \"$TC_BASE/$TC_NAME/sysroot/\" hello\nHello world!\n</code></pre>"},{"location":"qemu/toolchain/#cleaning-up","title":"Cleaning up","text":"<p>To save about 11 GB of storage space, run the <code>clean</code> command in the crosstool-NG source directory.</p> <pre><code>$ ./ct-ng clean\n</code></pre> <p>This removes the source code of the toolchain components, as well as all the generated files that are now useless, since the toolchain has been installed in <code>~/x-tools</code>, and we made a back-up archive.</p> <p>Do this only if you have limited storage space. In case you made a mistake in the toolchain configuration, you may need to run crosstool-NG again to rebuild everything form scratch \u2014 keeping generated files would save a significant amount of time.</p>"},{"location":"qemu/toolchain/#licensing","title":"Licensing","text":"<p>This document is an extension to: Embedded Linux System Development - Practical Labs - QEMU Variant  \u2014 \u00a9 2004-2023, Bootlin https://bootlin.com/, <code>CC-BY-SA-3.0</code> license.</p>"},{"location":"qemu/virtualbox/","title":"Host VM","text":"<p>I chose to use a virtual machine as the host machine, so that I won't mess with my physical machines. Moreover, I can bring it around on an USB hard disk!</p> <p>I chose VirtualBox as my VM, simply because it's a freely available VM I've used for a long time. My current version is 7.0.6, but it shouldn't matter much as far as I know. I installed this VirtualBox on several Windows 10 machines successfully; this is the VM host OS.</p> <p>As the VM guest OS I chose Lubuntu 22.04 LTS. I know that many prefer a standard Debian, but I find Ubuntu easier to setup \u2014 I don't want to waste too much time configuring  the host machine.</p> <p>Lubuntu is rather lightweight and quick, with no frills, while still being an officially supported Linux distro.</p> <p>The LTS was chosen because it's in the middle of its planned life, so it's mature enough to get stable results for enough time.</p> <p>Furthermore, 22.04 LTS is officially supported by several tools and frameworks, including Yocto.</p>"},{"location":"qemu/virtualbox/#required-tools","title":"Required Tools","text":"<ul> <li> <p>VirtualBox 7.0.6   or later</p> </li> <li> <p>Lubuntu 22.04 LTS (Jammy Jellyfish)   or another Ubuntu 22.04 LTS</p> </li> <li> <p>Training lab data</p> </li> </ul>"},{"location":"qemu/virtualbox/#vm-guest-os-installation","title":"VM guest OS installation","text":"<p>First, install VirtualBox, which should be very straightforward.</p> <p>Then, create a new virtual machine.</p> <p>Important VM specs:</p> <ul> <li> <p>Hard Disk \u2265 32 GB</p> <ul> <li>Dynamically allocated is fine</li> <li>Enable <code>Use Host I/O cache</code> to avoid hiccups</li> </ul> </li> <li> <p>CD drive with the Lubuntu ISO file as a <code>Live CD/DVD</code></p> </li> <li> <p>RAM \u2265 4 GB</p> <ul> <li>With less RAM, some toolchains might get stuck in swap hell</li> </ul> </li> <li> <p>Processors = number of physical CPU cores</p> <ul> <li>VM host OS still usable</li> <li>good performance</li> <li>might not leverage hyperthreading</li> <li>I'm using <code>Enable PAE/NX</code> as an added bonus</li> <li>suggested \u2265 4 physical cores of the host machine</li> </ul> </li> <li> <p>Network via NAT</p> <ul> <li>No need for a proper network as with physical boards</li> </ul> </li> </ul> <p>Launch the VM and wait for it to load the Live OS straight from the emulated DVD drive.</p> <p>When available, let's run the installer from the desktop. No particular options have to be set, so leave the defauit ones if in doubt.</p> <p>When prompted for formatting options, just let the installer format the whole partition with swap on file.</p> <p>When asked for names and passwords, I'd opt for covnenience:</p> <ul> <li>Machine name: <code>vm</code></li> <li>User name: <code>me</code></li> <li>Password: none</li> <li>Automatic login: enabled</li> </ul> <p>After a few minutes the installer should have terminated, and the VM can be restarted to enter the installed VM guest OS.</p>"},{"location":"qemu/virtualbox/#vm-guest-os-configuration","title":"VM guest OS configuration","text":"<p>Once the installed VM guest OS is run, it should install any updates from the internet.</p> <p>For shell commands I typically use the default terminal application provided by the OS. In the case of Lubuntu, it's QTerminal, which can be accessed either via the start menu, or by pressing Ctrl+Alt+T.</p> <p>So, let's update the system, with the canonical commands for Debian-based Linux distros:</p> <pre><code>$ sudo apt update\n$ sudo apt dist-upgrade\n</code></pre> <p>It most probably installed some Linux kernel updates, so let's reboot to make changes effective:</p> <pre><code>$ sudo reboot\n</code></pre> <p>This time it's best to add VirtualBox Guest Additions for the best VM experience.</p> <p>From the <code>Devices</code> menu, select <code>Insert Guest Additions CD Image...</code>. Ignore any automatic actions; we're going to install them from the shell:</p> <pre><code>$ cd /media/me/VBox_GAs_7.0.6/\n$ sudo ./VBoxLinuxAdditions.run\n</code></pre> <p>You can usually type <code>cd /media</code> and press the Tab key repeatedly for automatic completion; the same for the run script.</p> <p>If you double-press Tab, the shell prints some suggestions. It's often handy to click the desired suggestion with the central mouse button to automatically append it to the command line.</p> <p>After the installation has finished, it's best to reboot again.</p> <p>You're now free to resize the window, or enter seamless mode. I usually select the latter, so that I can open a PDF in the host OS, and superimpose Lubuntu shell windows seamlessly.</p>"},{"location":"qemu/virtualbox/#networking","title":"Networking","text":"<p>There's no special configuration to be made to follow this tutorial. You can leave the VirtualBox emulated network interface configured as NAT, which makes life easier for our course. Just make sure that the VM guest OS can reach the internet in a stable and possibly fast way.</p> <p>The conventions for this tutorial are the following:</p> <ul> <li>Network mask: <code>255.255.255.0</code> = <code>/24</code>, the 24 most significant bits.</li> <li>Host machine IP: <code>10.0.2.15</code>, the default one for of Ubuntu VirtualBox VM.</li> <li>Target machine IP: <code>10.0.2.69</code>, an arbitrary target IP you can spot and remember easily.</li> </ul>"},{"location":"qemu/virtualbox/#training-lab-data","title":"Training lab data","text":"<p>You should retrieve the training lab data from its Bootlin page:</p> <pre><code>$ cd ~\n$ wget https://bootlin.com/doc/training/embedded-linux-qemu/embedded-linux-qemu-labs.tar.xz\n$ tar xfv embedded-linux-qemu-labs.tar.xz\n</code></pre> <p>You can give a quick look to the folder structure with the <code>tree</code> command:</p> <pre><code>$ tree ~/embedded-linux-qemu-labs/\n/home/me/embedded-linux-qemu-labs/\n\u251c\u2500\u2500 appdev\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 app.c\n\u251c\u2500\u2500 bootloader\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 u-boot\n\u251c\u2500\u2500 buildroot\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 mpd.conf\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 music\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 1-sample.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 2-arpent.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 3-chronos.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 4-land-of-pirates.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 5-ukulele-song.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 6-le-baguette.ogg\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 7-fireworks.ogg\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 README.txt\n\u251c\u2500\u2500 debugging\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 vista-emulator.c\n\u251c\u2500\u2500 tinysystem\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 data\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 busybox-1.35.config\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 hello.c\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 www\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cgi-bin\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 cpuinfo\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 list\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 reboot\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 upload\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 upload.c\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 upload.cfg\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2514\u2500\u2500 uptime\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 gohome.png\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 index.html\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 kshutdown.png\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 upload\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 BadPage.html\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 files\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 adult-small.png\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 brick.png\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 linux-blackfin.jpg\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u251c\u2500\u2500 linux-kernel-dev-book.jpg\n\u2502\u00a0\u00a0             \u2502\u00a0\u00a0 \u2514\u2500\u2500 lkn-small.jpg\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 OkPage.html\n\u2514\u2500\u2500 toolchain\n    \u2514\u2500\u2500 hello.c\n15 directories, 32 files\n</code></pre>"}]}